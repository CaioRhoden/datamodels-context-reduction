[{"task_id": 10237, "output": ["class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [[x1 - L // 2, y1 - L // 2], [x1 - L // 2, y2 + L // 2], [x2 + L // 2, y2 + L // 2], [x2 + L // 2, y1 - L // 2]]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        A = [0, 0]\n        B = [2 * L, 0]\n        C = [2 * L, 2 * L]\n        D = [0, 2 * L]\n        return sorted(A + B + C + D)", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x, y = points[0]\n        dx = L - 2 * x\n        dy = L - 2 * y\n        return sorted([[x - dx, y], [x, y], [x + dx, y], [x, y + dy]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * i + j * j <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        x, y = p\n        cx = (L / 2) + (x / 2)\n        cy = (L / 2) + (y / 2)\n        return sorted([[cx - L, cy - L], [cx - L, cy + L], [cx + L, cy - L], [cx + L, cy + L]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[1] <= L2[1]))\nimport math\n\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        a = p2[0] - p1[0]\n        b = p2[1] - p1[1]\n        c = math.sqrt(a * a + b * b) / 2\n        d = L - c\n        return [(p1[0] - d, p1[1]), (p1[0] + d, p1[1]), (p1[0], p1[1] - d), (p1[0], p1[1] + d)]", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n#Example usage:\nsolution = Solution()\nprint(solution.rectanglesInCircle(1))  # Output: 1\nprint(solution.rectanglesInCircle(2))  # Output: 8", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or R1[3] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, q1 = points\n        p2, q2 = points\n        mid_x = (p1[0] + q1[0]) / 2\n        mid_y = (p1[1] + q1[1]) / 2\n        p1 = (mid_x - L / 2, mid_y - L / 2)\n        q1 = (mid_x + L / 2, mid_y - L / 2)\n        p2 = (mid_x - L / 2, mid_y + L / 2)\n        q2 = (mid_x + L / 2, mid_y + L / 2)\n        return [p1, q1, p2, q2]\nimport math\n\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, q1 = points\n        p2, q2 = points\n        p1 = (p1[0] - L / 2, p1[1] - L / 2)\n        q1 = (q1[0] - L / 2, q1[1] - L / 2)\n        p2 = (p2[0] - L / 2, p2[1] + L / 2)\n        q2 = (q2[0] - L / 2, q2[1] + L / 2)\n        p3 = (p1[0] + L / 2, p1[1] - L / 2)\n        q3 = (q1[0] + L / 2, q1[1] - L / 2)\n        p4 = (p2[0] + L / 2, p2[1] + L / 2)\n        q4 = (q2[0] + L / 2, q2[1] + L / 2)\n        return [p1, q1, p2, q2, p3, q3, p4, q4]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, int(d) + 1):\n            for j in range(1, int(d) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points[0]\n        qx, qy = points[1]\n        return sorted([int((px + qx) / 2), int((py + qy) / 2), int((px + qx) / 2), int((py + qy) / 2)])", "class Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        px1 = px - L / 2\n        py1 = py - L / 2\n        qx1 = qx - L / 2\n        qy1 = qy - L / 2\n        return [px1, py1, qx1, qy1]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        ax, ay = x1 - L / 2, y1 - L / 2\n        bx, by = x2 + L / 2, y2 + L / 2\n        cx, cy = x2 + L / 2, y1 - L / 2\n        dx, dy = x1 - L / 2, y2 + L / 2\n        return sorted([ax, ay, bx, by, cx, cy, dx, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        a = (p[0] - L/2, p[1])\n        b = (q[0] + L/2, q[1])\n        c = (q[0] - L/2, q[1])\n        d = (p[0] + L/2, p[1])\n        return sorted([a, b, c, d], key=lambda x: (x[0], x[1]))", "class Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the average of the x-coordinates and y-coordinates of p and q\n        avg_x = (points[0][0] + points[1][0]) / 2\n        avg_y = (points[0][1] + points[1][1]) / 2\n        \n        # Calculate the difference between the x-coordinates and y-coordinates of p and q\n        diff_x = points[1][0] - points[0][0]\n        diff_y = points[1][1] - points[0][1]\n        \n        # Calculate the coordinates of points A, B, C, and D\n        A = (avg_x - diff_x/2, avg_y - diff_y/2)\n        B = (avg_x + diff_x/2, avg_y - diff_y/2)\n        C = (avg_x + diff_x/2, avg_y + diff_y/2)\n        D = (avg_x - diff_x/2, avg_y + diff_y/2)\n        \n        # Return the coordinates of points A, B, C, and D in sorted order\n        return sorted([A, B, C, D])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        x = (q[0] - p[0]) / 2\n        y = (q[1] - p[1]) / 2\n        return sorted([p[0] - x, p[1] - y, p[0] + x, p[1] + y], key=lambda x: x)", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\n\n    def doOverlap(self, L1, R1, L2, R2):\n        if L2[0] > R1[0] or R1[1] > L2[1]:\n            return 0\n        if R2[1] > L1[1] or L1[0] > R2[0]:\n            return 0\n        return 1\n\n    def findCornerPoints(self, L, points):\n        return [[points[0][0] - L / 2, points[0][1] - L / 2],\n                [points[0][0] + L / 2, points[0][1] - L / 2],\n                [points[0][0] + L / 2, points[0][1] + L / 2],\n                [points[0][0] - L / 2, points[0][1] + L / 2]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [(-x2, -y2), (-x2, y2), (x1, y2), (x1, -y2)]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return [(L - points[0][0]) // 2, (L - points[0][1]) // 2], [(L - points[0][0]) // 2, (L - points[1][1]) // 2], [(L + points[0][0]) // 2, (L - points[0][1]) // 2], [(L + points[0][0]) // 2, (L + points[1][1]) // 2]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = R * R\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return (L2[0] < R1[0] and L1[0] < R2[0] and L2[1] < R1[1] and L1[1] < R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        A = (0, 0)\n        B = (2 * p[0], 0)\n        C = (2 * q[0], 2 * p[1])\n        D = (2 * q[0], 2 * q[1])\n        return [A, B, C, D]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, int(ds) + 1):\n            for j in range(1, int(ds) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or (R1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        a, b = points\n        return sorted([(-L, a[1]), (0, a[1]), (L, a[1]), (L, -b[1])])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        mid_x = (px + qx) / 2\n        mid_y = (py + qy) / 2\n        corner_points = [[(mid_x - L / 2, mid_y - L / 2), (mid_x + L / 2, mid_y - L / 2), (mid_x + L / 2, mid_y + L / 2), (mid_x - L / 2, mid_y + L / 2)]]\n        return corner_points\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        length = (L - 2 * min(px, qx)) * 2\n        mid_x = (px + qx) / 2\n        mid_y = (py + qy) / 2\n        corner_points = [[(mid_x - length / 2, mid_y - L / 2), (mid_x + length / 2, mid_y - L / 2), (mid_x + length / 2, mid_y + L / 2), (mid_x - length / 2, mid_y + L / 2)]]\n        return corner_points", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nimport math\n\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x, y = points[0]\n        x2, y2 = points[1]\n        return sorted([[x - L / 2, y - L / 2], [x - L / 2, y + L / 2], [x2 - L / 2, y + L / 2], [x2 - L / 2, y - L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\n\n    def findCornerPoints(self, L, points):\n        x = (points[0][0] + points[1][0]) / 2\n        y = (points[0][1] + points[1][1]) / 2\n        return [x - L / 2, y - L / 2, x + L / 2, y + L / 2]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R ** 2\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points[0]\n        qx, qy = points[1]\n        cx = (px + qx) / 2\n        cy = (py + qy) / 2\n        dx = (L - abs(px - qx)) / 2\n        dy = (L - abs(py - qy)) / 2\n        return sorted([[cx - dx, cy - dy], [cx + dx, cy - dy], [cx - dx, cy + dy], [cx + dx, cy + dy]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, qx = points\n        return sorted([(px - L // 2, qx - L // 2), (px - L // 2, qx + L // 2), (px + L // 2, qx + L // 2), (px + L // 2, qx - L // 2)])", "class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        x1, y1, x2, y2 = rec1\n        a, b, c, d = rec2\n        return (max(x1, a) < min(x2, c) and \n                max(y1, b) < min(y2, d))", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x, y = points\n        return [x - L // 2, y - L // 2], [x + L // 2, y - L // 2], [x - L // 2, y + L // 2], [x + L // 2, y + L // 2]", "class Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return [[p[0] - (p[0] - q[0]), p[1] - (p[1] - q[1])], \n                [p[0] + (p[0] - q[0]), p[1] + (p[1] - q[1])], \n                [q[0] - (p[0] - q[0]), q[1] - (p[1] - q[1])], \n                [q[0] + (p[0] - q[0]), q[1] + (p[1] - q[1])]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n        \n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        \n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1]:\n            return 0\n        return 1\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or R1[1] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        ax, ay = points[0]\n        bx, by = points[1]\n        return sorted([[ax - L / 2, ay], [ax + L / 2, ay], [bx, by - L / 2], [bx, by + L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        a = (L - abs(x2 - x1)) // 2\n        b = (L - abs(y2 - y1)) // 2\n        return [(x1 - a, y1 - b), (x1 + a, y1 + b), (x2 - a, y2 + b), (x2 + a, y2 - b)]", "class Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        return sorted([(-p1[0] + p2[0], -p1[1] + p2[1]), \n                      (p1[0] + p2[0], -p1[1] + p2[1]), \n                      (-p1[0] + p2[0], p1[1] + p2[1]), \n                      (p1[0] + p2[0], p1[1] + p2[1])])", "class Solution:\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] < L2[0] or R2[0] < L1[0] or R1[1] > R2[1] or R2[1] > R1[1])\n\n    def findCornerPoints(self, L, points):\n        p = (points[0][0] - points[1][0] // 2, points[0][1] - points[1][1] // 2)\n        q = (points[0][0] + points[1][0] // 2, points[0][1] + points[1][1] // 2)\n        return [tuple(p), tuple(q), tuple(q), tuple(p)]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1 >= L2 or L2 >= R1 or L1 <= R2 or R1 <= L2)\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [(max(0, x1 - L), max(0, y1 - L)), (max(0, x1 - L), max(0, y2 - L)), \n                (max(0, x2 - L), max(0, y1 - L)), (max(0, x2 - L), max(0, y2 - L))]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, qx = points\n        return [(px - L / 2, qx - L / 2), (px - L / 2, qx + L / 2), (px + L / 2, qx + L / 2), (px + L / 2, qx - L / 2)]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        px, py = points\n        cx, cy = points\n        a = L - abs(px - cx)\n        b = L - abs(py - cy)\n        return sorted([px - a / 2, py - b / 2, px + a / 2, cy + b / 2])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1]:\n            return 0\n        return 1\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] > R2[0] or R1[1] < L2[1]:\n            return 0\n        if R2[1] < L1[1] or L2[0] > R1[0]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return sorted([(p[0] - L // 2, p[1] - L // 2), (p[0] + L // 2, p[1] - L // 2), (p[0] - L // 2, p[1] + L // 2), (p[0] + L // 2, p[1] + L // 2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\n\n    def findCornerPoints(self, L, points):\n        px1, py1 = points[0]\n        px2, py2 = points[1]\n        return sorted([[px1 - L / 2, py1 - L / 2],\n                      [px1 + L / 2, py1 - L / 2],\n                      [px1 - L / 2, py1 + L / 2],\n                      [px1 + L / 2, py1 + L / 2]])\n\n# Test the functions\nsolution = Solution()\n\n# Example 1:\nprint(solution.rectanglesInCircle(1))  # Output: 1\nprint(solution.rectanglesInCircle(2))  # Output: 8\n\n# Example 2:\nprint(solution.doOverlap([0, 0, 2, 2], [1, 1, 3, 3]))  # Output: 1\nprint(solution.doOverlap([0, 0, 1, 1], [1, 0, 2, 1]))  # Output: 0\nprint(solution.doOverlap([0, 0, 1, 1], [2, 2, 3, 3]))  # Output: 0\n\n# Example 3:\nprint(solution.findCornerPoints(2, [1, 0]))  # Output: [[0.0, 0.0], [0.0, 2.0], [2.0, 0.0], [2.0, 2.0]]\nprint(solution.findCornerPoints(2.8284, [1, 1]))  # Output: [[-2.0, 0.0], [0.0, -2.0], [0.0, 2.0], [2.0, 0.0]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] <= R2[0] and R1[0] >= L2[0] and L1[1] <= R2[1] and R1[1] >= L1[1]:\n            return 1\n        return 0\nclass Solution:\n    def findCornerPoints(self, L, points):\n        mid_x = (points[0][0] + points[1][0]) / 2\n        mid_y = (points[0][1] + points[1][1]) / 2\n        return [mid_x - L / 2, mid_y - L / 2], [mid_x + L / 2, mid_y - L / 2], [mid_x - L / 2, mid_y + L / 2], [mid_x + L / 2, mid_y + L / 2]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, ds + 1):\n            for j in range(1, ds + 1):\n                if i * i + j * j <= ds * ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, qx = points\n        L = float(L)\n        return [[px - L / 2, qx - L / 2], [px - L / 2, qx + L / 2], [px + L / 2, qx + L / 2], [px + L / 2, qx - L / 2]]\nclass Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the coordinates of points A, B, C, D\n        Ax, Ay = (points[0][0] - L/2, points[0][1] - L/2)\n        Bx, By = (points[0][0] + L/2, points[0][1] + L/2)\n        Cx, Cy = (points[1][0] + L/2, points[1][1] + L/2)\n        Dx, Dy = (points[1][0] - L/2, points[1][1] - L/2)\n        \n        # Return the corner points in sorted order\n        return sorted([Ax, Ay, Bx, By, Cx, Cy, Dx, Dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        return sorted([(-p[0] + q[0], -p[1] + q[1]), (p[0] - q[0], p[1] - q[1]), (p[0] + q[0], p[1] + q[1]), (q[0] - p[0], q[1] - p[1])])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1]:\n            return False\n        return True\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        return sorted([(p[0] - L, p[1] - L), (p[0] + L, p[1] - L), (p[0] - L, p[1] + L), (p[0] + L, p[1] + L)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        return sorted([[p[0] - L / 2, p[1] - L / 2], [p[0] + L / 2, p[1] - L / 2], [p[0] + L / 2, p[1] + L / 2], [p[0] - L / 2, p[1] + L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R ** 2\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L2[0] > R1[0] or R1[1] > L2[1]:\n            return 0\n        if R2[1] > L1[1] or L1[0] > R2[0]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        return sorted([[(p1[0] - L // 2), (p1[1] - L // 2)], [(p1[0] + L // 2), (p1[1] - L // 2)], [(p1[0] - L // 2), (p1[1] + L // 2)], [(p1[0] + L // 2), (p1[1] + L // 2)]])", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        # Calculate the coordinates of point A (midpoint of AD)\n        A_x = points[0][0] - (L - points[0][1]) / 2\n        A_y = points[0][1]\n\n        # Calculate the coordinates of point D (opposite of A)\n        D_x = points[0][0] + (L - points[0][1]) / 2\n        D_y = points[0][1]\n\n        # Calculate the coordinates of point B (midpoint of BC)\n        B_x = points[1][0] + (L - points[1][1]) / 2\n        B_y = points[1][1]\n\n        # Calculate the coordinates of point C (opposite of B)\n        C_x = points[1][0] - (L - points[1][1]) / 2\n        C_y = points[1][1]\n\n        # Return the coordinates of the four points in sorted order\n        return sorted([[A_x, A_y], [B_x, B_y], [C_x, C_y], [D_x, D_y]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([[0, 0], [0, L], [L, L], [L, 0]], key=lambda x: (x[0], x[1]))", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x, y = points\n        a = (x - L // 2, y)\n        b = (x + L // 2, y)\n        c = (x, y - L // 2)\n        d = (x, y + L // 2)\n        return sorted([a, b, c, d])", "class Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return sorted([tuple(sorted([p[0] - L/2, p[1] - L/2, p[0] + L/2, p[1] + L/2]))])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * i + j * j <= (2 * R) ** 2:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return [(points[0][0] - points[1][0], points[0][1] - points[1][1]),\n                (points[0][0] + points[1][0], points[0][1] + points[1][1]),\n                (points[0][0] + points[1][0], points[0][1] - points[1][1]),\n                (points[0][0] - points[1][0], points[0][1] + points[1][1])]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        ax = (px - qx) / 2\n        ay = (py - qy) / 2\n        bx = px + ax\n        by = py + ay\n        cx = qx - ax\n        cy = qy - ay\n        dx = qx + cx\n        dy = qy + cy\n        return sorted([list(map(int, [ax, ay, bx, by, cx, cy, dx, dy]))]\n                    , key=lambda x: x[0])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * i + j * j <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (R1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        x1, y1 = p1\n        x2, y2 = p2\n        ax = x1 - L / 2\n        ay = y1 - L / 2\n        bx = x2 + L / 2\n        by = y2 + L / 2\n        return [[ax, ay], [ax, by], [bx, ay], [bx, by]]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        # Calculate the midpoint coordinates\n        px, py = points[0]\n        qx, qy = points[1]\n        \n        # Calculate the x and y coordinates of the corner points\n        ax = px - (qx - px) / 2\n        ay = py - (qy - py) / 2\n        bx = qx + (qx - px) / 2\n        by = qy + (qy - py) / 2\n        cx = L - bx\n        cy = L - ay\n        dx = L - cx\n        dy = L - by\n        \n        # Return the coordinates of the corner points in sorted order\n        return sorted([ax, ay, bx, by, cx, cy, dx, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        mid_x = (points[0][0] + points[1][0]) / 2\n        mid_y = (points[0][1] + points[1][1]) / 2\n        return sorted([(-mid_x + points[0][0], -mid_y + points[0][1]),\n                      (-mid_x + points[1][0], -mid_y + points[1][1]),\n                      (mid_x - points[0][0], mid_y - points[0][1]),\n                      (mid_x - points[1][0], mid_y - points[1][1])])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, int(R) + 1):\n            for j in range(1, int(R) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "import math\n\nclass Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\n\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        x = (px + qx) / 2\n        y = (py + qy) / 2\n        return sorted([math.floor(x - L / 2), math.floor(y - L / 2), math.floor(x + L / 2), math.floor(y + L / 2)])", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\n\n    def findCornerPoints(self, L, points):\n        mid_x = (points[0][0] + points[1][0]) // 2\n        mid_y = (points[0][1] + points[1][1]) // 2\n        return sorted([(mid_x - L // 2, mid_y - L // 2), \n                      (mid_x + L // 2, mid_y - L // 2), \n                      (mid_x - L // 2, mid_y + L // 2), \n                      (mid_x + L // 2, mid_y + L // 2)])", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p, q = points\n        x1, y1 = p\n        x2, y2 = q\n        return sorted([x1-L/2, y1-L/2, x2+L/2, y2+L/2])", "class Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the difference between the two points\n        dx = points[1][0] - points[0][0]\n        dy = points[1][1] - points[0][1]\n        \n        # Calculate the midpoint coordinates\n        mid_x = (points[0][0] + points[1][0]) / 2\n        mid_y = (points[0][1] + points[1][1]) / 2\n        \n        # Calculate the coordinates of the corner points\n        A = [mid_x - dx / 2, mid_y - dy / 2]\n        B = [mid_x + dx / 2, mid_y - dy / 2]\n        C = [mid_x + dx / 2, mid_y + dy / 2]\n        D = [mid_x - dx / 2, mid_y + dy / 2]\n        \n        # Return the coordinates of the corner points in sorted order\n        return sorted([A, B, C, D])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the difference between the two points\n        dx = points[1][0] - points[0][0]\n        dy = points[1][1] - points[0][1]\n        \n        # Calculate the midpoint coordinates\n        mid_x = (points[0][0] + points[1][0]) / 2\n        mid_y = (points[0][1] + points[1][1]) / 2\n        \n        # Calculate the coordinates of the corner points\n        A = [mid_x - L / 2, mid_y]\n        B = [mid_x + L / 2, mid_y]\n        C = [mid_x, mid_y - L / 2]\n        D = [mid_x, mid_y + L / 2]\n        \n        # Return the coordinates of the corner points in sorted order\n        return sorted([A, B, C, D])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, R + 1):\n            for j in range(1, R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n\tdef findCornerPoints(self, L, points):\n\t\tp, q = points\n\t\tmidX = (p[0] + q[0]) / 2\n\t\tmidY = (p[1] + q[1]) / 2\n\t\td = (midX - p[0]) ** 2 + (midY - p[1]) ** 2\n\t\tx = midX - d ** 0.5\n\t\ty = midY - d ** 0.5\n\t\tA = [x, y]\n\t\tB = [x, midY + y]\n\t\tC = [midX + x, midY + y]\n\t\tD = [midX + x, y]\n\t\treturn sorted([A, B, C, D])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * i + j * j <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * j <= (2 * R) ** 2:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] > R2[0] or R1[1] < L2[1] or L1[1] > R2[1] or R1[0] < L2[0]:\n            return 0\n        return 1\n\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        return [[p[0] - L / 2, p[1] - L / 2], [p[0] - L / 2, p[1] + L / 2], [q[0] + L / 2, p[1] - L / 2], [q[0] + L / 2, p[1] + L / 2]]\n\n# Example usage:\ns = Solution()\nprint(s.rectanglesInCircle(1))  # Output: 1\nprint(s.rectanglesInCircle(2))  # Output: 8\nprint(s.doIntersect((1, 1), (10, 1), (1, 2), (10, 2)))  # Output: 0\nprint(s.doIntersect((10, 0), (0, 10), (0, 0), (10, 10)))  # Output: 1\nprint(s.doOverlap((0, 0), (2, 2), (1, 1), (3, 3)))  # Output: 1\nprint(s.findCornerPoints(2, [(1, 0), (1, 2)]))  # Output: [[0, 0], [0, 2], [2, 0], [2, 2]]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        dx = abs(p2[0] - p1[0])\n        dy = abs(p2[1] - p1[1])\n        \n        # Calculate the coordinates of points A and B\n        ax, ay = p1[0] - dx, p1[1] - dy\n        bx, by = p1[0] + dx, p1[1] + dy\n        \n        # Calculate the coordinates of points C and D\n        cx, cy = p2[0] + dx, p2[1] + dy\n        dx, dy = dx, dy\n        \n        return [ax, ay, bx, by, cx, cy]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1]:\n            return 0\n        return 1\n\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        x = (p[0] + q[0]) / 2\n        y = (p[1] + q[1]) / 2\n        return [[x - (L - p[0]) / 2, y - (L - p[1]) / 2],\n                [x + (L - p[0]) / 2, y - (L - p[1]) / 2],\n                [x - (L - p[0]) / 2, y + (L - p[1]) / 2],\n                [x + (L - p[0]) / 2, y + (L - p[1]) / 2]]\n\n\n# Example usage:\nsolution = Solution()\nprint(solution.rectanglesInCircle(2))\nprint(solution.doIntersect((1, 1), (10, 1), (1, 2), (10, 2)))\nprint(solution.doOverlap([0, 0, 2, 2], [1, 1, 3, 3]))\nprint(solution.findCornerPoints(10, [[1, 0], [1, 2]]))", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, qx = points\n        return [max(0, min(px, qx) - L), max(0, min(px, qx) - L), min(px, qx) + L, min(px, qx) + L]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, int(ds) + 1):\n            for j in range(1, int(ds) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [[x1 - (L - x1) / 2, y1 - (L - y1) / 2], [x1 + (L - x1) / 2, y1 - (L - y1) / 2], \n                [x2 - (L - x2) / 2, y2 + (L - y2) / 2], [x2 + (L - x2) / 2, y2 + (L - y2) / 2]]\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [[x1 - L / 2, y1 - L / 2], [x1 + L / 2, y1 - L / 2], [x1 - L / 2, y2 + L / 2], [x1 + L / 2, y2 + L / 2]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\n\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return [[p[0] - L // 2, p[1] - L // 2], [p[0] + L // 2, p[1] - L // 2],\n                [p[0] - L // 2, p[1] + L // 2], [p[0] + L // 2, p[1] + L // 2]]\n\n# Example usage:\nsolution = Solution()\nprint(solution.rectanglesInCircle(1))  # Output: 1\nprint(solution.rectanglesInCircle(2))  # Output: 8\nprint(solution.doIntersect((1, 1), (10, 1), (1, 2), (10, 2)))  # Output: 0\nprint(solution.doIntersect((10, 0), (0, 10), (0, 0), (10, 10)))  # Output: 1\nprint(solution.isRectangleOverlap([0, 0, 2, 2], [1, 1, 3, 3]))  # Output: True\nprint(solution.isRectangleOverlap([0, 0, 1, 1], [1, 0, 2, 1]))  # Output: False\nprint(solution.isRectangleOverlap([0, 0, 1, 1], [2, 2, 3, 3]))  # Output: False\nprint(solution.findCornerPoints(2, {{1, 0}, {1, 2}}))  # Output: [[0, 0], [0, 2], [2, 0], [2, 2]]\nprint(solution.findCornerPoints(2.8284, {{1, 1}, {-1, -1}}))  # Output: [[-2, 0], [0, -2], [0, 2], [2, 0]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        for i in range(1, int(R * 2) + 1):\n            for j in range(i, int(R * 2) + 1):\n                if i * i + j * j <= 4 * R * R:\n                    rec += 1\n        return rec\nclass Solution:\n    def rectanglesInCircle(self, R):\n        return R * R", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1 >= R2 or L2 >= R1)\n\n    def findCornerPoints(self, L, points):\n        p, q = points\n        a = p[0] - L // 2\n        b = p[1] - L // 2\n        c = q[0] + L // 2\n        d = q[1] + L // 2\n        return sorted([[a, b], [a, d], [c, b], [c, d]])\n\n# Example usage:\nsolution = Solution()\nprint(solution.rectanglesInCircle(2))  # Output: 8\nprint(solution.doOverlap(0, 2, 1, 3))  # Output: 1\nprint(solution.findCornerPoints(4, [1, 2]))  # Output: [[-1.0, -1.0], [-1.0, 3.0], [3.0, -1.0], [3.0, 3.0]]", "class Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        x_mid = (p[0] + q[0]) / 2\n        y_mid = (p[1] + q[1]) / 2\n        corner_points = [[x_mid - L / 2, y_mid - L / 2], [x_mid + L / 2, y_mid - L / 2],\n                         [x_mid - L / 2, y_mid + L / 2], [x_mid + L / 2, y_mid + L / 2]]\n        return corner_points", "class Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the coordinates of points A and D\n        ax = points[0][0] - L / 2\n        ay = points[0][1] - L / 2\n        dx = points[0][0] + L / 2\n        dy = points[0][1] + L / 2\n        ad = [ax, ay, dx, dy]\n        \n        # Calculate the coordinates of points B and C\n        bx = points[1][0] - L / 2\n        by = points[1][1] - L / 2\n        cx = points[1][0] + L / 2\n        cy = points[1][1] + L / 2\n        bc = [bx, by, cx, cy]\n        \n        # Combine the coordinates of points A, B, C, and D\n        corners = ad + bc\n        \n        # Return the coordinates of the four points in sorted order\n        return sorted(corners)", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[0] or R1[0] <= L2[0] or L1[1] >= R2[1] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([(-points[0][0] + points[1][0], -points[0][1] + points[1][1]), \n                       (points[0][0] + points[1][0], points[0][1] + points[1][1]), \n                       (points[0][0] - points[1][0], points[0][1] - points[1][1]), \n                       (points[0][0] + points[1][0], points[0][1] - points[1][1])])", "class Solution:\n    def rectanglesInCircle(self, R):\n        return R * (R + 1) // 2", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return sorted([(-x1 + x2, -y1 + y2), (x1 + x2, -y1 + y2), (x1 + x2, y1 + y2), (-x1 + x2, y1 + y2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, int(ds) + 1):\n            for j in range(1, int(ds) + 1):\n                dl = i * i + j * j\n                if dl <= ds * ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1]:\n            return False\n        return True\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = (points[0][0] + points[1][0]) / 2\n        q = (points[0][1] + points[1][1]) / 2\n        return sorted([(-p + L / 2, -q + L / 2), (-p + L / 2, q - L / 2), (p - L / 2, -q + L / 2), (p - L / 2, q - L / 2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([\n            [points[0][0] - L / 2, points[0][1] - L / 2],\n            [points[0][0] + L / 2, points[0][1] - L / 2],\n            [points[0][0] + L / 2, points[0][1] + L / 2],\n            [points[0][0] - L / 2, points[0][1] + L / 2]\n        ])", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        a = L / 2\n        b = p1[0] - a\n        c = p1[1] - a\n        d = p2[0] + a\n        e = p2[1] + a\n        return sorted([[b, c], [d, c], [d, e], [b, e]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        # Calculate the center of the rectangle\n        center_x = (points[0][0] + points[1][0]) / 2\n        center_y = (points[0][1] + points[1][1]) / 2\n        \n        # Calculate the coordinates of the corners\n        corner1 = [center_x - L / 2, center_y - L / 2]\n        corner2 = [center_x + L / 2, center_y - L / 2]\n        corner3 = [center_x + L / 2, center_y + L / 2]\n        corner4 = [center_x - L / 2, center_y + L / 2]\n        \n        # Return the coordinates of the corners in sorted order\n        return sorted([corner1, corner2, corner3, corner4])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        return sorted([(px - L / 2, py - L / 2), (px + L / 2, py - L / 2), (px - L / 2, qy + L / 2), (px + L / 2, qy + L / 2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x1, y1, x2, y2 = min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)\n        return sorted([(x1 - L // 2, y1 - L // 2), (x1 + L // 2, y1 - L // 2), (x1 - L // 2, y1 + L // 2), (x1 + L // 2, y1 + L // 2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n\tdef findCornerPoints(self, L, points):\n\t\tmx = max(points[0][0], points[1][0])\n\t\tmn = min(points[0][0], points[1][0])\n\t\tmx = max(points[0][1], points[1][1])\n\t\tmn = min(points[0][1], points[1][1])\n\t\treturn [[mn, mn], [mx, mn], [mx, mx], [mn, mx]]", "class Solution:\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] < L2[0] or R1[2] > L2[2] or R1[1] < L2[1] or R1[3] > L2[3])\n\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return self.doOverlap(rec1, [rec1[0], rec1[3], rec1[2], rec1[1]], rec2, [rec2[0], rec2[3], rec2[2], rec2[1]])\n\n    def findCornerPoints(self, L, points):\n        return sorted([[points[0][0] - L / 2, points[0][1] - L / 2], \n                      [points[0][0] + L / 2, points[0][1] - L / 2], \n                      [points[0][0] + L / 2, points[0][1] + L / 2], \n                      [points[0][0] - L / 2, points[0][1] + L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\n\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[2] <= L2[0] or L1[1] >= R2[3] or R1[3] <= L2[1])\n\n    def findCornerPoints(self, L, points):\n        # Calculate the difference between p and q\n        dx = points[1][0] - points[0][0]\n        dy = points[1][1] - points[0][1]\n        \n        # Calculate the midpoint of the diagonal\n        mid_x = (points[0][0] + points[1][0]) / 2\n        mid_y = (points[0][1] + points[1][1]) / 2\n        \n        # Calculate the length of the diagonal\n        diagonal_length = ((points[0][0] - points[1][0])**2 + (points[0][1] - points[1][1])**2) ** 0.5\n        \n        # Calculate the coordinates of A and B\n        A_x = mid_x - (L / 2) * dx\n        A_y = mid_y - (L / 2) * dy\n        B_x = mid_x + (L / 2) * dx\n        B_y = mid_y + (L / 2) * dy\n        \n        # Calculate the coordinates of C and D\n        C_x = mid_x + (L / 2) * dx\n        C_y = mid_y + (L / 2) * dy\n        D_x = mid_x - (L / 2) * dx\n        D_y = mid_y - (L / 2) * dy\n        \n        # Return the coordinates of A, B, C, and D\n        return sorted([[A_x, A_y], [B_x, B_y], [C_x, C_y], [D_x, D_y]])\nsolution = Solution()\nprint(solution.rectanglesInCircle(3))  # Output: 13\nprint(solution.doIntersect([0,0], [3,0], [2,1], [4,1]))  # Output: 1\nprint(solution.isRectangleOverlap([0,0,2,2], [1,1,3,3]))  # Output: 1\nprint(solution.doOverlap([0,10], [10,0], [1,1], [2,2]))  # Output: 0\nprint(solution.findCornerPoints(10, [[1,0],[1,2]]))  # Output: [[0,0],[0,2],[2,0],[2,2]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L2[0] > R1[0] or R1[1] > L2[1]:\n            return 0\n        if R2[1] > L1[1] or L1[0] > R2[0]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points[0]\n        qx, qy = points[1]\n        return [(px - L // 2, py - L // 2), (px - L // 2, qy + L // 2), (qx + L // 2, qy + L // 2), (qx + L // 2, py - L // 2)]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [(x1 - (L - x2) / 2, y1 - (L - y2) / 2),\n                (x1 - (L - x2) / 2, y1 + (L - y2) / 2),\n                (x1 + (L - x2) / 2, y1 + (L - y2) / 2),\n                (x1 + (L - x2) / 2, y1 - (L - y2) / 2)]", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p, q = points\n        dx = abs(q[0] - p[0])\n        dy = abs(q[1] - p[1])\n        return sorted([(-dx, -dy), (0, -dy), (dx, -dy), (dx, 0)])", "class Solution:\n    def findCornerPoints(self, L, points):\n        # The points are given as (x, y) coordinates of the midpoints of the sides AD and BC\n        # Since the sides AD and BC are equal, the distance between the midpoints and the corners is the same\n        # So, we can simply double the x and y coordinates of the midpoints to get the coordinates of the corners\n        # We also need to subtract the length of the side from the x coordinate of the left corner and add it to the x coordinate of the right corner\n        # Similarly, we need to subtract the length of the side from the y coordinate of the bottom corner and add it to the y coordinate of the top corner\n        return sorted([(points[0][0] - L, points[0][1] - L), (points[0][0] + L, points[0][1] - L),\n                       (points[0][0] - L, points[0][1] + L), (points[0][0] + L, points[0][1] + L)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        A = [x1 - L / 2, y1 + L / 2]\n        B = [x1 + L / 2, y1 + L / 2]\n        C = [x1 + L / 2, y1 - L / 2]\n        D = [x1 - L / 2, y1 - L / 2]\n        return sorted(A + B + C + D)", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, int(2 * R) + 1):\n            for j in range(1, int(2 * R) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, int(2 * R) + 1):\n            for j in range(1, int(2 * R) + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        mid_x = (points[0][0] + points[1][0]) // 2\n        mid_y = (points[0][1] + points[1][1]) // 2\n        return [mid_x - L // 2, mid_y - L // 2], [mid_x + L // 2, mid_y - L // 2], [mid_x - L // 2, mid_y + L // 2], [mid_x + L // 2, mid_y + L // 2]", "class Solution:\n    def findCornerPoints(self, L, points):\n        # calculate the x and y coordinates of the center of the rectangle\n        cx = (points[0][0] + points[1][0]) // 2\n        cy = (points[0][1] + points[1][1]) // 2\n\n        # calculate the x and y coordinates of the top-left corner\n        ax = cx - (points[0][0] - cx)\n        ay = cy - (points[0][1] - cy)\n\n        # calculate the x and y coordinates of the bottom-right corner\n        bx = cx + (points[1][0] - cx)\n        by = cy + (points[1][1] - cy)\n\n        # calculate the x and y coordinates of the top-right corner\n        cx = cx - (points[1][0] - cx)\n        cy = cy + (points[1][1] - cy)\n\n        # return the coordinates of the 4 corners in sorted order\n        return sorted([ax, ay, bx, by], key=lambda x: (x[0], x[1]))", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p = (points[0][0] + points[1][0]) / 2\n        q = (points[0][1] + points[1][1]) / 2\n        return sorted([[p - L / 2, q - L / 2], [p + L / 2, q - L / 2], [p + L / 2, q + L / 2], [p - L / 2, q + L / 2]])", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (R1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([0, 0], [0, L], [L, L], [L, 0])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        mid_x, mid_y = points[0][0] + (points[1][0] - points[0][0]) / 2, points[0][1] + (points[1][1] - points[0][1]) / 2\n        corner_points = [(mid_x - L / 2, mid_y - L / 2), (mid_x + L / 2, mid_y - L / 2), (mid_x + L / 2, mid_y + L / 2), (mid_x - L / 2, mid_y + L / 2)]\n        return sorted(corner_points)", "class Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        \n        # Calculate the difference in x and y coordinates\n        dx = x2 - x1\n        dy = y2 - y1\n        \n        # Calculate the coordinates of point A and B\n        ax = x1 - dx / 2\n        ay = y1 - dy / 2\n        bx = x1 + dx / 2\n        by = y1 + dy / 2\n        \n        # Calculate the coordinates of point C and D\n        cx = x2 - dx / 2\n        cy = y2 - dy / 2\n        dx = L\n        dy = L\n        dx = -dx\n        dy = -dy\n        dx = -dx\n        dy = -dy\n        \n        # Return the coordinates of the 4 points in sorted order\n        return sorted([ax, ay, bx, by, cx, cy, dx, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                if i * i + j * j <= 4 * R * R:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([[points[0][0] - L/2, points[0][1] - L/2], \n                       [points[0][0] + L/2, points[0][1] - L/2], \n                       [points[0][0] + L/2, points[0][1] + L/2], \n                       [points[0][0] - L/2, points[0][1] + L/2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        return sorted([[p1[0] - L // 2, p1[1] - L // 2], \n                       [p1[0] + L // 2, p1[1] - L // 2], \n                       [p1[0] + L // 2, p1[1] + L // 2], \n                       [p1[0] - L // 2, p1[1] + L // 2]])", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        return sorted([min(points), max(points)] + [points[0] + (points[1] - points[0]), points[1] + (points[0] - points[1])])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1 >= R2 or L2 >= R1)\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [(x1 - (L - x1) / 2, y1 - (L - y1) / 2), \n                (x1 + (L - x1) / 2, y1 - (L - y1) / 2), \n                (x1 + (L - x1) / 2, y1 + (L - y1) / 2), \n                (x1 - (L - x1) / 2, y1 + (L - y1) / 2)]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or R1[0] <= L2[0] or L1[1] >= R2[3] or R1[1] <= L2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return [[x1 - (L - x1) // 2, y1 - (L - y1) // 2],\n                [x1 + (L - x1) // 2, y1 - (L - y1) // 2],\n                [x1 - (L - x1) // 2, y1 + (L - y1) // 2],\n                [x1 + (L - x1) // 2, y1 + (L - y1) // 2]]", "class Solution:\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        \n        # Calculate the coordinates of A and D\n        ax, ay = x1 - (L - abs(x2 - x1)) / 2, y1 - (L - abs(y2 - y1)) / 2\n        dx, dy = x1 + (L - abs(x2 - x1)) / 2, y1 + (L - abs(y2 - y1)) / 2\n        \n        # Calculate the coordinates of B and C\n        bx, by = x2 - (L - abs(x2 - x1)) / 2, y2 - (L - abs(y2 - y1)) / 2\n        cx, cy = x2 + (L - abs(x2 - x1)) / 2, y2 + (L - abs(y2 - y1)) / 2\n        \n        return [[ax, ay], [bx, by], [cx, cy], [dx, dy]]", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\n\n    def findCornerPoints(self, L, points):\n        px, qx = points\n        x = (px[0] + qx[0]) / 2\n        y = (px[1] + qx[1]) / 2\n        return sorted([[x - L / 2, y - L / 2], [x + L / 2, y - L / 2], [x - L / 2, y + L / 2], [x + L / 2, y + L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or R1[3] <= R2[1]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        return sorted([points[0][0] - (points[0][0] - points[1][0]) / 2,\n                      points[0][1] - (points[0][1] - points[1][1]) / 2,\n                      points[0][0] + (points[0][0] - points[1][0]) / 2,\n                      points[0][1] + (points[0][1] - points[1][1]) / 2,\n                     points[1][0] - (points[0][0] - points[1][0]) / 2,\n                     points[1][1] - (points[0][1] - points[1][1]) / 2,\n                     points[1][0] + (points[0][0] - points[1][0]) / 2,\n                     points[1][1] + (points[0][1] - points[1][1]) / 2,\n                     L - (L - points[0][0]) / 2,\n                     L - (L - points[0][1]) / 2,\n                     L + (L - points[1][0]) / 2,\n                     L + (L - points[1][1]) / 2])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p = points[0]\n        q = points[1]\n        dx = q[0] - p[0]\n        dy = q[1] - p[1]\n        x1 = p[0] - dx / 2\n        y1 = p[1] - dy / 2\n        x2 = p[0] + dx / 2\n        y2 = p[1] + dy / 2\n        x3 = q[0] - dy / 2\n        y3 = q[1] + dx / 2\n        x4 = q[0] + dy / 2\n        y4 = q[1] - dx / 2\n        return sorted([x1, x2, y1, y2, x3, y3, x4, y4])", "class Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        x1, y1 = p\n        x2, y2 = q\n        x = x1 + (x2 - x1) / 2\n        y = y1 + (y2 - y1) / 2\n        return sorted([[x - L / 2, y - L / 2], [x + L / 2, y - L / 2], [x - L / 2, y + L / 2], [x + L / 2, y + L / 2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1 >= L2 + R2 - L1 or L2 >= L1 + R1 - L2 or R1 >= R2 + L2 - R1 or R2 >= R1 + L1 - R2)\nclass Solution:\n\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return sorted([(x1 - L // 2, y1 - L // 2), (x1 - L // 2, y2 + L // 2), (x2 + L // 2, y1 - L // 2), (x2 + L // 2, y2 + L // 2)])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        L1tl = L1\n        L1tr = [R1[0], L1[1]]\n        L1bl = [L1[0], R1[1]]\n        L1br = R1\n        L2tl = L2\n        L2tr = [R2[0], L2[1]]\n        L2bl = [L2[0], R2[1]]\n        L2br = R2\n        if L2[0] > R1[0] or R1[1] > L2[1]:\n            return 0\n        if R2[1] > L1[1] or L1[0] > R2[0]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        ax = (points[0][0] - points[1][0]) / 2\n        ay = (points[0][1] - points[1][1]) / 2\n        bx = (points[0][0] + points[1][0]) / 2\n        by = (points[0][1] + points[1][1]) / 2\n        cx = (points[0][0] + points[1][0]) / 2\n        cy = (points[0][1] - points[1][1]) / 2\n        dx = (points[0][0] - points[1][0]) / 2\n        dy = (points[0][1] + points[1][1]) / 2\n        return sorted([[ax, ay], [bx, by], [cx, cy], [dx, dy]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, ds):\n            for j in range(1, ds):\n                dl = i * i + j * j\n                if dl <= ds * ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * 2 * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= L2[2] or L1[2] <= L2[0] or R1[1] >= R2[3] or R1[3] <= R2[1])\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        ax, ay = p1[0] - L / 2, p1[1] - L / 2\n        bx, by = p1[0] + L / 2, p1[1] + L / 2\n        cx, cy = p2[0] - L / 2, p2[1] - L / 2\n        dx, dy = p2[0] + L / 2, p2[1] + L / 2\n        return sorted([ax, bx, cx, dx, ay, by, cy, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points[0]\n        qx, qy = points[1]\n        return sorted([[px-L//2, py], [px+L//2, py], [px, qy-L//2], [px, qy+L//2]])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R\n        for i in range(1, int(ds) + 1):\n            for j in range(1, int(ds) + 1):\n                dl = i * i + j * j\n                if dl <= ds * ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        px, py = points\n        qx, qy = points\n        return [[px - L // 2, py - L // 2], [px - L // 2, qy + L // 2], [qx + L // 2, py - L // 2], [qx + L // 2, qy + L // 2]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, R):\n            for j in range(1, R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 4\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        p1, p2 = points\n        ax = p1[0] - (p2[0] - p1[0]) / 2\n        ay = p1[1] - (p2[1] - p1[1]) / 2\n        bx = p2[0] + (p2[0] - p1[0]) / 2\n        by = p2[1] + (p2[1] - p1[1]) / 2\n        cx = p1[0] + (p2[0] - p1[0]) / 2\n        cy = p1[1] + (p2[1] - p1[1]) / 2\n        dx = p2[0] - (p2[0] - p1[0]) / 2\n        dy = p2[1] - (p2[1] - p1[1]) / 2\n        return sorted([ax, ay, bx, by, cx, cy, dx, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]):\n            return False\n        return True\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        if L2[0] > R1[0] or R1[1] > L2[1]:\n            return 0\n        if R2[1] > L1[1] or L1[0] > R2[0]:\n            return 0\n        return 1\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        A = [p[0] - p[0], p[1] - p[1], p[0], p[1]]\n        B = [p[0] + p[0], p[1] - p[1], p[0] + p[0], p[1]]\n        C = [q[0] - p[0], q[1] - p[1], q[0], q[1]]\n        D = [q[0] + p[0], q[1] - p[1], q[0] + p[0], q[1]]\n        return sorted([A, B, C, D], key=lambda x: x[0] * x[0] + x[1] * x[1])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def doIntersect(self, p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            if val > 0:\n                return 1\n            return 2\n\n        def onSegment(p, q, r):\n            if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n                return True\n            return False\n\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1!= o2 and o3!= o4:\n            return 1\n        if o1 == 0 and onSegment(p1, p2, q1):\n            return 1\n        if o2 == 0 and onSegment(p1, q2, q1):\n            return 1\n        if o3 == 0 and onSegment(p2, p1, q2):\n            return 1\n        if o4 == 0 and onSegment(p2, q1, q2):\n            return 1\n        return 0\nclass Solution:\n    def isRectangleOverlap(self, rec1, rec2):\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or (rec1[3] <= rec2[1]))\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or (L1[3] <= R2[1]))\nclass Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return sorted([(-p[0] + q[0], -p[1] + q[1]), (p[0] + q[0], p[1] + q[1]), (p[0] - q[0], p[1] - q[1]), (q[0] - p[0], q[1] - p[1])])", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\n\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (R1[0] >= L2[2] or R1[2] <= L2[0] or R1[1] >= L2[3] or (R1[3] <= L2[1]))\n\n    def findCornerPoints(self, L, points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x = (x1 + x2) / 2\n        y = (y1 + y2) / 2\n        a = L - abs(x - x1)\n        b = L - abs(y - y1)\n        return [[x - a, y - b], [x - a, y + b], [x + a, y - b], [x + a, y + b]]", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 2 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R ** 2\n        for i in range(1, R + 1):\n            for j in range(1, R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec\nclass Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\nclass Solution:\n    def doOverlap(self, L1, R1, L2, R2):\n        return not (L1[0] >= R2[2] or L1[2] <= R2[0] or L1[1] >= R2[3] or L1[3] <= R2[1])\nimport math\n\nclass Solution:\n    def findCornerPoints(self, L, points):\n        midpoint_x = (points[0][0] + points[1][0]) / 2\n        midpoint_y = (points[0][1] + points[1][1]) / 2\n        corner_points = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                x = midpoint_x + i * L / 2\n                y = midpoint_y + j * L / 2\n                corner_points.append((x, y))\n        return corner_points", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        ds = 4 * R * R\n        for i in range(1, 2 * R + 1):\n            for j in range(1, 2 * R + 1):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec", "class Solution:\n    def findCornerPoints(self, L, points):\n        p, q = points\n        return sorted([p[0] - (p[0] - q[0]) / 2, p[1] - (p[1] - q[1]) / 2,\n                      p[0] + (p[0] - q[0]) / 2, p[1] + (p[1] - q[1]) / 2,\n                      q[0] - (q[0] - p[0]) / 2, q[1] - (q[1] - p[1]) / 2,\n                      q[0] + (q[0] - p[0]) / 2, q[1] + (q[1] - p[1]) / 2])", "class Solution:\n\n    def findCornerPoints(self, L, points):\n        p, q = points\n        ax, ay = -p[0] + L / 2, -p[1] + L / 2\n        bx, by = p[0] + L / 2, p[1] + L / 2\n        cx, cy = q[0] + L / 2, q[1] + L / 2\n        dx, dy = q[0] - L / 2, q[1] - L / 2\n        return sorted([ax, ay, bx, by, cx, cy, dx, dy])", "class Solution:\n    def rectanglesInCircle(self, R):\n        rec = 0\n        d = 2 * R\n        ds = d * d\n        for i in range(1, 2 * R):\n            for j in range(1, 2 * R):\n                dl = i * i + j * j\n                if dl <= ds:\n                    rec += 1\n        return rec"]}]