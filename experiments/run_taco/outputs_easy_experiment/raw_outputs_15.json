{"id": 15, "input": "You are given an array A of N integers A_{1}, A_{2}, \\ldots, A_{N}. Determine if there are two [permutations] B and C of this array, for which the following condition is satisfied:\n\n* There doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \\neq (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j].\n\nIf there exist such permutations, find any of them.\n\nAs a reminder, B[i:j] refers to the subarray [B_{i}, B_{i+1}, \\ldots, B_{j}]\n\n------ Input Format ------ \n\n- The first line of the input contains a single integer T, the number of test cases. The description of the test cases follows.\n- The first line of each test case contains a single integer N \u2014 the number of integers.\n- The second line of each test case contains N space-separated integers A_{1}, A_{2}, \\ldots, A_{N}.\n\n------ Output Format ------ \n\nFor each test case, if there are no such permutations B and C, output NO.\n\nOtherwise, on the first line output YES. In the next line, output N integers B_{1}, B_{2}, \\ldots, B_{N}. In the next line, output N integers C_{1}, C_{2}, \\ldots, C_{N}.\n\nYou may print each character of YES/NO in either uppercase or lowercase (for example, the strings YES, yeS, YeS, and yEs will all be treated as identical).\n\n------ Constraints ------ \n\n$1 \u2264T \u2264100$\n$3 \u2264N \u22641000$\n$0 \u2264A_{i} \u226410^{9}$\n- The sum of $N$ over all test cases doesn't exceed $2000$.\n\n----- Sample Input 1 ------ \n3\n3\n1 1 2\n4\n19 39 19 84\n6\n1 2 3 1 2 3\n----- Sample Output 1 ------ \nNO\nYES\n19 19 39 84 \n39 84 19 19 \nYES\n1 1 2 2 3 3 \n2 3 3 1 1 2 \n----- explanation 1 ------ \nTest case $1$: There are $3 \\times 3 = 9$ pairs of permutations of the given array. Here's why they're all bad:\n- If $B = [1, 1, 2]$ and $C = [1, 1, 2]$, $B[1:1] = C[1:1]$\n- If $B = [1, 1, 2]$ and $C = [1, 2, 1]$, $B[1:1] = C[1:1]$\n- If $B = [1, 1, 2]$ and $C = [2, 1, 1]$, $B[2:2] = C[2:2]$\n- If $B = [1, 2, 1]$ and $C = [1, 1, 2]$, $B[1:1] = C[1:1]$\n- If $B = [1, 2, 1]$ and $C = [1, 2, 1]$, $B[1:1] = C[1:1]$\n- If $B = [1, 2, 1]$ and $C = [2, 1, 1]$, $B[3:3] = C[3:3]$\n- If $B = [2, 1, 1]$ and $C = [1, 1, 2]$, $B[2:2] = C[2:2]$\n- If $B = [2, 1, 1]$ and $C = [1, 2, 1]$, $B[3:3] = C[3:3]$\n- If $B = [2, 1, 1]$ and $C = [2, 1, 1]$, $B[1:1] = C[1:1]$\n", "difficulty": "HARD", "generations": [{"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if n == 3:\n        a1, a2, a3 = a\n        if a1 == a3 and a2!= a3:\n            print(\"YES\")\n            print(a1, a2, a3)\n            print(a3, a2, a1)\n            return\n        elif a1!= a3 and a2 == a3:\n            print(\"YES\")\n            print(a1, a2, a3)\n            print(a2, a3, a1)\n            return\n        else:\n            print(\"NO\")\n            return\n\n    if n % 2 == 0:\n        print(\"YES\")\n        for i in range(n // 2):\n            print(a[i], end=' ')\n            print(a[-i - 1], end=' ')\n        print()\n        for i in range(n // 2):\n            print(a[-i - 1], end=' ')\n            print(a[i], end=' ')\n        print()\n    else:\n        print(\"YES\")\n        for i in range(n // 2):\n            print(a[i], end=' ')\n            print(a[-i - 1], end=' ')\n        print(a[n // 2])\n        for i in range(n // 2):\n            print(a[-i - 1], end=' ')\n            print(a[i], end=' ')\n        print(a[n // 2])\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by first checking if the length of the input array is 3. If it is, the program checks if the first and third elements of the array are equal and the second element is not equal to the third element, or if the first element is not equal to the third element and the second element is equal to the third element. If either of these conditions is true, the program prints \"YES\" and the corresponding permutations of the array. Otherwise, the program prints \"NO\".\n\nIf the length of the input array is not 3, the program checks if the length of the array is even or odd. If the length is even, the program prints \"YES\" and the corresponding permutations of the array by printing the elements of the array in the order [i, n-i-1] for i in range(n // 2). If the length of the array is odd, the program prints \"YES\" and the corresponding permutations of the array by printing the elements of the array in the order [i, n-i-1] for i in range(n // 2) and then printing the middle element of the array."}, {"generated_text": "Here is a Python program to solve the given problem:\n\n```python\nfrom collections import Counter\nimport sys\n\ndef find_permutations(A):\n    n = len(A)\n    freq_A = Counter(A)\n    freq_B = Counter(A)\n    freq_C = Counter(A)\n    \n    for i in range(n):\n        freq_B[A[i]] -= 1\n        freq_C[A[n-i-1]] -= 1\n        \n        if freq_B!= freq_C:\n            return False, [], []\n        \n    return True, list(freq_B.elements()), list(freq_C.elements())\n\ndef main():\n    input = sys.stdin.readline\n    output = sys.stdout.write\n    \n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n        \n        possible, B, C = find_permutations(A)\n        \n        if not possible:\n            output(\"NO\\n\")\n        else:\n            output(\"YES\\n\")\n            output(\" \".join(map(str, B)) + \"\\n\")\n            output(\" \".join(map(str, C)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses the `Counter` class from the `collections` module to count the frequency of each element in the array `A`. It then tries to find two permutations `B` and `C` of `A` such that there doesn't exist a pair of integers `(i, j)` such that `1 \u2264 i \u2264 j \u2264 N` and `(i, j) \u2260 (1, N)`, for which the subarray `B[i:j]` is a permutation of subarray `C[i:j]`.\n\nThe program first initializes three counters `freq_A`, `freq_B`, and `freq_C` to count the frequency of each element in the array `A`. Then, it iterates over the array `A` from left to right and right to left, updating the counters `freq_B` and `freq_C` accordingly. If at any point the counters `freq_B` and `freq_C` are not equal, the program returns `False` and an empty list for `B` and `C`.\n\nIf the program finishes iterating over the array `A` without finding any pair of integers `(i, j)` that satisfies the condition, it returns `True` and the lists `B` and `C`.\n\nThe main function reads the input from the standard input and writes the output to the standard output. It first reads the number of test cases `t`, and then for each test case, it reads the length of the array `n` and the array `A`. It then calls the `find_permutations` function to find two permutations `B` and `C` of `A`, and prints the result accordingly."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nfrom collections import Counter\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    # If the array has repeated elements, it is impossible to construct B and C\n    if len(set(A))!= n:\n        print(\"NO\")\n        return\n\n    # Sort the array\n    A.sort()\n\n    # Try to construct B and C\n    B = A[:]\n    C = A[:]\n    for i in range(1, n - 1):\n        if B[i] == B[i - 1]:\n            C[i] = A[n - 1 - i]\n        elif B[i] == B[i + 1]:\n            C[i] = A[n - 1 - i + 1]\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*B)\n    print(*C)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program first checks if the array has repeated elements. If it does, it is impossible to construct B and C, so it prints \"NO\". Otherwise, it sorts the array and tries to construct B and C by swapping elements. If it cannot construct B and C without having any pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j], it prints \"NO\". Otherwise, it prints \"YES\" and the two arrays B and C."}, {"generated_text": "Here's a Python program that solves the given problem:\n\n```python\ndef find_permutations(A):\n    n = len(A)\n    count = {}\n    for num in A:\n        if num not in count:\n            count[num] = 0\n        count[num] += 1\n\n    # Find the maximum frequency of any number\n    max_freq = max(count.values())\n\n    # If the maximum frequency is more than n/2, \n    # it means we can always swap the numbers in the two arrays\n    # and the condition will always be satisfied\n    if max_freq > n // 2:\n        return [A, A]\n\n    # Sort the numbers and create two arrays\n    sorted_A = sorted(A)\n    B = sorted_A[:n // 2] + sorted_A[n // 2 + 1:]\n    C = sorted_A[n // 2:]\n\n    return [B, C]\n\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n\n        result = find_permutations(A)\n        if result[0] == result[1]:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for arr in result:\n                print(*arr)\n\n\nif __name__ == \"__main__\":\n    solve()\n```\n\nThe idea behind this solution is as follows:\n\n*   We first count the frequency of each number in the array.\n*   If the maximum frequency of any number is more than n/2, it means we can always swap the numbers in the two arrays and the condition will always be satisfied.\n*   Otherwise, we sort the numbers and create two arrays by splitting them at the middle index.\n*   If the two arrays are the same, it means there are no permutations that satisfy the condition, so we print \"NO\".\n*   Otherwise, we print \"YES\" and the two arrays.\n\nThis solution runs in O(n log n) time due to the sorting operation, where n is the number of elements in the array. The space complexity is O(n) as we need to store the two arrays."}, {"generated_text": "Here is a Python program to solve the problem. This program first checks if it is possible to construct two permutations B and C of the given array A such that no subarray of B is a permutation of a subarray of C, and vice versa. If it is possible, it constructs these two permutations.\n\n```python\nimport sys\nimport random\n\ndef check(A):\n    n = len(A)\n    if n < 4:\n        return False, None, None\n\n    # Check if it is possible to construct B and C\n    B = A[:]\n    C = A[:]\n    random.shuffle(C)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sorted(B[i:j + 1]) == sorted(C[i:j + 1]):\n                return False, None, None\n\n    return True, B, C\n\ndef print_result(A, B, C):\n    print(\"YES\")\n    print(*B)\n    print(*C)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n        possible, B, C = check(A)\n        if possible:\n            print_result(A, B, C)\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works as follows:\n\n1. It first checks if the length of the array is less than 4. If it is, it returns False and None for B and C, because it is not possible to construct B and C.\n2. It constructs two permutations B and C of the given array A. It does this by creating a copy of the array A, and then shuffling the copy to create permutation C.\n3. It then checks if there is any subarray of B that is a permutation of a subarray of C. If it finds such a subarray, it returns False and None for B and C.\n4. If it does not find any such subarray, it returns True, B, and C.\n5. Finally, it prints the result. If B and C exist, it prints YES, followed by B and C. Otherwise, it prints NO."}, {"generated_text": "Here is a Python program that will solve the problem:\n\n```python\nimport sys\n\ndef is_good_permutation(A):\n    # If the array has less than 4 elements, it is a good permutation\n    if len(A) < 4:\n        return True, A, A\n\n    # Count the frequency of each number\n    freq = {}\n    for num in A:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Create a list of numbers and their indices\n    num_idx = []\n    for num, count in freq.items():\n        num_idx.extend([(num, i) for i in range(count)])\n\n    # Sort the list of numbers and their indices\n    num_idx.sort(key=lambda x: x[0])\n\n    # Check if the array can be split into two parts with the same numbers\n    B = []\n    C = []\n    i = 0\n    j = len(num_idx) - 1\n    while i <= j:\n        B.append(num_idx[i][0])\n        C.append(num_idx[j][0])\n        i += 1\n        j -= 1\n\n    # Create the permutations\n    B_perm = [num_idx[i][0] for i in range(len(num_idx))]\n    C_perm = [num_idx[j][0] for j in range(len(num_idx) - 1, -1, -1)]\n\n    return True, B_perm, C_perm\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n\n        is_good, B, C = is_good_permutation(A)\n        if is_good:\n            print(\"YES\")\n            print(' '.join(map(str, B)))\n            print(' '.join(map(str, C)))\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first counting the frequency of each number in the array. It then creates a list of numbers and their indices, and sorts this list. The program then checks if the array can be split into two parts with the same numbers. If it can, the program creates the permutations and prints them. If it cannot, the program prints \"NO\".\n\nNote: This program assumes that the input is well-formed and does not contain any errors. If the input may contain errors, you should add error checking code to handle these cases."}, {"generated_text": "Here's a Python program that can solve the problem:\n\n```python\nimport sys\n\ndef read_input():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        yield N, A\n\ndef is_permutation(B, C):\n    return sorted(B) == sorted(C)\n\ndef find_permutations(A):\n    N = len(A)\n    seen = set()\n    for i in range(N):\n        for j in range(i, N):\n            B = A[:i] + A[i:j+1] + A[j+1:]\n            C = A[:j] + A[j+1:i+1] + A[i+1:]\n            if is_permutation(B, C) and tuple(B) not in seen:\n                seen.add(tuple(B))\n                yield B, C\n\ndef solve(N, A):\n    for B, C in find_permutations(A):\n        print(\"YES\")\n        print(*B)\n        print(*C)\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    for N, A in read_input():\n        solve(N, A)\n```\n\nThis program uses a generator function `read_input` to read the input data from the standard input. It then uses a generator function `find_permutations` to find all permutations B and C of the input array A such that there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j]. The function `solve` then checks if such permutations exist and prints the result accordingly.\n\nThe program uses a set `seen` to keep track of the permutations that have been found so far. This is necessary because the `find_permutations` function generates permutations in a specific order, and we want to make sure that we don't print the same permutation multiple times.\n\nThe program also uses a helper function `is_permutation` to check if two lists are permutations of each other. This function simply sorts the lists and checks if they are equal.\n\nFinally, the program uses the `if __name__ == \"__main__\":` guard to ensure that the `solve` function is only called when the script is run directly. This is a good practice in Python programming."}, {"generated_text": "```python\nfrom collections import Counter\n\ndef find_permutations(A):\n    n = len(A)\n    cnt = Counter(A)\n    for i in range(1, n):\n        if cnt[A[i]] > 1:\n            B = A[:]\n            C = A[:]\n            C[i:] = C[:i]\n            return 'YES', B, C\n    return 'NO', [], []\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n        ans, B, C = find_permutations(A)\n        print(ans)\n        if B:\n            print(' '.join(map(str, B)))\n            print(' '.join(map(str, C)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis Python program takes an array `A` as input and checks if there exist two permutations `B` and `C` of this array such that there doesn't exist a pair of integers `(i, j)` such that `1 \u2264 i \u2264 j \u2264 N` and `(i, j) \u2260 (1, N)`, for which the subarray `B[i:j]` is a permutation of subarray `C[i:j]`.\n\nThe program first counts the frequency of each element in the array `A` using the `Counter` class from the `collections` module. Then it checks if there exists an index `i` such that the frequency of `A[i]` is greater than 1. If such an index exists, it constructs two permutations `B` and `C` by reversing the order of elements in the array `A` from index `i` to the end.\n\nIf no such index exists, it means that there are no two permutations `B` and `C` that satisfy the given condition, and the program prints 'NO'.\n\nFinally, the program prints the permutations `B` and `C` if they exist.\n\nNote that this program assumes that the input array `A` contains non-negative integers. If the input array `A` can contain negative integers or non-integer values, you may need to modify the program accordingly."}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\nimport sys\nfrom collections import Counter\n\ndef check(a):\n    n = len(a)\n    freq = Counter(a)\n    for i in range(n):\n        left = freq.copy()\n        right = freq.copy()\n        for j in range(i, n):\n            left[a[j]] -= 1\n            if left[a[j]] == 0:\n                del left[a[j]]\n            right[a[i + j - i]] -= 1\n            if right[a[i + j - i]] == 0:\n                del right[a[i + j - i]]\n            if j - i + 1 == n or len(left) == 0 or len(right) == 0:\n                return True\n    return False\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1 or check(a):\n        print(\"YES\")\n        b = sorted(a)\n        c = sorted(a, reverse=True)\n        print(*b)\n        print(*c)\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\nThis code first checks if the length of the array is 1. If it is, then it's impossible to find two permutations of the array such that the condition is satisfied. If the length of the array is greater than 1, it uses the `check` function to check if there exist two permutations of the array such that the condition is satisfied. If the condition is satisfied, it prints the two permutations; otherwise, it prints \"NO\"."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\nfrom itertools import permutations\n\ndef check(arr):\n    perms = list(permutations(arr))\n    for i in range(len(perms)):\n        for j in range(i + 1, len(perms)):\n            b = perms[i]\n            c = perms[j]\n            flag = True\n            for k in range(len(b)):\n                if k == 0 or k == len(b) - 1:\n                    if b[k]!= c[k]:\n                        flag = False\n                        break\n                else:\n                    if b[k] == c[k] or b[k] == c[k - 1] or b[k] == c[k + 1]:\n                        flag = False\n                        break\n            if flag:\n                return b, c\n    return None\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = check(arr)\n    if result is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        b, c = result\n        print(*b)\n        print(*c)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by generating all permutations of the input array, and then checking each pair of permutations to see if they satisfy the given condition. If a pair is found that satisfies the condition, it is returned as the solution. If no such pair is found after checking all permutations, it is concluded that no such permutations exist.\n\nThe time complexity of this program is O(n! * n^2), where n is the length of the input array. This is because there are n! permutations of the array, and for each permutation, we need to check n^2 pairs of elements to see if they satisfy the given condition.\n\nThe space complexity is O(n!), as we need to store all permutations of the array."}, {"generated_text": "Here is a Python program to solve the problem. This program generates two permutations of the input array where no subarray of the first permutation is a permutation of a subarray of the second permutation.\n\n```python\nimport random\nimport sys\n\ndef generate_permutation(arr):\n    permutation = arr[:]\n    random.shuffle(permutation)\n    return permutation\n\ndef check_permutations(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        if sorted(arr[i:i+2]) == sorted(arr[n-2-i:n-i-1]):\n            return False\n    return True\n\ndef solve_test_case():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        print('YES')\n        print(arr[0])\n        print(arr[0])\n        return\n\n    if not check_permutations(arr):\n        print('NO')\n        return\n\n    arr1 = generate_permutation(arr)\n    arr2 = generate_permutation(arr)\n    while arr1 == arr2:\n        arr2 = generate_permutation(arr)\n\n    print('YES')\n    print(' '.join(map(str, arr1)))\n    print(' '.join(map(str, arr2)))\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve_test_case()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first checking if the input array can be permuted into two arrays that satisfy the given condition. If not, it prints 'NO'. If so, it generates two random permutations of the input array and checks if they satisfy the condition. If not, it generates another random permutation of the second array until it finds two permutations that satisfy the condition. It then prints 'YES' followed by the two permutations.\n\nPlease note that this program may take a long time to run for large inputs because it generates random permutations. If you want to improve the efficiency of the program, you can use a more efficient algorithm to generate permutations, such as using a Fisher-Yates shuffle."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\nimport random\n\ndef check_permutations(B, C):\n    n = len(B)\n    for i in range(1, n):\n        for j in range(i, n):\n            if set(B[i:j]) == set(C[i:j]):\n                return False\n    return True\n\ndef generate_random_permutation(arr):\n    random.shuffle(arr)\n    return arr\n\ndef solve_test_case():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    B = arr[:]\n    C = arr[:]\n    \n    # Try to find a pair of permutations\n    for _ in range(1000):\n        C = generate_random_permutation(arr)\n        if check_permutations(B, C):\n            return B, C\n    \n    # If no pair of permutations is found, return None\n    return None\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        result = solve_test_case()\n        if result is None:\n            print(\"NO\")\n        else:\n            B, C = result\n            print(\"YES\")\n            print(\" \".join(map(str, B)))\n            print(\" \".join(map(str, C)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a brute-force approach to try to find a pair of permutations. It generates a random permutation of the input array and checks if it satisfies the condition. If it does, the program returns the pair of permutations. If it doesn't, the program repeats the process until it finds a pair of permutations or until it has tried 1000 times.\n\nNote that this program has a time complexity of O(1000 \\* N!), which is not efficient for large inputs. However, it is sufficient for the given constraints."}, {"generated_text": "Here's a Python program to solve the given problem:\n\n```python\nimport sys\nfrom collections import Counter\n\ndef check_permutation(a, b):\n    \"\"\"Check if two lists are permutations of each other.\"\"\"\n    return Counter(a) == Counter(b)\n\ndef find_permutations(a):\n    \"\"\"Find all permutations of a list.\"\"\"\n    def find_permutations_recursive(a, prefix, result):\n        if not a:\n            result.append(prefix)\n        else:\n            for i in range(len(a)):\n                find_permutations_recursive(a[:i] + a[i+1:], prefix + [a[i]], result)\n    permutations = []\n    find_permutations_recursive(a, [], permutations)\n    return permutations\n\ndef check_condition(a):\n    \"\"\"Check if there exist two permutations B and C of the array a,\n    for which the condition is satisfied.\"\"\"\n    permutations = find_permutations(a)\n    for i in range(len(permutations)):\n        for j in range(len(permutations)):\n            if i!= j and check_permutation(permutations[i][:-1], permutations[j][1:]):\n                return permutations[i], permutations[j]\n    return None\n\ndef solve_test_case():\n    \"\"\"Solve a single test case.\"\"\"\n    n = int(input())\n    a = list(map(int, input().split()))\n    permutations = check_condition(a)\n    if permutations:\n        print('YES')\n        print(' '.join(map(str, permutations[0])))\n        print(' '.join(map(str, permutations[1])))\n    else:\n        print('NO')\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        solve_test_case()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first finding all permutations of the input array using the `find_permutations` function. Then, for each pair of permutations, it checks if the subarray from the first permutation is a permutation of the subarray from the second permutation. If it finds such a pair, it returns it. If it doesn't find any such pair after checking all permutations, it returns `None`.\n\nThe `check_permutation` function checks if two lists are permutations of each other by comparing their element counts.\n\nThe `solve_test_case` function reads the input for a single test case, checks if there exist two permutations that satisfy the condition, and prints the result.\n\nThe `main` function reads the number of test cases and calls `solve_test_case` for each test case."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport random\nfrom collections import Counter\n\ndef check_permutations(A):\n    n = len(A)\n    if n < 4:\n        return \"NO\"\n    A.sort()\n    B = A.copy()\n    C = A.copy()\n    for i in range(1, n):\n        B[i], B[i-1] = B[i-1], B[i]\n    for i in range(n-2, 0, -1):\n        C[i], C[i+1] = C[i+1], C[i]\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if Counter(B[i:j]) == Counter(C[i:j]):\n                return \"NO\"\n    return \"YES\\n\" + \" \".join(map(str, B)) + \"\\n\" + \" \".join(map(str, C))\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        A = list(map(int, input().split()))\n        print(check_permutations(A))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program sorts the input array, then creates two permutations of it by reversing the array and reversing it in reverse order. It then checks all possible subarrays of the two permutations for equality, and returns \"NO\" if any are found to be equal. If no equal subarrays are found, it returns \"YES\" followed by the two permutations.\n\nThis solution has a time complexity of O(n^2), where n is the length of the input array."}, {"generated_text": "Here's a Python program to solve the problem. This program uses a simple brute force approach to find the permutations B and C.\n\n```python\nimport itertools\nimport sys\n\ndef find_permutations(A):\n    # Find all permutations of the array A\n    perms = list(itertools.permutations(A))\n    \n    # Check all pairs of permutations\n    for i in range(len(perms)):\n        for j in range(i+1, len(perms)):\n            B, C = perms[i], perms[j]\n            valid = True\n            \n            # Check if the subarrays B[i:j] and C[i:j] are permutations of each other\n            for k in range(1, len(A)):\n                sub_B = B[i:k]\n                sub_C = C[i:k]\n                if sorted(sub_B)!= sorted(sub_C):\n                    valid = False\n                    break\n            \n            # If the permutations B and C are valid, return them\n            if valid:\n                return B, C\n    \n    # If no valid permutations are found, return None\n    return None\n\ndef main():\n    T = int(input())\n    \n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        \n        perms = find_permutations(A)\n        \n        if perms is None:\n            print(\"NO\")\n        else:\n            B, C = perms\n            print(\"YES\")\n            print(*B)\n            print(*C)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first finding all permutations of the input array A. Then, it checks all pairs of permutations to see if they satisfy the condition. If a pair of valid permutations is found, it returns them. If no valid permutations are found, it returns None.\n\nPlease note that this program may take a long time to run for large inputs because it uses a brute force approach to find the permutations and check them."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef check_permutations(A):\n    n = len(A)\n    A.sort()\n    B = A[:]\n    C = A[::-1]\n    \n    for i in range(1, n):\n        for j in range(i, n):\n            if B[i:j+1] in [C[k:l+1] for k in range(n) for l in range(k, n)]:\n                return False\n    return True\n\ndef find_permutations(A):\n    n = len(A)\n    A.sort()\n    B = A[:]\n    C = A[::-1]\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if B[i:j+1] in [C[k:l+1] for k in range(n) for l in range(k, n)]:\n                return B, C\n    \n    return None\n\ndef solve(N, A):\n    if check_permutations(A):\n        B, C = find_permutations(A)\n        print(\"YES\")\n        print(*B)\n        print(*C)\n    else:\n        print(\"NO\")\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        solve(N, A)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first checks if there are two permutations B and C of the array A for which there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j]. If such permutations exist, it finds any of them and prints them. If no such permutations exist, it prints \"NO\". \n\nThe `check_permutations` function checks if there are two permutations B and C of the array A for which there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j]. \n\nThe `find_permutations` function finds any two permutations B and C of the array A for which there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j]. \n\nThe `solve` function solves the problem for a given array A. \n\nThe `main` function reads the input and calls the `solve` function for each test case."}, {"generated_text": "```python\nfrom collections import Counter\n\ndef check_permutations(A):\n    n = len(A)\n    count = Counter(A)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            B = A[:i] + A[n - i:]\n            C = A[i:n - i] + A[:i]\n            if set(B) == set(A) and set(C) == set(A):\n                return B, C\n    return None, None\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n        B, C = check_permutations(A)\n        if B is None:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(*B)\n            print(*C)\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n**Explanation**\n\nThis Python program solves the given problem by checking all possible permutations of the input array A. It uses the Counter class from the collections module to count the frequency of each element in A. Then, it checks all possible subarrays of A with a length that divides n (the length of A). For each such subarray, it constructs two new arrays B and C by concatenating the elements of A in a certain order. If both B and C are permutations of A and there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 n and (i, j) \u2260 (1, n), for which the subarray B[i:j] is a permutation of subarray C[i:j], then the function returns B and C.\n\n**Time Complexity**\n\nThe time complexity of this program is O(n^3), where n is the length of the input array A. This is because the program checks all possible subarrays of A with a length that divides n, and for each such subarray, it constructs two new arrays B and C.\n\n**Space Complexity**\n\nThe space complexity of this program is O(n), where n is the length of the input array A. This is because the program uses a Counter object to count the frequency of each element in A, which requires O(n) space."}, {"generated_text": "Here is a Python solution for the problem. The solution uses a simple brute-force approach by generating all possible permutations of the input array and checking if there are two permutations that satisfy the condition.\n\n```python\nimport itertools\nimport sys\n\ndef find_permutations(A):\n    # Generate all permutations of A\n    perms = list(itertools.permutations(A))\n    \n    # Check if there are two permutations that satisfy the condition\n    for i in range(len(perms)):\n        for j in range(i + 1, len(perms)):\n            B = list(perms[i])\n            C = list(perms[j])\n            if is_valid(B, C):\n                return B, C\n    return None\n\ndef is_valid(B, C):\n    N = len(B)\n    for i in range(1, N - 1):\n        B_slice = B[i:i + 2]\n        C_slice = C[i:i + 2]\n        if sorted(B_slice) == sorted(C_slice):\n            return False\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        B, C = find_permutations(A)\n        if B is None:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(*B)\n            print(*C)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution first generates all permutations of the input array `A` using the `itertools.permutations` function. It then checks each pair of permutations to see if they satisfy the condition. If a pair is found that satisfies the condition, it returns the pair. If no pair is found after checking all permutations, it returns `None`.\n\nThe `is_valid` function checks if a pair of permutations satisfies the condition. It does this by checking if any pair of adjacent elements in the permutations are equal. If it finds any such pair, it returns `False`. If it does not find any such pair, it returns `True`.\n\nThe `main` function reads the input and calls the `find_permutations` function to find a pair of permutations that satisfy the condition. If a pair is found, it prints the pair. If no pair is found, it prints \"NO\"."}, {"generated_text": "```python\ndef find_permutations(A):\n    \"\"\"\n    Find two permutations B and C of the array A such that there doesn't exist a pair of integers (i, j) \n    such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of \n    subarray C[i:j].\n\n    If such permutations exist, return them. Otherwise, return None.\n    \"\"\"\n    n = len(A)\n    if n == 1:\n        return A, A\n    if n == 2:\n        if A[0] == A[1]:\n            return A, A\n        return None\n\n    # Sort the array to find the first and last occurrence of each element\n    sorted_A = sorted(A)\n    first_occurrence = {}\n    last_occurrence = {}\n    for i, x in enumerate(sorted_A):\n        first_occurrence[x] = i\n        last_occurrence[x] = i\n\n    # Create two lists, B and C, where B has the first half of the elements and C has the second half\n    B = []\n    C = []\n    for i in range(n // 2):\n        B.append(A[i])\n        C.append(A[n - 1 - i])\n    if n % 2 == 1:\n        B.append(A[n // 2])\n\n    # Check if there exists a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), \n    # for which the subarray B[i:j] is a permutation of subarray C[i:j]\n    for i in range(n // 2 + 1):\n        for j in range(i, n // 2 + 1):\n            # Create subarrays B[i:j] and C[i:j]\n            B_subarray = B[i:j]\n            C_subarray = C[i:j]\n\n            # Sort the subarrays\n            sorted_B_subarray = sorted(B_subarray)\n            sorted_C_subarray = sorted(C_subarray)\n\n            # Check if the subarrays are permutations of each other\n            if sorted_B_subarray!= sorted_C_subarray:\n                return None\n\n    return B, C\n\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        A = list(map(int, input().split()))\n\n        permutations = find_permutations(A)\n        if permutations is None:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            B, C = permutations\n            print(\" \".join(map(str, B)))\n            print(\" \".join(map(str, C)))\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nThis code defines a function `find_permutations` that finds two permutations B and C of the array A such that there doesn't exist a pair of integers (i, j) such that 1 \u2264 i \u2264 j \u2264 N and (i, j) \u2260 (1, N), for which the subarray B[i:j] is a permutation of subarray C[i:j]. If such permutations exist, it returns them. Otherwise, it returns None.\n\nIn the `main` function, it reads the input, calls the `find_permutations` function, and prints the result.\n\nThe time complexity of this code is O(n log n) due to the sorting operation, and the space complexity is O(n) for storing the permutations."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nfrom collections import Counter\n\ndef check_permutations(A):\n    n = len(A)\n    freq = Counter(A)\n    if any(count > 1 for count in freq.values()):\n        return False\n    # Create B and C\n    B = []\n    C = []\n    for i in range(n):\n        B.append(A[n - i - 1])\n        C.append(A[i])\n    return B, C\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = list(map(int, input().split()))\n        B, C = check_permutations(A)\n        if B is None:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(' '.join(map(str, B)))\n            print(' '.join(map(str, C)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works as follows:\n\n1.  It first checks if the input array `A` contains any duplicate elements. If there are any duplicates, it immediately returns `False` because it's impossible to create two permutations `B` and `C` that satisfy the condition.\n\n2.  If `A` contains no duplicates, it creates `B` and `C` by reversing `A`. This is because we want to check the condition for all possible pairs of permutations `B` and `C`.\n\n3.  If we can create `B` and `C`, we print \"YES\" and the two permutations `B` and `C`.\n\n4.  If we cannot create `B` and `C`, we print \"NO\".\n\nThis solution runs in O(n) time, where n is the length of the input array `A`. The space complexity is also O(n), which is used to store `B` and `C`."}]}