{"id": 32, "input": "Stewie the Rabbit explores a new parallel universe. This two dimensional universe has the shape of a rectangular grid, containing n lines and m columns. The universe is very small: one cell of the grid can only contain one particle. Each particle in this universe is either static or dynamic. Each static particle always remains in one and the same position. Due to unintelligible gravitation laws no two static particles in the parallel universe can be present in one column or row, and they also can't be present in the diagonally adjacent cells. A dynamic particle appears in a random empty cell, randomly chooses the destination cell (destination cell may coincide with the start cell, see the samples) and moves there along the shortest path through the cells, unoccupied by the static particles. All empty cells have the same probability of being selected as the beginning or end of the path. Having reached the destination cell, the particle disappears. Only one dynamic particle can exist at one moment of time. This particle can move from a cell to a cell if they have an adjacent side, and this transition takes exactly one galactic second. Stewie got interested in what is the average lifespan of one particle in the given universe.\n\nInput\n\nThe first line contains two space-separated integers: n, m (2 \u2264 n, m \u2264 1000) which represent the sizes of the universe. The next n lines containing m symbols each describe the universe without dynamic particles \u2014 the j-th symbol of the i-th line equals to 'X' if the cell is occupied by a static particle, and to '.' if it is empty. It is guaranteed that the described universe satisfies the properties described above, that is no two static particles can be in one column or in one row, besides, they can't be positioned in the diagonally adjacent cells.\n\nOutput\n\nYou have to print on a single line a single number which is the average life span of a particle with an accuracy of at least 6 decimal places.\n\nThe answer will be accepted if it is within 10 - 6 of absolute or relative error from the correct answer.\n\nExamples\n\nInput\n\n2 2\n..\n.X\n\n\nOutput\n\n0.888888888889\n\n\nInput\n\n3 3\n...\n.X.\n...\n\n\nOutput\n\n2.000000000000\n", "difficulty": "VERY_HARD", "generations": [{"generated_text": "To calculate the average lifespan of a particle in the given universe, we need to consider the number of possible paths a particle can take and the time it takes to traverse each path. We can use a breadth-first search (BFS) algorithm to find the shortest path between two cells.\n\nHere's a Python program that uses BFS to calculate the average lifespan:\n\n```python\nimport sys\nfrom collections import deque\n\ndef bfs(grid, start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        (x, y), dist = queue.popleft()\n        if (x, y) == end:\n            return dist\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid)) and (0 <= ny < len(grid[0])) and (grid[nx][ny] == '.') and ((nx, ny) not in visited):\n                queue.append(((nx, ny), dist + 1))\n                visited.add((nx, ny))\n\ndef calculate_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    total_time = 0\n    num_paths = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                for x in range(n):\n                    for y in range(m):\n                        if grid[x][y] == '.':\n                            time = bfs(grid, (i, j), (x, y))\n                            if time!= -1:\n                                total_time += time\n                                num_paths += 1\n\n    return total_time / num_paths if num_paths > 0 else 0\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(input()))\n\n    print(calculate_lifespan(grid))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works as follows:\n\n1.  The `bfs` function performs a breadth-first search from a given start cell to find the shortest path to a given end cell. It returns the distance (time) if a path exists, and -1 otherwise.\n2.  The `calculate_lifespan` function calculates the average lifespan of a particle by summing up the times of all possible paths from each empty cell to all other empty cells, and dividing by the number of paths.\n3.  The `main` function reads the input grid and calls the `calculate_lifespan` function to print the result."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) algorithm to calculate the average lifespan of a particle. Here's a Python program to solve the problem:\n\n```python\nimport random\nfrom collections import deque\n\ndef calculate_average_lifespan(n, m, grid):\n    # Initialize the count of valid positions\n    count = 0\n    total_lifespan = 0\n\n    # Iterate over all possible starting positions\n    for i in range(n):\n        for j in range(m):\n            # Check if the current cell is empty\n            if grid[i][j] == '.':\n                # Initialize the BFS queue\n                queue = deque([(i, j, 0)])  # x, y, lifespan\n                visited = {(i, j)}\n\n                # Perform BFS\n                while queue:\n                    x, y, lifespan = queue.popleft()\n\n                    # Update the total lifespan and count\n                    total_lifespan += lifespan\n                    count += 1\n\n                    # Check all possible destinations\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n\n                        # Check if the destination is within the grid and empty\n                        if (0 <= nx < n) and (0 <= ny < m) and grid[nx][ny] == '.' and (nx, ny) not in visited:\n                            queue.append((nx, ny, lifespan + 1))\n                            visited.add((nx, ny))\n\n    # Return the average lifespan\n    return total_lifespan / count\n\n\n# Read the input\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\n\n# Calculate and print the average lifespan\naverage_lifespan = calculate_average_lifespan(n, m, grid)\nprint(f\"{average_lifespan:.6f}\")\n```\n\nThis program first reads the input grid size and the grid itself. Then, it calculates the average lifespan of a particle by iterating over all possible starting positions, performing a BFS from each position, and updating the total lifespan and count. Finally, it returns the average lifespan and prints it with six decimal places."}, {"generated_text": "```python\nimport random\nfrom typing import List, Tuple\n\ndef generate_random_path(grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a random path from start to end in the grid.\n    \"\"\"\n    path = [start]\n    current = start\n    while current!= end:\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        random.shuffle(directions)\n        for dx, dy in directions:\n            nx, ny = current[0] + dx, current[1] + dy\n            if (0 <= nx < len(grid)) and (0 <= ny < len(grid[nx])) and grid[nx][ny] == '.':\n                path.append((nx, ny))\n                current = (nx, ny)\n                break\n    return path\n\ndef simulate_particle(grid: List[List[str]], start: Tuple[int, int]) -> int:\n    \"\"\"\n    Simulate a particle starting at the given position.\n    \"\"\"\n    n, m = len(grid), len(grid[0])\n    path = generate_random_path(grid, start, (start[0], start[1]))\n    return len(path) - 1\n\ndef average_lifespan(grid: List[List[str]]) -> float:\n    \"\"\"\n    Calculate the average lifespan of a particle in the grid.\n    \"\"\"\n    n, m = len(grid), len(grid[0])\n    total_lifespan = 0\n    num_simulations = 1000\n    for _ in range(num_simulations):\n        start = (random.randint(0, n - 1), random.randint(0, m - 1))\n        while grid[start[0]][start[1]] == 'X':\n            start = (random.randint(0, n - 1), random.randint(0, m - 1))\n        total_lifespan += simulate_particle(grid, start)\n    return total_lifespan / num_simulations\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    print(average_lifespan(grid))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code uses a Monte Carlo simulation to estimate the average lifespan of a particle. It generates a random path for each particle from a random start position to a random end position, and then calculates the length of that path (which represents the lifespan of the particle). The average lifespan is then calculated by summing up the lifespans of all particles and dividing by the number of simulations."}, {"generated_text": "To calculate the average lifespan of a particle in the given universe, we can use the concept of random walks and the properties of the grid. We'll calculate the average number of steps a particle can take before disappearing and then divide it by the total number of possible starting positions.\n\nHere's the Python code to solve the problem:\n\n```python\nimport random\nimport math\n\ndef calculate_average_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    total_steps = 0\n    total_start_positions = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_start_positions += 1\n\n                # Calculate the number of possible steps from this position\n                directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n                possible_steps = 0\n                visited = set()\n\n                # Perform a random walk from the current position\n                queue = [(i, j)]\n                while queue:\n                    x, y = queue.pop(0)\n                    if (x, y) not in visited:\n                        visited.add((x, y))\n                        if grid[x][y] == '.':\n                            possible_steps += 1\n                        for dx, dy in directions:\n                            nx, ny = x + dx, y + dy\n                            if (0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited):\n                                queue.append((nx, ny))\n\n                total_steps += possible_steps\n\n    average_lifespan = total_steps / total_start_positions\n    return average_lifespan\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(input()))\n\n    average_lifespan = calculate_average_lifespan(grid)\n    print(format(average_lifespan, \".6f\"))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code first reads the grid from the input, then calculates the average number of steps a particle can take before disappearing from each possible starting position. Finally, it prints the average lifespan with an accuracy of at least 6 decimal places."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) algorithm to find the shortest path for each dynamic particle. We can then calculate the average lifespan of the particle by taking the sum of all lifespans and dividing by the number of particles.\n\nHere is a Python program that solves the problem:\n\n```python\nimport sys\nfrom collections import deque\n\ndef can_place(grid, i, j):\n    n, m = len(grid), len(grid[0])\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if grid[x][y] == 'X' and (x == i and y == j or abs(x-i) == abs(y-j)):\n                return False\n    return True\n\ndef bfs(grid, start):\n    n, m = len(grid), len(grid[0])\n    queue = deque([(start, 0)])\n    visited = set([start])\n    while queue:\n        (x, y), dist = queue.popleft()\n        if grid[x][y]!= 'X':\n            return dist\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                if can_place(grid, nx, ny):\n                    queue.append(((nx, ny), dist + 1))\n                    visited.add((nx, ny))\n    return -1\n\ndef calculate_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    total_lifespan = 0\n    num_particles = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_lifespan += bfs(grid, (i, j))\n                num_particles += 1\n    return total_lifespan / num_particles if num_particles > 0 else 0\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    print(\"{:.6f}\".format(calculate_lifespan(grid)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works as follows:\n\n- The `can_place` function checks if a particle can be placed at a given position in the grid.\n- The `bfs` function performs a breadth-first search to find the shortest path for a particle starting from a given position.\n- The `calculate_lifespan` function calculates the total lifespan of all particles in the grid.\n- The `main` function reads the input, constructs the grid, and prints the average lifespan of the particles."}, {"generated_text": "To calculate the average lifespan of a particle in the given universe, we can simulate the movement of a particle through the grid. We will count the number of steps it takes for the particle to reach a new destination, and repeat this process many times to get an estimate of the average lifespan.\n\n```python\nimport random\nimport numpy as np\n\ndef calculate_lifespan(n, m, grid):\n    \"\"\"\n    Calculate the average lifespan of a particle in the given universe.\n\n    Args:\n    n (int): The number of rows in the grid.\n    m (int): The number of columns in the grid.\n    grid (list): A 2D list representing the grid, where 'X' represents a static particle and '.' represents an empty cell.\n\n    Returns:\n    float: The average lifespan of a particle in the given universe.\n    \"\"\"\n    # Initialize a counter for the total number of steps\n    total_steps = 0\n\n    # Repeat the simulation many times\n    for _ in range(100000):\n        # Choose a random empty cell as the starting point\n        start_x, start_y = random.randint(0, n-1), random.randint(0, m-1)\n        while grid[start_x][start_y] == 'X':\n            start_x, start_y = random.randint(0, n-1), random.randint(0, m-1)\n\n        # Choose a random empty cell as the destination point\n        dest_x, dest_y = random.randint(0, n-1), random.randint(0, m-1)\n        while grid[dest_x][dest_y] == 'X' or (start_x == dest_x and start_y == dest_y):\n            dest_x, dest_y = random.randint(0, n-1), random.randint(0, m-1)\n\n        # Initialize a counter for the number of steps in this simulation\n        steps = 0\n\n        # Simulate the movement of the particle\n        while (start_x, start_y)!= (dest_x, dest_y):\n            # Choose a random adjacent cell as the next destination\n            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # right, left, down, up\n            random.shuffle(directions)\n            for dx, dy in directions:\n                new_x, new_y = start_x + dx, start_y + dy\n                if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] == '.':\n                    start_x, start_y = new_x, new_y\n                    break\n            steps += 1\n\n        # Update the total number of steps\n        total_steps += steps + 1  # +1 for the final step to the destination\n\n    # Calculate the average lifespan\n    average_lifespan = total_steps / 100000.0\n\n    return average_lifespan\n\ndef main():\n    # Read the input\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    # Calculate the average lifespan\n    average_lifespan = calculate_lifespan(n, m, grid)\n\n    # Print the result\n    print(\"%.6f\" % average_lifespan)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a simple simulation to estimate the average lifespan of a particle in the given universe. It chooses a random empty cell as the starting point and a random empty cell as the destination point, then simulates the movement of the particle through the grid. The number of steps in each simulation is counted and accumulated to estimate the average lifespan. The result is printed with an accuracy of at least 6 decimal places."}, {"generated_text": "Here's a Python solution to the problem using breadth-first search (BFS) to calculate the average lifespan of a particle.\n\n```python\nfrom collections import deque\nimport math\n\ndef is_valid(grid, r, c):\n    \"\"\"\n    Check if a cell is valid to place a particle\n    \"\"\"\n    return 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == '.'\n\ndef count_particles(grid):\n    \"\"\"\n    Count the number of static particles in the grid\n    \"\"\"\n    return sum(row.count('X') for row in grid)\n\ndef bfs(grid, start):\n    \"\"\"\n    Perform BFS to find the shortest path to all reachable cells\n    \"\"\"\n    queue = deque([(start, 0)])\n    visited = set([start])\n    parent = {start: None}\n\n    while queue:\n        (r, c), dist = queue.popleft()\n        if grid[r][c] == 'X':\n            continue\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if is_valid(grid, nr, nc) and (nr, nc) not in visited:\n                queue.append(((nr, nc), dist + 1))\n                visited.add((nr, nc))\n                parent[(nr, nc)] = (r, c)\n\n    return parent\n\ndef calculate_lifespan(grid):\n    \"\"\"\n    Calculate the average lifespan of a particle\n    \"\"\"\n    n, m = len(grid), len(grid[0])\n    particles = count_particles(grid)\n    lifespan = 0\n    total_paths = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                continue\n            parent = bfs(grid, (i, j))\n            # Calculate the number of paths from each cell to the destination cell\n            for r, c in parent:\n                if grid[r][c] == 'X':\n                    continue\n                total_paths += 1\n                lifespan += parent[(r, c)][1] if parent[(r, c)][1] else 1\n\n    return lifespan / total_paths\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n\n    average_lifespan = calculate_lifespan(grid)\n    print(\"{:.6f}\".format(average_lifespan))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first counts the number of static particles in the grid. Then it performs BFS from each empty cell to calculate the shortest path to all reachable cells. Finally, it calculates the average lifespan of a particle by summing up the distances from each cell to the destination cell and dividing by the total number of paths.\n\nNote that this program assumes that the input grid is a rectangular grid with n lines and m columns, and that each cell is either empty or occupied by a static particle. The program also assumes that the static particles are placed such that no two particles are in the same row or column, and that no two particles are in diagonally adjacent cells."}, {"generated_text": "```python\nfrom sys import stdin\nfrom random import randint\n\ndef read_input():\n    n, m = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(stdin.readline().strip()))\n    return n, m, grid\n\ndef is_valid_move(grid, x, y, visited):\n    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == '.' and not visited[x][y]:\n        return True\n    return False\n\ndef bfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    visited = [[False]*m for _ in range(n)]\n    visited[x][y] = True\n    queue = [(x, y)]\n    distance = 0\n    while queue:\n        new_queue = []\n        for x, y in queue:\n            distance += 1\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid_move(grid, nx, ny, visited):\n                    visited[nx][ny] = True\n                    new_queue.append((nx, ny))\n        queue = new_queue\n    return distance\n\ndef simulate(n, m, grid):\n    total_distance = 0\n    num_simulations = 10000\n    for _ in range(num_simulations):\n        x, y = randint(0, n-1), randint(0, m-1)\n        while grid[x][y]!= '.':\n            x, y = randint(0, n-1), randint(0, m-1)\n        distance = bfs(grid, x, y)\n        total_distance += distance\n    return total_distance / num_simulations\n\ndef main():\n    n, m, grid = read_input()\n    print(\"{:.6f}\".format(simulate(n, m, grid)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works as follows:\n\n1. Read the grid size and the grid itself from the input.\n2. Simulate the particle's movement for a large number of times (10000 in this case).\n3. In each simulation, randomly choose a start position and calculate the distance to the nearest unoccupied cell using BFS.\n4. Calculate the average distance over all simulations.\n5. Print the result with at least 6 decimal places.\n\nNote that the simulation is not exact, as it only uses a large number of simulations to estimate the average distance. However, this should be good enough for most purposes."}, {"generated_text": "```python\nimport numpy as np\n\ndef get_distance(map, start, end):\n    \"\"\"\n    Calculate the Manhattan distance between two points in a grid.\n    \n    Args:\n    map (2D list): Grid map.\n    start (tuple): Starting point coordinates.\n    end (tuple): Ending point coordinates.\n    \n    Returns:\n    int: Manhattan distance between the two points.\n    \"\"\"\n    return abs(start[0] - end[0]) + abs(start[1] - end[1])\n\ndef get_paths(map, start, end):\n    \"\"\"\n    Get all possible paths between two points in a grid.\n    \n    Args:\n    map (2D list): Grid map.\n    start (tuple): Starting point coordinates.\n    end (tuple): Ending point coordinates.\n    \n    Returns:\n    list: List of all possible paths.\n    \"\"\"\n    paths = []\n    queue = [(start, [start])]\n    visited = set([start])\n    \n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == end:\n            paths.append(path)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(map)) and (0 <= ny < len(map[0])) and (map[nx][ny]!= 'X') and ((nx, ny) not in visited):\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                visited.add((nx, ny))\n    \n    return paths\n\ndef get_average_lifespan(map):\n    \"\"\"\n    Calculate the average lifespan of a particle in a grid.\n    \n    Args:\n    map (2D list): Grid map.\n    \n    Returns:\n    float: Average lifespan.\n    \"\"\"\n    n, m = len(map), len(map[0])\n    total_paths = 0\n    total_lifespan = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if map[i][j] == '.':\n                empty_cells = [(i, j)]\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = i + dx, j + dy\n                    if (0 <= nx < n) and (0 <= ny < m) and (map[nx][ny] == '.'):\n                        empty_cells.append((nx, ny))\n                \n                for end in empty_cells:\n                    paths = get_paths(map, (i, j), end)\n                    total_paths += len(paths)\n                    for path in paths:\n                        lifespan = get_distance(map, (i, j), end)\n                        total_lifespan += len(path) - 1\n    \n    return total_lifespan / total_paths\n\ndef main():\n    n, m = map(int, input().split())\n    map = [list(input().strip()) for _ in range(n)]\n    average_lifespan = get_average_lifespan(map)\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\nThis program first reads the grid map from the input, then calculates the average lifespan of a particle in the grid. The `get_distance` function calculates the Manhattan distance between two points in the grid, the `get_paths` function gets all possible paths between two points in the grid, and the `get_average_lifespan` function calculates the average lifespan of a particle in the grid. The `main` function reads the grid map from the input, calculates the average lifespan, and prints the result."}, {"generated_text": "To solve this problem, we can use the following Python program:\n\n```python\nimport sys\nimport random\n\ndef generate_random_path(grid, start, end):\n    queue = [(start, [start])]\n    visited = set([start])\n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == end:\n            return path\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid)) and (0 <= ny < len(grid[0])) and (grid[nx][ny] == '.') and ((nx, ny) not in visited):\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                visited.add((nx, ny))\n    return None\n\ndef calculate_average_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    total_lifespan = 0\n    num_paths = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                start = (i, j)\n                for k in range(n):\n                    for col in range(m):\n                        if grid[k][col] == 'X':\n                            continue\n                        end = (k, col)\n                        path = generate_random_path(grid, start, end)\n                        if path:\n                            total_lifespan += len(path) - 1\n                            num_paths += 1\n    return total_lifespan / num_paths if num_paths > 0 else 0\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    average_lifespan = calculate_average_lifespan(grid)\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first reads the input grid and then calculates the average lifespan by generating all possible paths for each empty cell in the grid. The average lifespan is then printed out with an accuracy of at least 6 decimal places."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) algorithm to find the shortest path for each dynamic particle. We will also use a dictionary to store the positions of static particles for efficient lookups.\n\nHere is the Python code to solve this problem:\n\n```python\nfrom collections import deque\nimport sys\nimport random\n\ndef get_shortest_path(grid, start, end):\n    # Directions to move in the grid\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Queue for BFS, contains cells in the form (x, y, distance)\n    queue = deque([(start[0], start[1], 0)])\n\n    # Set to keep track of visited cells\n    visited = set((start[0], start[1]))\n\n    while queue:\n        x, y, dist = queue.popleft()\n\n        # If this is the destination cell, return the distance\n        if (x, y) == end:\n            return dist\n\n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check if the neighbor is within the grid and not visited\n            if (0 <= nx < len(grid)) and (0 <= ny < len(grid[0])) and (nx, ny) not in visited:\n                # Check if the neighbor is not occupied by a static particle\n                if grid[nx][ny] == '.':\n                    queue.append((nx, ny, dist + 1))\n                    visited.add((nx, ny))\n\n    # If there is no path to the destination\n    return -1\n\ndef calculate_average_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    static_particles = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                static_particles.append((i, j))\n\n    total_lifespan = 0\n    num_particles = 0\n    for i in range(n):\n        for j in range(m):\n            # Skip cells occupied by static particles\n            if grid[i][j] == 'X':\n                continue\n\n            # Choose a random destination cell\n            end_x, end_y = random.randint(0, n - 1), random.randint(0, m - 1)\n\n            # Calculate the shortest path to the destination\n            lifespan = get_shortest_path(grid, (i, j), (end_x, end_y))\n\n            # If there is no path to the destination, skip this particle\n            if lifespan == -1:\n                continue\n\n            total_lifespan += lifespan\n            num_particles += 1\n\n    # Calculate the average lifespan\n    if num_particles == 0:\n        return 0\n    return total_lifespan / num_particles\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    average_lifespan = calculate_average_lifespan(grid)\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code first reads the grid size and the grid itself from the input. It then calculates the average lifespan of a particle by simulating many particles and calculating their lifespans. The `get_shortest_path` function uses a BFS algorithm to find the shortest path between two cells in the grid. The `calculate_average_lifespan` function simulates many particles and calculates their lifespans. Finally, the `main` function reads the input, calculates the average lifespan, and prints the result."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) algorithm to find the shortest path from the starting point to the ending point, considering the static particles as obstacles. We can then calculate the average lifespan of the particle.\n\nHere is the Python code to solve this problem:\n\n```python\nfrom collections import deque\nimport math\n\ndef bfs(grid, start, end):\n    \"\"\"Perform a breadth-first search to find the shortest path from start to end.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    queue = deque([(start, 0)])\n    visited = set((start,))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while queue:\n        (x, y), dist = queue.popleft()\n        \n        if (x, y) == end:\n            return dist\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if (0 <= nx < rows and 0 <= ny < cols and \n                grid[nx][ny] == '.' and (nx, ny) not in visited):\n                queue.append(((nx, ny), dist + 1))\n                visited.add((nx, ny))\n                \n    return -1  # No path found\n\ndef calculate_lifespan(grid, n, m):\n    \"\"\"Calculate the average lifespan of a particle in the grid.\"\"\"\n    total_lifespan = 0\n    total_paths = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                for _ in range(100):  # Try 100 random paths from each empty cell\n                    x, y = i, j\n                    end_x, end_y = i, j\n                    \n                    while (x, y)!= (end_x, end_y):\n                        end_x, end_y = random.randint(0, n - 1), random.randint(0, m - 1)\n                        \n                    total_lifespan += bfs(grid, (x, y), (end_x, end_y))\n                    total_paths += 1\n                    \n    return total_lifespan / total_paths\n\nimport random\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    \n    avg_lifespan = calculate_lifespan(grid, n, m)\n    \n    print(f\"{avg_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code first reads the grid from the input and then calculates the average lifespan of a particle in the grid by trying 100 random paths from each empty cell and averaging the lifespans of these paths. The result is printed to the console with an accuracy of at least 6 decimal places."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nimport random\nimport math\n\ndef calculate_lifespan(n, m, grid):\n    \"\"\"\n    Calculate the average lifespan of a particle in the given universe.\n\n    Args:\n    n (int): The number of rows in the grid.\n    m (int): The number of columns in the grid.\n    grid (list): A 2D list representing the grid, where '.' represents an empty cell and 'X' represents a static particle.\n\n    Returns:\n    float: The average lifespan of a particle in the given universe.\n    \"\"\"\n\n    def is_valid_move(x, y):\n        \"\"\"\n        Check if a move to the given cell is valid.\n\n        Args:\n        x (int): The row index of the cell.\n        y (int): The column index of the cell.\n\n        Returns:\n        bool: True if the move is valid, False otherwise.\n        \"\"\"\n        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n    def calculate_distance(x1, y1, x2, y2):\n        \"\"\"\n        Calculate the Manhattan distance between two cells.\n\n        Args:\n        x1 (int): The row index of the first cell.\n        y1 (int): The column index of the first cell.\n        x2 (int): The row index of the second cell.\n        y2 (int): The column index of the second cell.\n\n        Returns:\n        int: The Manhattan distance between the two cells.\n        \"\"\"\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def simulate_particle():\n        \"\"\"\n        Simulate a particle moving through the grid.\n\n        Returns:\n        int: The lifespan of the particle.\n        \"\"\"\n        x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        while grid[x][y]!= '.':\n            x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n\n        lifespan = 0\n        while True:\n            grid[x][y] = '.'\n            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # right, left, down, up\n            random.shuffle(directions)\n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if is_valid_move(new_x, new_y):\n                    grid[new_x][new_y] = '.'\n                    lifespan += calculate_distance(x, y, new_x, new_y)\n                    x, y = new_x, new_y\n                    break\n            else:\n                break\n\n        return lifespan\n\n    total_lifespan = 0\n    for _ in range(1000000):  # simulate 1 million particles\n        total_lifespan += simulate_particle()\n\n    return total_lifespan / 1000000.0\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n\n    average_lifespan = calculate_lifespan(n, m, grid)\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a Monte Carlo simulation to estimate the average lifespan of a particle in the given universe. It simulates a large number of particles (1 million in this case) and calculates the average lifespan by summing up the lifespans of all particles and dividing by the number of particles.\n\nThe `simulate_particle` function simulates a single particle moving through the grid. It starts at a random empty cell and moves to a new cell in each iteration, choosing a random direction at each step. The particle stops moving when it reaches a cell that is not adjacent to any empty cell.\n\nThe `calculate_lifespan` function calculates the average lifespan of a particle in the given universe by simulating a large number of particles and calculating the average lifespan.\n\nThe `main` function reads the input from the user, creates a grid representation of the universe, and calls the `calculate_lifespan` function to calculate the average lifespan. It then prints the result to the console."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) to calculate the distance (or lifespan) of each dynamic particle from any empty cell. We will sum up all the lifespans and then divide by the total number of empty cells.\n\nHere is a Python program that implements the above solution:\n\n```python\nfrom collections import deque\n\ndef bfs(grid, x, y):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(x, y, 0)])\n    visited = {(x, y)}\n    max_distance = 0\n\n    while queue:\n        cx, cy, distance = queue.popleft()\n        max_distance = max(max_distance, distance)\n\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n\n            if (0 <= nx < len(grid)) and (0 <= ny < len(grid[0])) and (grid[nx][ny] == '.') and ((nx, ny) not in visited):\n                queue.append((nx, ny, distance + 1))\n                visited.add((nx, ny))\n\n    return max_distance\n\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    total_distance = 0\n    total_cells = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_cells += 1\n                distance = bfs(grid, i, j)\n                total_distance += distance\n\n    average_lifespan = total_distance / total_cells\n    print(f\"{average_lifespan:.6f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first reads the grid size and the grid itself from the input. Then it uses a BFS to calculate the distance from each empty cell to the closest static particle. It sums up all these distances and divides by the total number of empty cells to get the average lifespan. The result is then printed out."}, {"generated_text": "To solve this problem, we need to find the average lifespan of a particle in the given universe. We can do this by simulating the movement of the particle for a large number of iterations and then calculating the average lifespan.\n\nHere's a Python program that implements this:\n\n```python\nimport random\nimport math\n\ndef distance(cell1, cell2):\n    return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1])\n\ndef get_valid_moves(cell, grid):\n    valid_moves = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            new_cell = (cell[0] + i, cell[1] + j)\n            if 0 <= new_cell[0] < len(grid) and 0 <= new_cell[1] < len(grid[0]) and grid[new_cell[0]][new_cell[1]] == '.':\n                valid_moves.append(new_cell)\n    return valid_moves\n\ndef simulate_particle(grid):\n    start_cell = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '.':\n                start_cell = (i, j)\n                break\n        if start_cell:\n            break\n\n    lifespan = 0\n    current_cell = start_cell\n    while True:\n        valid_moves = get_valid_moves(current_cell, grid)\n        if not valid_moves:\n            break\n        target_cell = random.choice(valid_moves)\n        lifespan += distance(current_cell, target_cell)\n        current_cell = target_cell\n        grid[current_cell[0]][current_cell[1]] = 'X'\n\n    return lifespan\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    total_lifespan = 0\n    for _ in range(100000):\n        total_lifespan += simulate_particle([row[:] for row in grid])\n\n    average_lifespan = total_lifespan / 100000\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first defines a few helper functions: `distance` calculates the Manhattan distance between two cells, `get_valid_moves` returns a list of valid moves for a particle at a given cell, and `simulate_particle` simulates the movement of a particle in the grid.\n\nIn the `main` function, we read the grid from the input, simulate the movement of a particle 100,000 times, and calculate the average lifespan. We then print the average lifespan with an accuracy of at least 6 decimal places."}, {"generated_text": "To calculate the average lifespan of a particle, we need to find all possible paths for the particle to move from one cell to another. We can use a breadth-first search (BFS) algorithm to find the shortest path between two cells.\n\nHere's a Python program to solve this problem:\n\n```python\nimport sys\nimport random\nimport math\nfrom collections import deque\n\n# Define the size of the universe\nn, m = map(int, input().split())\n\n# Define the universe as a 2D grid\nuniverse = []\nfor _ in range(n):\n    universe.append(list(input().strip()))\n\n# Define the possible directions to move\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n# Function to check if a cell is valid\ndef is_valid(x, y):\n    return 0 <= x < n and 0 <= y < m and universe[x][y] == '.'\n\n# Function to perform BFS\ndef bfs(x, y):\n    queue = deque([(x, y, 0)])\n    visited = {(x, y)}\n    while queue:\n        x, y, dist = queue.popleft()\n        if is_valid(x, y):\n            if universe[x][y] == '.':\n                return dist\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                queue.append((nx, ny, dist + 1))\n                visited.add((nx, ny))\n    return -1\n\n# Calculate the average lifespan\ntotal_lifespan = 0\ntotal_paths = 0\nfor i in range(n):\n    for j in range(m):\n        if universe[i][j] == '.':\n            for _ in range(10000):\n                x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n                while universe[x][y] == '.':\n                    x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n                dist = bfs(i, j)\n                if dist!= -1:\n                    total_lifespan += dist\n                    total_paths += 1\n                    break\n\n# Calculate the average lifespan\nif total_paths > 0:\n    average_lifespan = total_lifespan / total_paths\nelse:\n    average_lifespan = 0\n\nprint(\"{:.6f}\".format(average_lifespan))\n```\n\nThis program first reads the size of the universe and the universe itself from the input. It then defines the possible directions to move and a function to check if a cell is valid. The `bfs` function performs a breadth-first search to find the shortest path between two cells.\n\nThe program then calculates the average lifespan by simulating many paths for the particle to move. It counts the total lifespan and the total number of paths, and then calculates the average lifespan by dividing the total lifespan by the total number of paths.\n\nFinally, the program prints the average lifespan with an accuracy of at least 6 decimal places."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) algorithm to find the shortest path between two random cells in the grid. We will generate a large number of random paths and calculate the average length of these paths.\n\nHere's the Python code to solve the problem:\n\n```python\nimport random\nimport math\n\ndef generate_grid(n, m):\n    grid = []\n    for _ in range(n):\n        row = list(input())\n        grid.append(row)\n    return grid\n\ndef is_valid(x, y, grid):\n    n, m = len(grid), len(grid[0])\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    if grid[x][y] == 'X':\n        return False\n    if x > 0 and grid[x-1][y] == 'X' and y > 0 and grid[x][y-1] == 'X':\n        return False\n    return True\n\ndef bfs(grid, start_x, start_y, end_x, end_y):\n    n, m = len(grid), len(grid[0])\n    queue = [(start_x, start_y, 0)]\n    visited = set((start_x, start_y))\n    while queue:\n        x, y, dist = queue.pop(0)\n        if (x, y) == (end_x, end_y):\n            return dist\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if is_valid(new_x, new_y, grid) and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y, dist + 1))\n                visited.add((new_x, new_y))\n    return -1\n\ndef calculate_average_lifespan(n, m):\n    grid = generate_grid(n, m)\n    total_lifespan = 0\n    num_paths = 1000000\n    for _ in range(num_paths):\n        start_x, start_y = random.randint(0, n-1), random.randint(0, m-1)\n        while grid[start_x][start_y] == 'X':\n            start_x, start_y = random.randint(0, n-1), random.randint(0, m-1)\n        end_x, end_y = random.randint(0, n-1), random.randint(0, m-1)\n        while (end_x, end_y) == (start_x, start_y) or grid[end_x][end_y] == 'X':\n            end_x, end_y = random.randint(0, n-1), random.randint(0, m-1)\n        lifespan = bfs(grid, start_x, start_y, end_x, end_y)\n        total_lifespan += lifespan\n    return total_lifespan / num_paths\n\nn, m = map(int, input().split())\nprint(calculate_average_lifespan(n, m))\n```\n\nThis code first generates the grid from the input, then calculates the average lifespan by generating a large number of random paths and calculating the average length of these paths. The `is_valid` function checks whether a cell is valid to visit, the `bfs` function performs a breadth-first search to find the shortest path between two cells, and the `calculate_average_lifespan` function calculates the average lifespan."}, {"generated_text": "To solve this problem, we can use a breadth-first search (BFS) to calculate the shortest distance from each empty cell to every other cell. We can then use this information to calculate the average lifespan of a particle.\n\nHere is a Python program to solve the problem:\n\n```python\nfrom collections import deque\n\ndef calculate_distance(grid):\n    n, m = len(grid), len(grid[0])\n    distances = [[float('inf')] * m for _ in range(n)]\n    queue = deque()\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                distances[i][j] = 0\n                queue.append((i, j))\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and distances[nx][ny] > distances[x][y] + 1:\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n\n    return distances\n\ndef calculate_average_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    distances = calculate_distance(grid)\n    total_distance = 0\n    total_cells = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_cells += 1\n                for x in range(n):\n                    for y in range(m):\n                        if grid[x][y] == '.':\n                            total_distance += distances[i][j] + distances[x][y]\n\n    return total_distance / (total_cells * (total_cells - 1))\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    print(\"{:.6f}\".format(calculate_average_lifespan(grid)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first calculates the shortest distance from each empty cell to every other cell using BFS, and then uses this information to calculate the average lifespan of a particle. The result is printed with an accuracy of at least 6 decimal places."}, {"generated_text": "To calculate the average lifespan of a particle in the given universe, we can simulate the movement of the particle from each empty cell to every other empty cell. We'll use a breadth-first search (BFS) algorithm to find the shortest path between two cells.\n\n```python\nimport sys\nfrom collections import deque\n\ndef is_valid_move(grid, visited, i, j):\n    \"\"\"Check if a move to (i, j) is valid\"\"\"\n    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n        return False\n    if grid[i][j] == 'X':\n        return False\n    if visited[i][j]:\n        return False\n    return True\n\ndef bfs(grid, i, j):\n    \"\"\"Perform BFS to find the shortest path to an empty cell\"\"\"\n    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n    queue = deque([(i, j, 0)])\n    visited[i][j] = True\n    while queue:\n        x, y, dist = queue.popleft()\n        if grid[x][y] == '.':\n            return dist\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid_move(grid, visited, nx, ny):\n                queue.append((nx, ny, dist + 1))\n                visited[nx][ny] = True\n    return -1\n\ndef calculate_average_lifespan(grid):\n    \"\"\"Calculate the average lifespan of a particle\"\"\"\n    n, m = len(grid), len(grid[0])\n    total_lifespan = 0\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_lifespan += bfs(grid, i, j)\n                count += 1\n    if count == 0:\n        return 0\n    return total_lifespan / count\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(n)]\n    average_lifespan = calculate_average_lifespan(grid)\n    print(f\"{average_lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first reads the input grid and then calculates the average lifespan of a particle by simulating the movement of the particle from each empty cell to every other empty cell. The `bfs` function performs a breadth-first search to find the shortest path to an empty cell, and the `calculate_average_lifespan` function calculates the total lifespan of all particles and divides it by the count of particles to get the average lifespan. The result is then printed with six decimal places."}, {"generated_text": "To calculate the average lifespan of a dynamic particle in the given universe, we need to simulate the movement of a particle in the grid and calculate the average number of steps it takes to reach a destination.\n\nHere is a Python program that solves the problem using a breadth-first search (BFS) algorithm to simulate the movement of a particle:\n\n```python\nimport sys\nfrom collections import deque\n\ndef bfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    queue = deque([(x, y, 0)])\n    visited[x][y] = True\n    while queue:\n        curr_x, curr_y, steps = queue.popleft()\n        if steps > 0:\n            return steps\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            new_x, new_y = curr_x + dx, curr_y + dy\n            if 0 <= new_x < n and 0 <= new_y < m and not visited[new_x][new_y] and grid[new_x][new_y] == '.':\n                queue.append((new_x, new_y, steps + 1))\n                visited[new_x][new_y] = True\n    return 0\n\ndef calculate_lifespan(grid):\n    n, m = len(grid), len(grid[0])\n    total_lifespan = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                total_lifespan += bfs(grid, i, j)\n    return total_lifespan / (n * m)\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(input()))\n    lifespan = calculate_lifespan(grid)\n    print(f\"{lifespan:.6f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by simulating the movement of a particle in the grid using BFS and calculating the average lifespan by summing up the lifespans of all particles and dividing by the total number of particles.\n\nNote that the grid is represented as a 2D list, where '.' represents an empty cell and 'X' represents a cell occupied by a static particle.\n\nThe `bfs` function takes a grid, a starting position, and returns the number of steps it takes for the particle to reach a destination.\n\nThe `calculate_lifespan` function calculates the average lifespan by summing up the lifespans of all particles and dividing by the total number of particles.\n\nThe `main` function reads the input, calculates the average lifespan, and prints the result."}]}