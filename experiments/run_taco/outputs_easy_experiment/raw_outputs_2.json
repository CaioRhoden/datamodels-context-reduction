{"id": 2, "input": "Little Petya likes to play a lot. Most of all he likes to play a game \u00abHoles\u00bb. This is a game for one person with following rules:\n\nThere are N holes located in a single row and numbered from left to right with numbers from 1 to N. Each hole has it's own power (hole number i has the power ai). If you throw a ball into hole i it will immediately jump to hole i + ai, then it will jump out of it and so on. If there is no hole with such number, the ball will just jump out of the row. On each of the M moves the player can perform one of two actions: \n\n  * Set the power of the hole a to value b. \n  * Throw a ball into the hole a and count the number of jumps of a ball before it jump out of the row and also write down the number of the hole from which it jumped out just before leaving the row. \n\n\n\nPetya is not good at math, so, as you have already guessed, you are to perform all computations.\n\nInput\n\nThe first line contains two integers N and M (1 \u2264 N \u2264 105, 1 \u2264 M \u2264 105) \u2014 the number of holes in a row and the number of moves. The second line contains N positive integers not exceeding N \u2014 initial values of holes power. The following M lines describe moves made by Petya. Each of these line can be one of the two types: \n\n  * 0 a b\n  * 1 a\n\nType 0 means that it is required to set the power of hole a to b, and type 1 means that it is required to throw a ball into the a-th hole. Numbers a and b are positive integers do not exceeding N.\n\nOutput\n\nFor each move of the type 1 output two space-separated numbers on a separate line \u2014 the number of the last hole the ball visited before leaving the row and the number of jumps it made.\n\nExamples\n\nInput\n\n8 5\n1 1 1 1 1 2 8 2\n1 1\n0 1 3\n1 1\n0 3 4\n1 2\n\n\nOutput\n\n8 7\n8 5\n7 3\n", "difficulty": "VERY_HARD", "generations": [{"generated_text": "```python\ndef solve(n, m, a, moves):\n    memo = {}\n    for i in range(n):\n        memo[i+1] = [0, i+1]\n\n    for move in moves:\n        if move[0] == 0:  # Set the power of hole a to value b\n            memo[move[1]] = [move[2], move[1]]\n        else:  # Throw a ball into the hole a\n            res = simulate(memo, move[1])\n            print(res[0], res[1])\n\n\ndef simulate(memo, start):\n    if start not in memo:\n        return [0, 0]\n    if memo[start][0]!= 0:\n        return memo[start]\n    memo[start][0] = 0\n    jumps, last = 0, start\n    while last <= len(memo):\n        last += memo[last][0]\n        jumps += 1\n    memo[start][0] = jumps\n    return [last, jumps]\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nmoves = []\nfor _ in range(m):\n    moves.append(list(map(int, input().split())))\n\nsolve(n, m, a, moves)\n```\n\nThis program uses a memoization table to store the results of subproblems. For each hole, it stores the number of jumps and the last hole visited. When a ball is thrown into a hole, it simulates the jumps and stores the result in the memoization table. This way, the simulation is only done once for each hole, and the results are reused for subsequent queries.\n\nNote: This program assumes that the input is well-formed and does not contain any errors. It also assumes that the input is not too large, as the memoization table grows quadratically with the number of holes."}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\nclass HolesGame:\n    def __init__(self, n, m, initial_powers):\n        self.n = n\n        self.m = m\n        self.initial_powers = initial_powers\n        self.powers = list(initial_powers)\n        self.jumps = [[] for _ in range(n)]\n\n    def set_power(self, a, b):\n        self.powers[a - 1] = b\n\n    def throw_ball(self, a):\n        position = a - 1\n        jumps = 0\n        while position < self.n - 1:\n            position = position + self.powers[position]\n            jumps += 1\n        self.jumps[position].append((a, jumps))\n\n    def solve(self):\n        for i in range(self.m):\n            action = list(map(int, input().split()))\n            if action[0] == 0:\n                self.set_power(action[1], action[2])\n            elif action[0] == 1:\n                self.throw_ball(action[1])\n\n\ndef main():\n    n, m = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n    game = HolesGame(n, m, initial_powers)\n    game.solve()\n    for i in range(m):\n        if game.jumps[i]:\n            for jump in game.jumps[i]:\n                print(f\"{jump[0]} {jump[1]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program defines a class `HolesGame` that encapsulates the game's logic. The `set_power` method sets the power of a hole, and the `throw_ball` method simulates the ball's jump from a given hole. The `solve` method reads the moves from input and performs the corresponding actions.\n\nIn the `main` function, we create an instance of `HolesGame` and call its `solve` method to play the game. After the game is finished, we print the results of each throw action."}, {"generated_text": "Here is a Python program to solve the problem.\n\n```python\nclass HolesGame:\n    def __init__(self, n, moves):\n        self.n = n\n        self.moves = moves\n        self.powers = [0] * n\n        self.jump_count = [0] * n\n        self.last_hole = [0] * n\n        self.cache = {}\n\n    def simulate_move(self, move_type, a, b=None):\n        if move_type == 0:\n            self.powers[a-1] = b\n            self.cache = {}\n        else:\n            if a-1 not in self.cache:\n                self.cache[a-1] = self._simulate_jump(a-1)\n            last_hole, jump_count = self.cache[a-1]\n            print(last_hole, jump_count)\n\n    def _simulate_jump(self, hole_index):\n        if hole_index >= self.n:\n            return hole_index, 0\n        jump_count = 0\n        current_hole = hole_index\n        while True:\n            current_hole += self.powers[current_hole]\n            if current_hole >= self.n:\n                return current_hole, jump_count + 1\n            jump_count += 1\n\ndef main():\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n    game = HolesGame(n, m)\n    for _ in range(m):\n        move_type, a, b = map(int, input().split())\n        if move_type == 0:\n            b -= 1\n        game.simulate_move(move_type, a, b)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a class `HolesGame` to encapsulate the state and behavior of the game. The `simulate_move` method is used to simulate a single move, and the `_simulate_jump` method is used to simulate a single jump. The cache is used to store the results of previously simulated jumps to avoid redundant computation. The `main` function reads the input and creates an instance of the `HolesGame` class to play the game."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\nclass HolesGame:\n    def __init__(self, n, moves):\n        self.n = n\n        self.moves = moves\n        self.hole_powers = [0] * (n + 1)\n        self.hole_jumps = [0] * (n + 1)\n        self.hole_numbers = list(range(1, n + 1))\n        self.prefix_sum = [[0] * (n + 1) for _ in range(n + 1)]\n\n    def precompute(self):\n        for i in range(1, self.n + 1):\n            self.prefix_sum[i][i] = 1\n            if self.hole_powers[i] > i:\n                self.hole_powers[i] = self.n + 1\n\n        for i in range(1, self.n + 1):\n            for j in range(i + 1, self.n + 1):\n                self.prefix_sum[i][j] = self.prefix_sum[i][j - 1] + self.prefix_sum[j][j]\n\n        for i in range(1, self.n + 1):\n            self.hole_jumps[i] = self.prefix_sum[1][i]\n\n    def set_hole_power(self, a, b):\n        self.hole_powers[a] = b\n        self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.n + 1)]\n        self.precompute()\n\n    def throw_ball(self, a):\n        hole_number = a\n        jumps = 0\n        while hole_number <= self.n:\n            jumps += 1\n            hole_number += self.hole_powers[hole_number]\n            if hole_number > self.n:\n                break\n        return hole_number, jumps\n\n\ndef main():\n    n, m = map(int, input().split())\n    hole_powers = list(map(int, input().split()))\n\n    game = HolesGame(n, m)\n    game.hole_powers = hole_powers\n    game.precompute()\n\n    for i in range(m):\n        move = list(map(int, input().split()))\n        if move[0] == 0:\n            game.set_hole_power(move[1], move[2])\n        else:\n            hole_number, jumps = game.throw_ball(move[1])\n            print(hole_number, jumps)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program defines a class `HolesGame` that encapsulates the game logic. It uses a prefix sum array to efficiently compute the number of jumps for each hole. The `precompute` method initializes the prefix sum array and the `set_hole_power` method updates the prefix sum array when a hole's power is changed. The `throw_ball` method simulates a ball throw and returns the number of the last hole visited and the number of jumps. The `main` function reads the input and creates an instance of `HolesGame`, which then simulates the game."}, {"generated_text": "Here's a Python program to solve the problem.\n\n```python\nfrom collections import deque\n\nclass HolesGame:\n    def __init__(self, n, m, initial_powers):\n        self.n = n\n        self.m = m\n        self.initial_powers = initial_powers\n        self.powers = initial_powers[:]\n        self.result = []\n\n        # Build the graph and calculate the maximum reachable index for each index\n        self.graph = [[] for _ in range(n + 1)]\n        self.max_reachable = [0] * (n + 1)\n        for i in range(n):\n            j = i + 1\n            while j <= n:\n                self.graph[i].append(j)\n                j += self.powers[i]\n                self.max_reachable[i] = max(self.max_reachable[i], j)\n\n        # Initialize the visited set and the queue\n        self.visited = [False] * (n + 1)\n        self.queue = deque([(1, 0)])  # (index, depth)\n\n    def simulate(self, a, b):\n        # Set the power of hole a to b\n        self.powers[a - 1] = b\n        self.graph = [[] for _ in range(self.n + 1)]\n        self.max_reachable = [0] * (self.n + 1)\n        for i in range(self.n):\n            j = i + 1\n            while j <= self.n:\n                self.graph[i].append(j)\n                j += self.powers[i]\n                self.max_reachable[i] = max(self.max_reachable[i], j)\n\n    def solve(self):\n        for _ in range(self.m):\n            query = input().split()\n            if query[0] == '0':\n                # Set the power of hole a to b\n                a, b = int(query[1]), int(query[2])\n                self.simulate(a, b)\n            else:\n                # Throw a ball into the hole a\n                a = int(query[1])\n                if self.visited[a - 1]:\n                    # If the ball has been visited before, return the previous result\n                    self.result.append((self.result[-1][1], self.result[-1][0]))\n                    continue\n                self.visited[a - 1] = True\n                queue = [(a, 0)]  # (index, depth)\n                while queue:\n                    index, depth = queue.popleft()\n                    if index > self.n:\n                        self.result.append((index, depth))\n                        break\n                    for next_index in self.graph[index - 1]:\n                        if not self.visited[next_index - 1]:\n                            queue.append((next_index, depth + 1))\n                self.visited[a - 1] = False\n\n\ndef main():\n    n, m = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n    game = HolesGame(n, m, initial_powers)\n    game.solve()\n    for result in game.result:\n        print(result[0], result[1])\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a breadth-first search (BFS) to simulate the ball's movement. It maintains a graph where each node represents a hole and the edges represent the ball's possible jumps. The `max_reachable` array keeps track of the maximum reachable index for each index. The `simulate` method updates the graph and `max_reachable` array when the power of a hole is changed. The `solve` method performs the BFS and stores the results in the `result` list. The `main` function reads the input and calls the `solve` method to get the final results."}, {"generated_text": "Here's a Python solution to the problem:\n\n```python\nclass Holes:\n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n        self.powers = [0] * (n + 1)\n        self.last_hole = [0] * (n + 1)\n        self.jumps = [0] * (n + 1)\n        self.cache = {}\n\n    def set_power(self, a, b):\n        self.powers[a] = b\n        self.cache = {}\n\n    def get_last_hole(self, a):\n        if a in self.cache:\n            return self.cache[a]\n\n        jumps = 0\n        last_hole = a\n        while last_hole <= self.n:\n            if last_hole + self.powers[last_hole] > self.n:\n                break\n            last_hole += self.powers[last_hole]\n            jumps += 1\n        self.cache[a] = last_hole\n        return last_hole, jumps\n\n    def solve(self):\n        for i in range(1, self.n + 1):\n            self.jumps[i] = self.get_jumps(i)\n\n        for _ in range(self.m):\n            query = list(map(int, input().split()))\n            if query[0] == 0:\n                self.set_power(query[1], query[2])\n            else:\n                last_hole, jumps = self.get_last_hole(query[1])\n                print(last_hole, jumps)\n\n    def get_jumps(self, a):\n        if a <= self.n:\n            return self.jumps[a]\n        if a in self.cache:\n            return self.cache[a]\n        jumps = 0\n        last_hole = a\n        while last_hole <= self.n:\n            if last_hole + self.powers[last_hole] > self.n:\n                break\n            last_hole += self.powers[last_hole]\n            jumps += 1\n        self.cache[a] = jumps\n        return jumps\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    holes = Holes(n, m)\n    powers = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        holes.powers[i] = powers[i - 1]\n    holes.solve()\n```\n\nIn this solution, we first initialize an instance of the `Holes` class with the given number of holes and moves. Then, we set the initial powers of the holes. We use a cache to store the results of expensive function calls to avoid redundant calculations.\n\nThe `set_power` method updates the power of a hole and clears the cache.\n\nThe `get_last_hole` method returns the last hole the ball visited before leaving the row and the number of jumps it made. We use the cache to store the results of this method.\n\nThe `solve` method reads the queries and processes each one. If the query is of type 0, we set the power of the hole. If it's of type 1, we print the last hole and the number of jumps.\n\nThe `get_jumps` method returns the number of jumps the ball made when thrown into a hole. We use the cache to store the results of this method.\n\nFinally, we create an instance of the `Holes` class and solve the problem."}, {"generated_text": "```python\nclass HolesGame:\n    def __init__(self, n, moves):\n        self.n = n\n        self.moves = moves\n        self.powers = list(map(int, input().split()))[:n]\n\n    def set_power(self, a, b):\n        self.powers[a-1] = b\n\n    def get_jumps(self, a):\n        visited = [False] * self.n\n        jumps = 0\n        current = a\n        while True:\n            visited[current-1] = True\n            current += self.powers[current-1] - 1\n            if current > self.n or visited[current-1]:\n                break\n            jumps += 1\n        return current, jumps\n\n    def play(self):\n        for i, move in enumerate(self.moves):\n            if move[0] == 0:\n                a, b = move[1], move[2]\n                self.set_power(a, b)\n            else:\n                a = move[1]\n                last_hole, jumps = self.get_jumps(a)\n                print(last_hole, jumps)\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    game = HolesGame(n, [list(map(int, input().split())) for _ in range(m)])\n    game.play()\n```\n\nThis program defines a class `HolesGame` to encapsulate the game logic. The `set_power` method sets the power of a hole, and the `get_jumps` method calculates the number of jumps and the last hole visited when a ball is thrown into a hole. The `play` method simulates the game and prints the results.\n\nIn the `main` block, the program reads the input, creates an instance of the `HolesGame` class, and calls the `play` method to simulate the game.\n\nNote that the input is assumed to be in the format specified in the problem statement. The program reads the number of holes and moves on the first line, the initial powers on the second line, and then each move on subsequent lines."}, {"generated_text": "```python\nclass HolesGame:\n    def __init__(self, n, m, initial_powers):\n        self.n = n\n        self.m = m\n        self.powers = [0] * (n + 1)  # powers[i] stores the power of the i-th hole\n        for i in range(1, n + 1):\n            self.powers[i] = initial_powers[i - 1]\n        self.result = []  # stores the result of each move\n\n    def set_power(self, a, b):\n        self.powers[a] = b\n\n    def get_jumps(self, a):\n        jumps = 0\n        position = a\n        while position <= self.n:\n            jumps += 1\n            position += self.powers[position]\n            if position > self.n:\n                self.result.append((position - self.powers[position], jumps))\n                return\n        self.result.append((self.n, jumps))\n\n    def play(self):\n        for _ in range(self.m):\n            query = list(map(int, input().split()))\n            if query[0] == 0:\n                self.set_power(query[1], query[2])\n            else:\n                self.get_jumps(query[1])\n\n        for i in range(len(self.result)):\n            print(*self.result[i])\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n    game = HolesGame(n, m, initial_powers)\n    game.play()\n```\n\nThis program uses a class `HolesGame` to encapsulate the game's state and behavior. The `play` method reads the queries from the input, updates the powers and results accordingly, and prints the final result.\n\nThe `set_power` method updates the power of a hole, and the `get_jumps` method simulates a throw into a hole, counting the number of jumps before the ball leaves the row.\n\nThe program uses a list `result` to store the result of each move, where each element is a tuple containing the number of the last hole visited and the number of jumps made.\n\nThe program handles queries of type 0 (set power) and type 1 (throw a ball), and prints the result for each throw."}, {"generated_text": "```python\nfrom collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n    dp = [[-1] * n for _ in range(n)]\n    visited = [[False] * n for _ in range(n)]\n    moves = []\n\n    def dfs(i, j, depth):\n        if visited[i][j]:\n            return (i, depth)\n        visited[i][j] = True\n        j += powers[j - 1]\n        if j >= n:\n            return (i, depth + 1)\n        if dp[i][j]!= -1:\n            return dp[i][j]\n        dp[i][j] = dfs(i, j, depth + 1)\n        return dp[i][j]\n\n    for _ in range(m):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            a, b = query[1] - 1, query[2]\n            powers[a - 1] = b\n            for i in range(n):\n                dp[i] = [-1] * n\n                visited[i] = [False] * n\n        else:\n            a = query[1] - 1\n            moves.append(dfs(a, a, 0))\n\n    for i in moves:\n        print(i[0] + 1, i[1])\n\nif __name__ == \"__main__\":\n    solve()\n```\n\nThis code defines a function `solve` that solves the problem. The function first reads the input and initializes the `dp` and `visited` matrices. It then enters a loop where it reads each query, performs the necessary action, and appends the result to the `moves` list. Finally, it prints the results.\n\nThe `dfs` function performs a depth-first search to calculate the number of jumps and the last hole visited before leaving the row. It uses a memoization technique to avoid redundant calculations.\n\nThe code assumes that the input is well-formed and does not contain any errors. It also assumes that the input is in the format specified in the problem statement."}, {"generated_text": "Here is a Python program that can solve the problem. The program uses a binary jump array to store the result of each jump, which can be used to calculate the next jump.\n\n```python\ndef calculate_jumps(n, m, holes, moves):\n    # Calculate the binary jump array\n    jumps = [[0] * n for _ in range(n)]\n    for i in range(n):\n        current = i + 1\n        for j in range(i + 1, n):\n            if current >= j:\n                break\n            current += holes[i]\n            jumps[i][j] = current\n\n    # Process each move\n    results = []\n    for move in moves:\n        if move[0] == 0:\n            # Set the power of a hole\n            a, b = move[1], move[2]\n            holes[a - 1] = b\n        else:\n            # Throw a ball into a hole\n            a = move[1] - 1\n            current = a + 1\n            jumps_count = 0\n            while current < n:\n                jumps_count += 1\n                current = jumps[a][current - 1] + 1\n            results.append((current - 1, jumps_count))\n\n    return results\n\n\ndef main():\n    # Read the input\n    n, m = map(int, input().split())\n    holes = list(map(int, input().split()))\n\n    moves = []\n    for _ in range(m):\n        move = list(map(int, input().split()))\n        moves.append(move)\n\n    # Calculate the result\n    results = calculate_jumps(n, m, holes, moves)\n\n    # Print the result\n    for result in results:\n        print(result[0], result[1])\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first calculates the binary jump array, which can be used to calculate the next jump. Then it processes each move, and for each move of type 1, it calculates the number of jumps and the last hole visited before leaving the row. Finally, it prints the result.\n\nYou can run this program with the input you provided, and it should output the correct result."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\nclass Holes:\n    def __init__(self, n, moves):\n        self.n = n\n        self.moves = moves\n        self.holes = list(range(1, n + 1))\n        self.powers = list(range(1, n + 1))\n        self.jumps = [[0] * n for _ in range(n)]\n\n    def set_power(self, a, b):\n        self.powers[a - 1] = b\n        self.jumps = [[0] * self.n for _ in range(self.n)]\n\n    def throw_ball(self, a):\n        visited = [False] * self.n\n        count = 0\n        i = a - 1\n        while True:\n            if i + self.powers[i] > self.n:\n                return i + 1, count\n            if visited[i + self.powers[i]]:\n                return i + self.powers[i], count\n            visited[i + self.powers[i]] = True\n            i = i + self.powers[i]\n            count += 1\n\n    def calculate_jumps(self):\n        for i in range(self.n):\n            for j in range(self.n):\n                self.jumps[i][j] = self.throw_ball(j + 1)[1]\n\ndef main():\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n    holes = Holes(n, m)\n    holes.holes = powers\n\n    for _ in range(m):\n        move = list(map(int, input().split()))\n        if move[0] == 0:\n            holes.set_power(move[1], move[2])\n        elif move[0] == 1:\n            last_hole, count = holes.throw_ball(move[1])\n            print(last_hole, count)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first initializes the `Holes` class, which has methods to set the power of a hole, throw a ball, and calculate the jumps. The `main` function reads the input, creates an instance of the `Holes` class, and performs the moves. For each move of type 1, it prints the last hole and the number of jumps.\n\nThe time complexity of this program is O(M*N^2), where M is the number of moves and N is the number of holes. This is because the `throw_ball` method needs to iterate over all holes to calculate the jumps."}, {"generated_text": "Here's a Python solution for the given problem:\n\n```python\nfrom collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n    max_power = n\n\n    # Create a dictionary to store the last hole visited and the number of jumps for each hole\n    hole_info = defaultdict(lambda: [0, 0])\n\n    for _ in range(m):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            # Update the power of the hole\n            hole_index = query[1] - 1\n            powers[hole_index] = query[2]\n        else:\n            # Throw the ball into the hole\n            hole_index = query[1] - 1\n            last_hole = hole_index\n            jumps = 0\n            current_index = hole_index\n\n            while current_index < max_power:\n                # Calculate the next hole index\n                next_index = current_index + powers[current_index]\n                if next_index >= max_power:\n                    break\n                current_index = next_index\n                last_hole = current_index\n                jumps += 1\n\n            # Store the last hole visited and the number of jumps in the dictionary\n            hole_info[hole_index] = [last_hole + 1, jumps + 1]\n            print(last_hole + 1, jumps + 1)\n\nsolve()\n```\n\nThis solution uses a dictionary `hole_info` to store the last hole visited and the number of jumps for each hole. It iterates over each query, and for each query of type 1, it calculates the last hole visited and the number of jumps by simulating the ball's movement. The result is stored in the dictionary and printed to the console."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nclass HoleGame:\n    def __init__(self, n, m, initial_powers):\n        self.n = n\n        self.m = m\n        self.initial_powers = [0] + initial_powers\n        self.powers = [0] * (n + 1)\n        self.max_reach = [0] * (n + 1)\n        self.max_reach[1] = 1\n        for i in range(1, n + 1):\n            self.max_reach[i + self.initial_powers[i]] = i + 1\n\n        for i in range(2, n + 1):\n            self.max_reach[i] = max(self.max_reach[i], self.max_reach[i - 1])\n\n        self.history = [[0, 0] for _ in range(m + 1)]\n\n    def update_max_reach(self, i, new_power):\n        self.max_reach[i] = max(self.max_reach[i], self.max_reach[i - 1])\n        for j in range(self.max_reach[i], n + 1, i):\n            self.max_reach[j] = j + new_power\n\n    def jump(self, i):\n        jumps = 0\n        position = i\n        while position <= self.n:\n            position += self.powers[position]\n            jumps += 1\n        self.history[i][0] = position\n        self.history[i][1] = jumps\n\n    def solve(self):\n        for i in range(1, self.n + 1):\n            self.powers[i] = self.initial_powers[i]\n\n        for i in range(1, self.m + 1):\n            action, hole, new_power = map(int, input().split())\n            if action == 0:\n                self.powers[hole] = new_power\n                self.update_max_reach(hole, new_power)\n            else:\n                self.jump(hole)\n\n        for i in range(1, self.m + 1):\n            print(self.history[i][0], self.history[i][1])\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n    game = HoleGame(n, m, initial_powers)\n    game.solve()\n```\n\nThis program uses a `HoleGame` class to encapsulate the game state and behavior. The `solve` method reads the input, updates the game state, and prints the results.\n\nThe `update_max_reach` method updates the `max_reach` array after changing the power of a hole.\n\nThe `jump` method simulates a jump from a given hole and updates the `history` array.\n\nThe `solve` method iterates over the moves, updates the game state, and prints the results."}, {"generated_text": "Here is the Python program that solves the problem:\n\n```python\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n\n    # Create a graph where each vertex represents a hole\n    graph = defaultdict(list)\n    for i in range(N):\n        graph[i + 1].append(i + 1 + initial_powers[i])\n\n    # Initialize a matrix to store the number of jumps for each hole\n    jumps_matrix = [[-1] * (N + 1) for _ in range(N + 1)]\n\n    # Initialize a matrix to store the last hole visited before leaving the row\n    last_hole_matrix = [[-1] * (N + 1) for _ in range(N + 1)]\n\n    # Compute the number of jumps and the last hole visited for each hole\n    for i in range(1, N + 1):\n        visited = set()\n        j = i\n        while j <= N:\n            visited.add(j)\n            next_hole = j + initial_powers[j - 1]\n            if next_hole > N:\n                break\n            jumps_matrix[i][j] = jumps_matrix[i][j - 1] + 1\n            last_hole_matrix[i][j] = next_hole\n            j = next_hole\n\n    # Process each move\n    for _ in range(M):\n        query_type, hole, value = map(int, input().split())\n        if query_type == 0:\n            # Update the power of the hole\n            graph[hole].clear()\n            for next_hole in graph[hole + value - 1]:\n                graph[hole].append(next_hole)\n        else:\n            # Throw a ball into the hole and compute the number of jumps and the last hole visited\n            j = hole\n            jumps = 0\n            while j <= N:\n                next_hole = last_hole_matrix[j][j]\n                if next_hole == -1:\n                    break\n                jumps += 1\n                j = next_hole\n            print(last_hole_matrix[hole][hole], jumps)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first creates a graph where each vertex represents a hole. It then initializes two matrices to store the number of jumps and the last hole visited for each hole. It computes these values by simulating the ball's movement for each hole. Finally, it processes each move and updates the graph and the matrices accordingly."}, {"generated_text": "```python\nclass Holes:\n    def __init__(self, n, m, powers):\n        self.n = n\n        self.m = m\n        self.powers = [0] + powers + [0]  # add dummy values to simplify indexing\n        self.max_reach = [0] * (n + 2)  # max reachable index for each hole\n        self.reachable = [[False] * (n + 2) for _ in range(n + 2)]  # reachable indices for each hole\n\n        self.build_reach()\n\n    def build_reach(self):\n        for i in range(1, self.n + 1):\n            self.max_reach[i] = i + self.powers[i]\n            self.reachable[i][i + self.powers[i]] = True\n\n        for j in range(self.n, 0, -1):\n            for i in range(1, self.n + 1):\n                if i + self.powers[i] <= self.n:\n                    self.max_reach[j] = max(self.max_reach[j], self.max_reach[i + self.powers[i]])\n                if self.reachable[j][i + self.powers[i]]:\n                    self.reachable[j][i] = True\n\n    def simulate(self, move):\n        if move[0] == 0:\n            self.powers[move[1]] = move[2]\n            self.build_reach()\n        else:\n            current = move[1]\n            jumps = 0\n            while current <= self.n and current <= self.max_reach[current]:\n                jumps += 1\n                current += self.powers[current]\n            print(current, jumps)\n\n\ndef main():\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n\n    holes = Holes(n, m, powers)\n\n    for _ in range(m):\n        move = list(map(int, input().split()))\n        holes.simulate(move)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program defines a class `Holes` that simulates the game. It maintains a `max_reach` array to keep track of the maximum reachable index for each hole and a `reachable` 2D array to keep track of the reachable indices for each hole. The `build_reach` method is used to precompute these values. The `simulate` method is used to simulate each move and print the result. The `main` function reads the input and creates an instance of the `Holes` class to simulate the game."}, {"generated_text": "To solve this problem, we can use a combination of a prefix sum array and a jump table. The prefix sum array will help us calculate the total power of holes up to a certain index, and the jump table will help us determine the number of jumps the ball makes when thrown into a hole.\n\nHere is a Python program that implements this solution:\n\n```python\nclass HolesGame:\n    def __init__(self, n, moves):\n        self.n = n\n        self.m = moves\n        self.power = [0] * (n + 1)\n        self.jump_table = [[0, 0] for _ in range(n + 1)]\n\n        self.read_power()\n        self.build_jump_table()\n\n    def read_power(self):\n        power_values = list(map(int, input().split()))\n        for i in range(1, self.n + 1):\n            self.power[i] = power_values[i - 1]\n\n    def build_jump_table(self):\n        for i in range(1, self.n + 1):\n            total_power = 0\n            for j in range(i, self.n + 1):\n                total_power += self.power[j]\n                self.jump_table[j][0] = i - 1\n                if j + total_power > self.n:\n                    self.jump_table[j][1] = j - i\n                else:\n                    self.jump_table[j][1] = self.jump_table[j + total_power][1] + 1\n\n    def play(self):\n        for _ in range(self.m):\n            move = list(map(int, input().split()))\n            if move[0] == 0:\n                self.power[move[1]] = move[2]\n                self.jump_table[move[1]] = [0, 0]\n                for i in range(move[1], self.n + 1):\n                    total_power = 0\n                    for j in range(i, self.n + 1):\n                        total_power += self.power[j]\n                        self.jump_table[j][0] = i - 1\n                        if j + total_power > self.n:\n                            self.jump_table[j][1] = j - i\n                        else:\n                            self.jump_table[j][1] = self.jump_table[j + total_power][1] + 1\n            elif move[0] == 1:\n                start = move[1]\n                end = self.jump_table[start][0]\n                jumps = self.jump_table[start][1]\n                print(end, jumps)\n\ngame = HolesGame(*map(int, input().split()))\ngame.play()\n```\n\nThis program first reads the number of holes and the number of moves. Then it reads the initial power values of the holes. It builds the jump table by iterating over each hole and calculating the total power up to that hole. When a move is made, it either updates the power value of a hole and rebuilds the jump table for that hole and all subsequent holes, or it throws a ball into a hole and prints the number of the last hole visited and the number of jumps made."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\nclass HolesGame:\n    def __init__(self, n, m, powers):\n        self.n = n\n        self.m = m\n        self.powers = powers\n        self.jump_count = [0] * n\n        self.last_hole = [0] * n\n\n    def set_power(self, hole, power):\n        self.powers[hole] = power\n        self.jump_count[hole] = 0\n        self.last_hole[hole] = 0\n\n    def calculate_jumps(self, hole):\n        total_jumps = 0\n        current_hole = hole\n        while current_hole < self.n:\n            self.jump_count[hole] += 1\n            current_hole += self.powers[current_hole]\n            self.last_hole[hole] = current_hole\n            if current_hole >= self.n:\n                break\n        return self.jump_count[hole]\n\n    def play(self):\n        for _ in range(self.m):\n            action, hole, *args = map(int, input().split())\n            if action == 0:\n                power = args[0]\n                self.set_power(hole - 1, power)\n            else:\n                jumps = self.calculate_jumps(hole - 1)\n                print(self.last_hole[hole - 1], jumps)\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n    game = HolesGame(n, m, powers)\n    game.play()\n```\n\nThis program defines a class `HolesGame` that encapsulates the game state and behavior. The `set_power` method updates the power of a hole, the `calculate_jumps` method calculates the number of jumps and the last hole visited before leaving the row for a given hole, and the `play` method simulates the game by iterating over the moves. The program then creates an instance of the `HolesGame` class and calls its `play` method to simulate the game."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\nclass Holes:\n    def __init__(self, n, m, initial_powers):\n        self.n = n\n        self.m = m\n        self.powers = initial_powers\n        self.cache = [[-1] * (n + 1) for _ in range(n + 1)]\n        self.result = []\n\n    def get_jumps(self, i, k):\n        if self.cache[i][k]!= -1:\n            return self.cache[i][k]\n\n        max_power = min(k + self.powers[i - 1], self.n)\n        jumps = 0\n        while i <= max_power:\n            if self.cache[i][k]!= -1:\n                return self.cache[i][k]\n\n            max_power = min(k + self.powers[i - 1], self.n)\n            new_jumps = 0\n            j = i\n            while j <= max_power:\n                new_jumps += 1\n                j += self.powers[j - 1]\n\n            self.cache[i][k] = (j, new_jumps)\n            jumps = new_jumps\n            i = j\n\n        return self.cache[i][k]\n\n    def solve(self):\n        for i in range(1, self.n + 1):\n            self.get_jumps(i, i)\n\n        for _ in range(self.m):\n            query = list(map(int, input().split()))\n\n            if query[0] == 0:\n                self.powers[query[1] - 1] = query[2]\n                self.cache = [[-1] * (self.n + 1) for _ in range(self.n + 1)]\n                self.solve()\n            elif query[0] == 1:\n                jumps = self.get_jumps(query[1], query[1])[1]\n                last_hole = self.get_jumps(query[1], query[1])[0]\n                self.result.append((last_hole, jumps))\n\n        for item in self.result:\n            print(item[0], item[1])\n\n\ndef main():\n    n, m = map(int, input().split())\n    initial_powers = list(map(int, input().split()))\n    holes = Holes(n, m, initial_powers)\n    holes.solve()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a `Holes` class to keep track of the number of holes, the number of moves, and the initial powers of the holes. It also uses a 2D `cache` to store the results of previously computed jumps.\n\nThe `get_jumps` method computes the number of jumps and the last hole visited for a given initial hole and jump count. It uses a depth-first search approach to compute the jumps.\n\nThe `solve` method reads the queries from the input, processes them, and appends the results to the `result` list. If a query is of type 0, it updates the power of the corresponding hole and resets the `cache`. If a query is of type 1, it uses the `get_jumps` method to compute the number of jumps and the last hole visited.\n\nThe `main` function reads the input, creates a `Holes` object, and calls its `solve` method to process the queries."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nfrom collections import deque\n\ndef calculate_jumps(holes, move):\n    n = len(holes)\n    visited = [False] * n\n    jumps = 0\n    last_hole = -1\n\n    queue = deque([(0, 0)])  # (hole, jumps)\n    while queue:\n        hole, current_jumps = queue.popleft()\n        jumps = max(jumps, current_jumps)\n        last_hole = hole\n\n        if hole + holes[hole] >= n:\n            break\n\n        if not visited[hole + holes[hole]]:\n            visited[hole + holes[hole]] = True\n            queue.append((hole + holes[hole], current_jumps + 1))\n\n    return last_hole, jumps\n\ndef solve():\n    n, m = map(int, input().split())\n    holes = list(map(int, input().split()))\n\n    for _ in range(m):\n        move = list(map(int, input().split()))\n        if move[0] == 0:\n            holes[move[1] - 1] = move[2]\n        else:\n            last_hole, jumps = calculate_jumps(holes, move[1] - 1)\n            print(last_hole + 1, jumps)\n\nsolve()\n```\n\nThis program uses a queue to keep track of the holes that the ball has visited. It starts by visiting the first hole, and then it continues to visit the holes that the ball can jump to. It keeps track of the number of jumps and the last hole that the ball visited.\n\nFor each move of type 1, it calls the `calculate_jumps` function to calculate the number of jumps and the last hole that the ball visited, and then it prints the result.\n\nFor each move of type 0, it simply updates the power of the corresponding hole.\n\nThe `calculate_jumps` function returns the last hole that the ball visited and the number of jumps it made. It uses a queue to keep track of the holes that the ball has visited, and it keeps track of the number of jumps and the last hole that the ball visited.\n\nThis program assumes that the input is valid and that the holes are numbered from 1 to n. It also assumes that the power of each hole is a positive integer not exceeding n."}, {"generated_text": "To solve this problem, we can use a combination of data structures like arrays and dictionaries to efficiently keep track of the holes and their powers.\n\nHere's a Python program that implements the solution:\n\n```python\nimport math\n\ndef max_jumps(holes, a, m):\n    # Calculate the maximum jump\n    max_jump = a + a * (len(holes) - 1)\n    \n    # Initialize the visited array\n    visited = [False] * len(holes)\n    \n    # Initialize the last visited array\n    last_visited = [0] * len(holes)\n    \n    # Perform DFS to find the maximum jump\n    stack = [0]\n    visited[0] = True\n    last_visited[0] = 0\n    while stack:\n        index = stack.pop()\n        if index + a < len(holes) and not visited[index + a]:\n            visited[index + a] = True\n            last_visited[index + a] = index\n            stack.append(index + a)\n        if index + a * (index + 1) >= len(holes):\n            break\n    \n    # Return the maximum jump and the last visited hole\n    max_jump = index + 1\n    return max_jump, last_visited[max_jump]\n\ndef main():\n    # Read the input\n    n, m = map(int, input().split())\n    holes = list(map(int, input().split()))\n    powers = dict(zip(range(1, n + 1), holes))\n    \n    # Process the moves\n    for _ in range(m):\n        move = list(map(int, input().split()))\n        if move[0] == 0:\n            # Set the power of the hole\n            powers[move[1]] = move[2]\n        else:\n            # Throw the ball into the hole\n            a = move[1]\n            jumps, last_hole = max_jumps(holes, powers[a], m)\n            print(last_hole, jumps - 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first reads the input, then it processes each move. If the move is of type 0, it sets the power of the hole. If the move is of type 1, it calculates the maximum jump and the last visited hole using a depth-first search (DFS) algorithm.\n\nNote that the DFS algorithm uses a stack to keep track of the visited holes and the last visited hole. The algorithm starts from the first hole and explores its neighbors, keeping track of the last visited hole. When it reaches a hole that has already been visited, it stops exploring that branch.\n\nThe maximum jump and the last visited hole are returned as a tuple. The last visited hole is the index of the hole from which the ball jumped out just before leaving the row.\n\nThe program prints the maximum jump and the last visited hole for each move of type 1.\n\nThis solution has a time complexity of O(m \\* n), where m is the number of moves and n is the number of holes. The space complexity is O(n), as we need to keep track of the visited holes and the last visited hole."}]}