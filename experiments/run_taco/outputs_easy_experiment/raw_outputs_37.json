{"id": 37, "input": "There are n cities and n-1 two-way roads in Treeland. Each road connects a pair of different cities. From any city you can drive to any other, moving only along the roads. Cities are numbered from 1 to n. Yes, of course, you recognized an undirected tree in this description.\n\nThe government plans to repair all the roads. Each road will be repaired by some private company. In total, the country has 10^6 private companies that are numbered from 1 to 10^6. It is possible that some companies will not repair roads at all, and some will repair many roads.\n\nTo simplify the control over the work of private companies, the following restriction was introduced: for each city, we calculate the number of different companies that repair roads that have this city at one end. This number for each city should not exceed 2. In other words, for each city, there should be no more than two different companies that repair roads related to this city.\n\nThe National Anti-Corruption Committee of Treeland raises concerns that all (or almost all) of the work will go to one private company. For this reason, the committee requires that roads be distributed among companies in such a way as to minimize the value of r. For each company, we calculate the number of roads assigned to it, the maximum among all companies is called the number r.\n\nHelp the government find such a way to distribute all roads among companies in the required way.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of input cases in the input. Next, the input cases themselves are given. The first line of each test case set contains an integer n (2 \u2264 n \u2264 3000) \u2014 the number of cities in Treeland. Next, in the n-1 lines the roads are written: a line contains two integers x_i, y_i (1 \u2264 x_i, y_i \u2264 n), indicating that the i-th road connects the cities x_i and y_i.\n\nIt is guaranteed that the sum of all values n \u200b\u200bfor all test cases in the input does not exceed 3000.\n\nOutput\n\nPrint the answers for all t test cases in the input. Each test case must begin with a line that contains r \u2014 the minimum possible number of roads assigned to the most used company. Next, in the next line print n-1 the number c_1, c_2, ..., c_{n-1} (1 \u2264 c_i \u2264 10^6), where c_i indicates the company to repair the i-th road. If there are several optimal assignments, print any of them.\n\nExample\n\nInput\n\n\n3\n3\n1 2\n2 3\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n7\n3 1\n1 4\n4 6\n5 1\n2 4\n1 7\n\n\nOutput\n\n\n1\n10 20\n3\n1 1 1 2 2 \n2\n11 11 12 13 12 13\n", "difficulty": "VERY_HARD", "generations": [{"generated_text": "To solve this problem, we can use a graph algorithm and a graph traversal technique (depth-first search). We will use a dictionary to represent the graph, where each key is a city and its value is a list of its neighboring cities.\n\nHere's the Python code for the problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(graph, city, parent, company, visited, used_company):\n    visited[city] = True\n    used_company[city] = company\n    for neighbor in graph[city]:\n        if neighbor!= parent:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, city, company, visited, used_company)\n            elif used_company[neighbor] == company:\n                new_company = len(used_company) + 1\n                for i in graph[neighbor]:\n                    if i!= parent and i!= city and used_company[i] == company:\n                        used_company[i] = new_company\n                company = new_company\n                used_company[neighbor] = new_company\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = defaultdict(list)\n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n        visited = [False] * (n + 1)\n        used_company = [0] * (n + 1)\n        company = 1\n        for i in range(1, n + 1):\n            if not visited[i]:\n                dfs(graph, i, -1, company, visited, used_company)\n                company += 1\n        max_company = max(used_company[1:])\n        print(max_company)\n        for i in range(1, n):\n            print(used_company[i], end=' ')\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code first reads the number of test cases, then for each test case, it reads the number of cities and the edges between them. It uses a dictionary to represent the graph, where each key is a city and its value is a list of its neighboring cities.\n\nThe `dfs` function performs a depth-first search on the graph, assigning companies to each city. If a city is already visited and assigned to the same company, it creates a new company and assigns the city to it.\n\nAfter the depth-first search, it finds the maximum company used and prints it. Then it prints the companies assigned to each road.\n\nNote: This code assumes that the input is well-formed and does not contain any errors. It also assumes that the graph is connected. If the graph is not connected, the code will assign a company to each connected component separately."}, {"generated_text": "Here's a Python program that uses a graph and a depth-first search to solve this problem. This program will first perform a depth-first search to calculate the number of different companies that repair roads related to each city. Then, it will assign roads to companies in a way that minimizes the maximum number of roads assigned to any company.\n\n```python\nfrom collections import defaultdict\n\ndef dfs(graph, visited, company, city):\n    visited[city] = True\n    company[city] = company[city] + 1\n    for neighbor in graph[city]:\n        if not visited[neighbor]:\n            dfs(graph, visited, company, neighbor)\n\ndef distribute_roads(graph, n):\n    visited = [False] * (n + 1)\n    company = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, visited, company, i)\n\n    roads = []\n    for i in range(1, n):\n        min_company = min(company[graph[i][0]], company[graph[i][1]])\n        if min_company == 1:\n            if company[graph[i][0]] > 1:\n                roads.append((graph[i][0], 1))\n            else:\n                roads.append((graph[i][1], 1))\n        else:\n            if company[graph[i][0]] > company[graph[i][1]]:\n                roads.append((graph[i][1], min_company))\n            else:\n                roads.append((graph[i][0], min_company))\n\n    for i in range(1, n):\n        if roads[i-1][0] == graph[i][0]:\n            roads[i-1] = (graph[i][0], roads[i-1][1])\n        else:\n            roads[i-1] = (graph[i][1], roads[i-1][1])\n\n    return roads\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = defaultdict(list)\n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n\n        distribute_roads(graph, n)\n\n        roads = distribute_roads(graph, n)\n        r = max(roads, key=lambda x: x[1])[1]\n        print(r)\n        print(*[x[1] for x in roads])\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first performing a depth-first search to calculate the number of different companies that repair roads related to each city. It then assigns roads to companies in a way that minimizes the maximum number of roads assigned to any company.\n\nIn the output, the first line is the minimum possible number of roads assigned to the most used company. The next line contains the number of the company that will repair each road.\n\nNote: This program assumes that the input is well-formed and does not contain any errors. It may not work correctly for invalid input."}, {"generated_text": "To solve this problem, we will use a combination of depth-first search (DFS) and graph theory. The idea is to first build the graph of cities and roads, then perform a DFS traversal to identify the subtrees. Each subtree will be assigned to a company, and we will make sure that each company is assigned at most two roads from each subtree.\n\nHere is a Python solution for the problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(graph, node, parent, visited, company, comp):\n    visited[node] = True\n    comp[node] = company\n    for neighbor in graph[node]:\n        if neighbor!= parent and not visited[neighbor]:\n            dfs(graph, neighbor, node, visited, company, comp)\n\ndef distribute_roads(graph, n):\n    # Initialize the visited array and the company assignment array\n    visited = [False] * (n + 1)\n    comp = [0] * (n + 1)\n\n    # Perform DFS traversal to identify the subtrees\n    for i in range(1, n + 1):\n        if not visited[i]:\n            company = 1\n            dfs(graph, i, -1, visited, company, comp)\n            company += 1\n\n    # Count the number of roads for each company\n    company_counts = defaultdict(int)\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if comp[i]!= comp[j]:\n                company_counts[comp[i]] += 1\n                company_counts[comp[j]] += 1\n\n    # Find the maximum number of roads for any company\n    r = max(company_counts.values())\n\n    # Assign roads to companies to minimize the value of r\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if comp[i] == comp[j]:\n                if company_counts[comp[i]] > r:\n                    comp[i] = comp[j] = comp[i] ^ comp[j]\n\n    return r, comp[1:-1]\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = defaultdict(list)\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            graph[u].append(v)\n            graph[v].append(u)\n\n        r, roads = distribute_roads(graph, n)\n        print(r)\n        print(' '.join(map(str, roads)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution first builds the graph of cities and roads, then performs a DFS traversal to identify the subtrees. Each subtree is assigned to a company, and we make sure that each company is assigned at most two roads from each subtree. Finally, we count the number of roads for each company and assign roads to companies to minimize the value of r.\n\nNote that this solution assumes that the input graph is a tree, and the roads are numbered from 1 to n-1. The solution also assumes that the companies are numbered from 1 to 10^6. The output is the value of r and the company assignments for each road."}, {"generated_text": "To solve this problem, we can use a graph traversal algorithm to assign the roads to the companies. We'll use a Breadth-First Search (BFS) to traverse the tree and assign the roads to the companies.\n\nHere's the Python code to solve the problem:\n\n```python\nfrom collections import deque\n\ndef solve(n, roads):\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(n)]\n    for u, v in roads:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    # Initialize the result list\n    result = [0] * (n - 1)\n\n    # Perform BFS to assign roads to companies\n    company = 1\n    queue = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    result[neighbor] = company\n                    queue.append(neighbor)\n        company += 1\n\n    # Count the number of companies for each node\n    count = [0] * n\n    for i in range(n - 1):\n        count[result[i]] += 1\n        count[result[i + 1]] += 1\n\n    # Find the maximum count\n    max_count = max(count)\n\n    # Find the minimum number of roads assigned to the most used company\n    r = (max_count + 1) // 2\n\n    # Print the result\n    print(r)\n    print(*[result[i] if i < n - 1 else result[i - 1] for i in range(n - 1)])\n\n# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of nodes\n    n = int(input())\n\n    # Read the roads\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n\n    # Solve the problem\n    solve(n, roads)\n```\n\nThis code first reads the number of test cases and then for each test case, it reads the number of nodes and the roads. It creates an adjacency list to represent the graph, performs BFS to assign roads to companies, counts the number of companies for each node, finds the maximum count, and finally prints the result.\n\nThis code has a time complexity of O(n * m), where n is the number of nodes and m is the number of roads, and a space complexity of O(n + m)."}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\nfrom collections import deque\n\ndef dfs(u, p, adj, comp):\n    comp[u] = 1\n    for v in adj[u]:\n        if v!= p:\n            dfs(v, u, adj, comp)\n\ndef distribute_roads(n, adj):\n    # Initialize companies and roads for each company\n    comp = [-1 for _ in range(n + 1)]\n    roads = [0 for _ in range(n + 1)]\n    companies = [[] for _ in range(n + 1)]\n\n    # Do DFS to find connected components\n    for i in range(1, n + 1):\n        if comp[i] == -1:\n            dfs(i, -1, adj, comp)\n\n    # Initialize the queue with all components\n    queue = deque([(i, i, 1) for i in range(1, n + 1) if comp[i] == 1])\n\n    # Distribute roads among companies\n    while queue:\n        u, p, flag = queue.popleft()\n        for v in adj[u]:\n            if v!= p:\n                if flag:\n                    companies[u].append((v, 1))\n                    roads[v] += 1\n                else:\n                    companies[v].append((u, 1))\n                    roads[u] += 1\n                queue.append((v, u, not flag))\n\n    # Find the maximum number of roads for any company\n    max_roads = max(roads[1:])\n\n    # Print the result\n    print(max_roads)\n    for i in range(1, n):\n        for j, c in companies[i]:\n            print(c, end=' ')\n        print()\n\n# Read the number of test cases\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    distribute_roads(n, adj)\n```\n\nThis program uses a depth-first search (DFS) to find the connected components in the graph. It then uses a queue to distribute the roads among companies in a way that minimizes the maximum number of roads for any company. The result is printed out at the end.\n\nNote that this program assumes that the input is well-formed and that the graph is a tree (i.e., it has no cycles). If the input may be malformed, you should add error checking code to handle this."}, {"generated_text": "To solve this problem, we can use a graph traversal approach with DFS (Depth-First Search). We'll first create an adjacency list representation of the graph, and then use DFS to assign companies to each road.\n\nHere is the Python code to solve the problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, companies):\n    company = 1\n    count = 0\n    for neighbor in graph[node]:\n        if neighbor!= parent:\n            if companies[neighbor]:\n                count += 1\n            else:\n                count += dfs(neighbor, node, graph, companies)\n                companies[neighbor] = company\n            company += 1\n    return count\n\ndef solve(graph, n):\n    companies = defaultdict(int)\n    count = 0\n    for i in range(1, n):\n        if not companies[i]:\n            count += dfs(i, -1, graph, companies)\n            companies[i] = (count + 1) // 2\n    return count, companies\n\ndef print_answer(companies):\n    answer = []\n    for i in range(1, len(companies)):\n        if companies[i] == companies[i-1]:\n            answer.append(companies[i-1])\n        else:\n            answer.append(companies[i])\n    return answer\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        graph = defaultdict(list)\n        for _ in range(n-1):\n            u, v = map(int, input().split())\n            graph[u].append(v)\n            graph[v].append(u)\n        count, companies = solve(graph, n)\n        print(count)\n        answer = print_answer(companies)\n        print(*answer)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIn this code, we first create an adjacency list representation of the graph using a defaultdict. We then use DFS to assign companies to each road, making sure that each city has at most two different companies that repair roads related to it. Finally, we print the minimum possible number of roads assigned to the most used company, and the companies assigned to each road."}, {"generated_text": "Here is the Python program to solve the problem:\n\n```python\nfrom collections import defaultdict\nimport sys\n\ndef dfs(node, parent, adj, comp, comp_id):\n    comp[node] = comp_id\n    for neighbor in adj[node]:\n        if neighbor!= parent:\n            dfs(neighbor, node, adj, comp, comp_id)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n\n        comp = [-1] * n\n        for i in range(n):\n            if comp[i] == -1:\n                comp_id = len(comp) + 1\n                dfs(i, -1, adj, comp, comp_id)\n\n        roads = [[] for _ in range(len(comp))]\n        for i in range(n - 1):\n            u, v = map(int, input().split())\n            u -= 1\n            v -= 1\n            if comp[u]!= comp[v]:\n                roads[comp[u] - 1].append((u, v))\n                roads[comp[v] - 1].append((u, v))\n\n        r = 0\n        for i in range(len(comp) - 1):\n            roads[i].sort(key=lambda x: (len(x), x[0]))\n            for j in range(len(roads[i]) - 1):\n                if len(roads[i][j]) + 1 == len(roads[i][j + 1]):\n                    roads[i][j + 1].append(roads[i][j][1])\n                    roads[i].pop(j)\n                    j -= 1\n\n        for i in range(len(roads)):\n            r = max(r, len(roads[i]) // 2)\n\n        print(r)\n        for i in range(len(roads) - 1):\n            for j in range(len(roads[i]) // 2):\n                print(comp[roads[i][j][0]] + (comp[roads[i][j][1]] if roads[i][j][0] < roads[i][j][1] else 0), end=' ')\n        print()\n\nsolve()\n```\n\nThis program uses DFS to find the connected components in the graph. It then distributes the roads among the companies by trying to distribute the roads in each component as evenly as possible. If a company already has a road, it tries to add another road to it, but if it can't, it starts a new company. The program then prints the number of roads assigned to the most used company and the companies assigned to each road."}, {"generated_text": "To solve this problem, we can use a depth-first search (DFS) approach. The main idea is to calculate the number of roads each company can repair without exceeding the limit of 2 for each city.\n\nHere's the Python code to solve the problem:\n\n```python\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent, tree, company, count):\n    for neighbor in tree[node]:\n        if neighbor!= parent:\n            dfs(neighbor, node, tree, company, count)\n            count[neighbor] += count[node]\n    company[node] = (len(tree[node]), 1)\n\ndef distribute_roads(tree, n):\n    company = defaultdict(int)\n    count = [0] * n\n\n    for i in range(n):\n        dfs(i, -1, tree, company, count)\n\n    for i in range(n):\n        if len(tree[i]) == 1:\n            company[i] = (1, 1)\n\n    for i in range(n):\n        if len(tree[i]) > 1:\n            for neighbor in tree[i]:\n                if neighbor!= company[i][1] and count[neighbor] <= n // 2:\n                    company[i] = (company[i][0] + 1, neighbor)\n\n    company = {i: (c, 1) for i, (c, _) in company.items()}\n\n    return company\n\ndef solve(n, roads):\n    tree = [[] for _ in range(n)]\n    for u, v in roads:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n\n    company = distribute_roads(tree, n)\n\n    r = 0\n    for c in company.values():\n        r = max(r, c[0])\n\n    return r, [company[i][1] for i in range(n-1)]\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    roads = [list(map(int, input().split())) for _ in range(n-1)]\n    r, companies = solve(n, roads)\n    print(r)\n    print(' '.join(map(str, companies)))\n```\n\nThis code first builds the tree representation of the cities and their connections using an adjacency list. Then it uses DFS to calculate the number of roads each company can repair without exceeding the limit of 2 for each city. After that, it distributes the roads among the companies in a way that minimizes the value of r. Finally, it prints the minimum value of r and the companies assigned to each road."}, {"generated_text": "Here's a Python program to solve the problem using a graph and a breadth-first search (BFS) approach.\n\n```python\nfrom collections import defaultdict, deque\n\ndef dfs(graph, company, city):\n    visited = set()\n    queue = deque([(city, company[city])])\n\n    while queue:\n        current_city, current_company = queue.popleft()\n\n        if current_city not in visited:\n            visited.add(current_city)\n            for neighbor in graph[current_city]:\n                if neighbor not in visited:\n                    queue.append((neighbor, company[neighbor] if neighbor in company else current_company))\n\n    return company\n\ndef solve(graph, cities, companies):\n    for city in graph:\n        if len(graph[city]) > 2:\n            for neighbor in graph[city]:\n                company = companies[neighbor]\n                companies[neighbor] = companies[city]\n                for n in graph[neighbor]:\n                    companies[n] = companies[city]\n                graph[neighbor].clear()\n\n    for i in range(1, len(cities)):\n        if len(graph[i]) == 1:\n            graph[i].pop()\n            graph[cities[i]].remove(i)\n            companies[i] = companies[cities[i]]\n\n    for city in graph:\n        companies[city] = 1\n\n    max_company = 1\n    for company in companies.values():\n        max_company = max(max_company, company)\n\n    return max_company\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        graph = defaultdict(list)\n        cities = list(range(1, n + 1))\n        companies = {}\n\n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n\n        result = solve(graph, cities, companies)\n        print(result)\n\n        for i in range(1, n):\n            if i > 1:\n                print(' ', end='')\n            print(companies[i], end='')\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program works by first clearing all roads that are connected to a city with more than two roads. Then it clears all roads that are connected to a city with only one road and assigns the company to the parent city. After that, it assigns a company to each city. The maximum company is the minimum number of roads assigned to the most used company. The program then prints the maximum company and the company for each road.\n\nPlease note that this solution assumes that the input is well-formed and does not contain any invalid data. You may need to add error checking code to handle invalid input."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    companies = defaultdict(list)\n    for node in range(1, n + 1):\n        companies[node] = [(1, node)]\n\n    def dfs(node, parent):\n        for child in graph[node]:\n            if child!= parent:\n                child_company = dfs(child, node)\n                companies[node].append(child_company)\n\n    dfs(1, 1)\n\n    def distribute_road(node, parent, company):\n        if len(companies[node]) > 2:\n            mid = len(companies[node]) // 2\n            companies[node] = companies[node][:mid] + companies[node][mid:]\n        if len(companies[node]) == 0:\n            return\n        if len(companies[node]) == 1:\n            companies[node][0] = (company, node)\n            return\n        companies[node].sort(key=lambda x: x[0])\n        if companies[node][0][0] == company:\n            companies[node][0] = (company, node)\n        else:\n            companies[node][0] = (companies[node][0][0] + 1, companies[node][0][1])\n            distribute_road(node, parent, company)\n\n    for node in range(1, n + 1):\n        distribute_road(node, 1, 1)\n\n    roads = [0] * (n - 1)\n    for node in range(1, n + 1):\n        for i, (company, road) in enumerate(companies[node]):\n            if i % 2 == 0:\n                roads[road - 1] = company\n\n    print(max(roads))\n    print(' '.join(map(str, roads)))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\nThis program first constructs the graph and then uses DFS to build the companies dictionary. It then distributes the roads among the companies to ensure that each city has at most two companies. Finally, it prints the minimum value of r and the corresponding distribution of roads among the companies."}, {"generated_text": "To solve this problem, we can use a graph traversal algorithm (such as DFS or BFS) to traverse the tree and assign roads to companies. We can use a dictionary to store the company number for each edge in the tree. When we encounter a node with degree 1, we can assign the road to the first company we have not used yet. For nodes with degree greater than 1, we can assign the road to the company that has not been used by the node's parent.\n\nHere is a Python solution for this problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, tree, used, companies, degree):\n    for neighbor in tree[node]:\n        if neighbor!= parent:\n            dfs(neighbor, node, tree, used, companies, degree)\n            companies[neighbor] = used[neighbor]\n            used[neighbor] += 1\n            degree[node] += 1\n    if degree[node] == 1:\n        used[node] += 1\n        companies[node] = used[node]\n    elif degree[node] > 1:\n        used[node] += 1\n        companies[node] = companies[parent]\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        tree = defaultdict(list)\n        used = defaultdict(int)\n        companies = defaultdict(int)\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            tree[u].append(v)\n            tree[v].append(u)\n        degree = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dfs(i, 0, tree, used, companies, degree)\n        max_company = max(companies.values())\n        r = max((max_company - companies[i] + 1) // 2 for i in range(1, n + 1))\n        print(r)\n        for i in range(1, n + 1):\n            if i!= 1:\n                print(' ', end='')\n            print(companies[i], end='')\n        print()\n\nsolve()\n```\n\nThis solution works by first creating a dictionary `tree` to store the adjacency list of the tree, and a dictionary `used` to store the number of roads assigned to each company. It then uses a DFS function to traverse the tree, assigning roads to companies as it goes. The DFS function uses a dictionary `companies` to store the company number for each node. After the DFS is complete, it finds the maximum company number and calculates the minimum possible value of `r`. Finally, it prints the value of `r` and the company number for each road."}, {"generated_text": "Here's a Python solution for the problem using Depth-First Search (DFS) and a disjoint set data structure.\n\n```python\nimport sys\ninput = sys.stdin.readline\n\ndef find(x, p):\n    if p[x]!= x:\n        p[x] = find(p[x], p)\n    return p[x]\n\ndef union(x, y, p, c):\n    r1 = find(x, p)\n    r2 = find(y, p)\n    if r1!= r2:\n        if c[find(x, p)] < c[find(y, p)]:\n            p[r1] = r2\n            c[r2] += c[r1]\n        else:\n            p[r2] = r1\n            c[r1] += c[r2]\n\ndef dfs(node, par, p, c, roads):\n    for child in roads[node]:\n        if child!= par:\n            dfs(child, node, p, c, roads)\n            union(node, child, p, c)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    roads = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        x, y = map(int, input().split())\n        roads[x - 1].append(y - 1)\n        roads[y - 1].append(x - 1)\n\n    p = list(range(n))\n    c = [1] * n\n\n    dfs(0, -1, p, c, roads)\n\n    max_val = max(c)\n    print(max_val)\n\n    result = [0] * (n - 1)\n    for i in range(n - 1):\n        x, y = roads[i].pop()\n        result[i] = find(x, p) + 1\n        if roads[i]:\n            union(i, roads[i][0], p, c)\n\n    print(*result)\n```\n\nThis code takes the number of test cases as input, and for each test case, it takes the number of cities and the roads as input. It then uses DFS and a disjoint set data structure to find the minimum possible number of roads assigned to the most used company. Finally, it prints the result for each test case."}, {"generated_text": "To solve this problem, we can use a graph traversal algorithm (Depth-First Search or DFS) to assign roads to companies. We will assign the first road to the first company, the second road to the second company, and so on. This way, we ensure that each company is assigned a unique number of roads.\n\nHere is a Python solution for the problem:\n\n```python\nfrom collections import defaultdict\n\ndef assign_roads(n, roads):\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(roads, 1):\n        graph[u].append((v, i))\n        graph[v].append((u, i))\n\n    company = 1\n    assigned = [0] * (n - 1)\n    for i in range(1, n + 1):\n        stack = [(i, -1)]\n        while stack:\n            u, p = stack.pop()\n            for v, edge in graph[u]:\n                if v!= p:\n                    assigned[edge - 1] = company\n                    company += 1\n                    stack.append((v, u))\n\n    return assigned, max(assigned)\n\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        roads = []\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            roads.append((u, v))\n        assigned, r = assign_roads(n, roads)\n        print(r)\n        print(' '.join(map(str, assigned)))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code defines a function `assign_roads` that takes the number of cities `n` and a list of roads as input, and returns a list of assigned companies and the maximum number of roads assigned to a company. The function uses a graph represented as a dictionary `graph` where each key is a city and the value is a list of tuples representing the neighboring cities and the road number. The function uses a stack to perform a DFS traversal of the graph and assign roads to companies.\n\nThe `main` function reads the input, calls the `assign_roads` function, and prints the result. The result includes the maximum number of roads assigned to a company `r` and a list of assigned companies.\n\nWhen you run this code, it will read the input, call the `assign_roads` function, and print the result for each test case."}, {"generated_text": "```python\nfrom collections import defaultdict\nimport sys\n\nclass Solution:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.company = [0 for _ in range(1000001)]\n        self.color = [0 for _ in range(3001)]\n        self.n = 0\n        self.r = 0\n        self.max_val = 0\n        self.max_comp = 0\n        self.cnt = 0\n\n    def dfs(self, u, parent):\n        self.color[u] = 1\n        self.cnt += 1\n        for v in self.graph[u]:\n            if v == parent:\n                continue\n            if self.color[v] == 1:\n                return 0\n            self.dfs(v, u)\n        if self.cnt == self.r:\n            self.max_val = u\n            self.max_comp = self.company[u]\n        self.cnt -= 1\n\n    def solve(self):\n        self.n = int(input())\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n        for i in range(1, self.n + 1):\n            if len(self.graph[i]) % 2!= 0:\n                self.r = len(self.graph[i]) // 2 + 1\n            else:\n                self.r = len(self.graph[i]) // 2\n            self.cnt = 0\n            self.dfs(i, -1)\n            for j in range(1, self.n + 1):\n                if j!= i:\n                    self.company[j] = self.company[i] + 1\n        self.r = self.max_val\n        self.company = [0 for _ in range(1000001)]\n        self.max_val = 0\n        self.max_comp = 0\n        for i in range(1, self.n + 1):\n            if self.color[i] == 1:\n                self.company[i] = 1\n        self.cnt = 0\n        self.dfs(self.r, -1)\n        self.r = self.max_comp\n        self.company = [0 for _ in range(1000001)]\n        self.max_val = 0\n        self.max_comp = 0\n        for i in range(1, self.n + 1):\n            if self.color[i] == 1:\n                self.company[i] = 1\n        self.cnt = 0\n        self.dfs(self.r, -1)\n        self.r = self.max_comp\n        self.company = [0 for _ in range(1000001)]\n        self.max_val = 0\n        self.max_comp = 0\n        for i in range(1, self.n + 1):\n            if self.color[i] == 1:\n                self.company[i] = 1\n        self.cnt = 0\n        self.dfs(self.r, -1)\n        self.r = self.max_comp\n        print(self.r)\n        for i in range(1, self.n + 1):\n            if self.color[i] == 1:\n                for v in self.graph[i]:\n                    if self.company[i]!= self.company[v]:\n                        self.company[v] = self.company[i]\n                        print(self.company[v], end=\" \")\n                print()\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        Solution().solve()\n```\n\nThis program first calculates the degree of each node in the graph and then performs a depth-first search (DFS) from each node. During the DFS, it keeps track of the number of nodes that have been visited and the maximum company number. It then finds the node with the maximum company number and assigns the corresponding company number to its neighbors. It repeats this process until all nodes have been assigned a company number.\n\nThe time complexity of this program is O(n * m), where n is the number of nodes and m is the number of edges in the graph. The space complexity is O(n), as we need to store the graph, the color array, the company array, and the maximum company number."}, {"generated_text": "Here's a Python solution that uses a depth-first search (DFS) to traverse the tree and assign roads to companies.\n\n```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, adj, comp, count):\n    for neighbor in adj[node]:\n        if neighbor!= parent:\n            if count[neighbor] > 1:\n                comp[neighbor].append((node, neighbor))\n            else:\n                comp[neighbor].append((node, neighbor))\n                count[neighbor] += 1\n            dfs(neighbor, node, adj, comp, count)\n\ndef distribute_roads(n, roads):\n    adj = defaultdict(list)\n    for u, v in roads:\n        adj[u].append(v)\n        adj[v].append(u)\n    comp = defaultdict(list)\n    count = defaultdict(int)\n    dfs(1, -1, adj, comp, count)\n    r = 1\n    for company in comp.values():\n        r = max(r, len(company) // 2 + len(company) % 2)\n    return r, [len(company) // 2 + 1 + i for i, company in enumerate(comp.values()) if len(company) > 1]\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n    r, companies = distribute_roads(n, roads)\n    print(r)\n    print(*companies)\n```\n\nThis code first constructs an adjacency list representation of the tree using a `defaultdict`. It then uses DFS to traverse the tree and assign roads to companies. The `distribute_roads` function returns the minimum possible number of roads assigned to the most used company and a list of companies where each company is represented by the number of roads assigned to it. The main loop reads input, calls `distribute_roads`, and prints the results.\n\nNote that this code assumes that the input is well-formed and does not contain any errors. It also assumes that the graph is a tree and that each company is assigned at most one additional road. If the input is malformed or the graph is not a tree, the code may produce incorrect results or crash."}, {"generated_text": "Here is a Python program that solves the problem using a depth-first search (DFS) approach to traverse the tree and a graph data structure to store the edges.\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n        self.company = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, u, p):\n        self.parent[u] = p\n        for v in self.adj[u]:\n            if v!= p:\n                self.dfs(v, u)\n                self.size[u] += self.size[v]\n\n    def distribute_roads(self):\n        self.dfs(1, 0)\n        queue = [(1, 0)]\n        visited = [False] * (self.n + 1)\n        visited[1] = True\n        while queue:\n            u, p = queue.pop(0)\n            for v in self.adj[u]:\n                if v!= p and not visited[v]:\n                    visited[v] = True\n                    self.company[v] = self.company[u] ^ 1\n                    queue.append((v, u))\n        for i in range(1, self.n):\n            if self.company[i] == 0:\n                self.company[i] = self.company[i - 1]\n        return self.company\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = Graph(n)\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            graph.add_edge(u, v)\n        company = graph.distribute_roads()\n        r = max(graph.adj[i] for i in range(1, n + 1))\n        print(r)\n        print(' '.join(str(c) for c in company[1:]))\n\nsolve()\n```\n\nThis program defines a `Graph` class to represent the tree and its edges. The `add_edge` method adds an edge between two nodes, the `dfs` method performs a depth-first search to calculate the size of each subtree, and the `distribute_roads` method distributes the roads among the companies.\n\nThe `solve` function reads the input, creates a graph, and calls the `distribute_roads` method to distribute the roads among the companies. It then prints the minimum number of roads assigned to the most used company and the companies assigned to each road.\n\nThis program assumes that the input is well-formed and does not contain any errors. If the input is invalid, it may produce incorrect results or crash."}, {"generated_text": "Here is a Python program that solves the problem using a Breadth-First Search (BFS) traversal to assign roads to companies.\n\n```python\nfrom collections import deque\n\ndef dfs(node, parent, graph, companies):\n    visited = set()\n    queue = deque([(node, parent)])\n    while queue:\n        curr, prev = queue.popleft()\n        visited.add(curr)\n        for neighbor in graph[curr]:\n            if neighbor!= prev and neighbor not in visited:\n                companies[neighbor] = companies[curr] + 1\n                queue.append((neighbor, curr))\n\ndef assign_companies(graph):\n    n = len(graph)\n    companies = {}\n    for i in range(1, n):\n        companies[i] = 1\n    for i in range(n):\n        dfs(i, -1, graph, companies)\n\n    company_road_map = {}\n    for i in range(1, n):\n        company = companies[i]\n        if company not in company_road_map:\n            company_road_map[company] = []\n        company_road_map[company].append(i)\n\n    max_company = max(company_road_map.keys())\n    road_count = 0\n    for company in company_road_map:\n        if company < max_company:\n            road_count += len(company_road_map[company]) * (company + 1) // 2\n        else:\n            road_count += len(company_road_map[company]) * company\n\n    return road_count, [company for company in company_road_map]\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            x -= 1\n            y -= 1\n            graph[x].append(y)\n            graph[y].append(x)\n        road_count, companies = assign_companies(graph)\n        print(road_count)\n        for company in companies:\n            print(company, end=' ')\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first assigns companies to roads using DFS traversal. Then it assigns roads to companies such that the maximum number of roads is minimized. The result is printed to the console.\n\nThis solution has a time complexity of O(n^2) where n is the number of cities. The space complexity is also O(n)."}, {"generated_text": "Here's a Python program to solve the problem. This program uses a depth-first search (DFS) approach to traverse the tree and assign roads to companies.\n\n```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, visited, company):\n    visited[node] = True\n    company[node] = 1\n    for neighbor in graph[node]:\n        if neighbor!= parent:\n            if not visited[neighbor]:\n                dfs(neighbor, node, graph, visited, company)\n                if company[neighbor] > company[node]:\n                    company[node], company[neighbor] = company[neighbor], company[node]\n            else:\n                if company[neighbor] == company[node]:\n                    company[neighbor] += 1\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = defaultdict(list)\n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n        visited = [False] * (n + 1)\n        company = [0] * (n + 1)\n        dfs(1, -1, graph, visited, company)\n        roads = [0] * (n - 1)\n        for i in range(1, n):\n            for neighbor in graph[i + 1]:\n                if company[i + 1] < company[neighbor]:\n                    roads[i - 1] = company[neighbor]\n                else:\n                    roads[i - 1] = company[i + 1]\n        r = max(roads)\n        print(r)\n        for road in roads:\n            print(road, end=' ')\n        print()\n\nsolve()\n```\n\nThis program works as follows:\n\n1.  It first reads the number of test cases `t`.\n2.  For each test case, it reads the number of cities `n` and the edges of the tree.\n3.  It uses a DFS approach to traverse the tree and assign roads to companies. In the DFS, it keeps track of the number of roads assigned to each company.\n4.  After the DFS, it calculates the maximum number of roads assigned to any company `r`.\n5.  Finally, it prints `r` and the number of companies assigned to each road.\n\nNote that this program assumes that the input is correct and doesn't include any error checking. You may want to add error checking depending on your specific requirements."}, {"generated_text": "Here is the Python program to solve the problem:\n\n```python\nimport sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, companies, visited):\n    visited[node] = True\n    companies[node] = set()\n    for neighbor in graph[node]:\n        if neighbor!= parent:\n            if not visited[neighbor]:\n                dfs(neighbor, node, graph, companies, visited)\n            companies[node].update(companies[neighbor])\n\ndef distribute_roads(graph, num_roads_per_company):\n    companies = defaultdict(set)\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if not visited[i]:\n            dfs(i, -1, graph, companies, visited)\n    \n    company_roads = {}\n    for i in range(len(graph)):\n        company_roads[i] = {}\n    \n    for i in range(len(graph)):\n        for neighbor in graph[i]:\n            if i < neighbor:\n                company = (i + 1) // 2\n                company_roads[i][company] = company_roads[i].get(company, 0) + 1\n                company_roads[neighbor][company] = company_roads[neighbor].get(company, 0) + 1\n    \n    for i in range(len(graph)):\n        for neighbor in graph[i]:\n            if i < neighbor:\n                company1 = (i + 1) // 2\n                company2 = (neighbor + 1) // 2\n                if company1!= company2:\n                    if company_roads[i][company1] == 1:\n                        company_roads[i][company2] += 1\n                        company_roads[neighbor][company2] += 1\n                        company_roads[i].pop(company1)\n                    elif company_roads[neighbor][company2] == 1:\n                        company_roads[i][company1] += 1\n                        company_roads[neighbor][company1] += 1\n                        company_roads[neighbor].pop(company2)\n    \n    result = []\n    for i in range(len(graph)):\n        for neighbor in graph[i]:\n            if i < neighbor:\n                company1 = (i + 1) // 2\n                company2 = (neighbor + 1) // 2\n                if company_roads[i][company1] > 0:\n                    result.append((i, company1))\n                    company_roads[i][company1] -= 1\n                    company_roads[neighbor][company1] -= 1\n                elif company_roads[neighbor][company2] > 0:\n                    result.append((neighbor, company2))\n                    company_roads[neighbor][company2] -= 1\n                    company_roads[i][company2] -= 1\n    \n    return result\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            u, v = map(int, input().split())\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n        \n        result = distribute_roads(graph, 2)\n        r = max(company for _, company in result) + 1\n        print(r)\n        for road in result:\n            print(road[1], end=' ')\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first performs a DFS traversal to group the cities into sets based on their common companies. Then it distributes the roads among the companies in such a way that each company has at most two roads. The result is a list of pairs, where each pair contains a road and the company that repairs it. The maximum value in this list is the minimum possible value of `r`."}, {"generated_text": "Here's a Python solution for the problem using Depth-First Search (DFS) and Breadth-First Search (BFS) to calculate the number of different companies for each city and distribute the roads among the companies.\n\n```python\nfrom collections import deque\n\ndef solve(n, roads):\n    # Step 1: Build the graph\n    graph = [[] for _ in range(n)]\n    for u, v in roads:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    # Step 2: Perform DFS to calculate the number of different companies for each city\n    company_count = [0] * n\n    root = 0\n    visited = [False] * n\n\n    def dfs(u, parent):\n        visited[u] = True\n        for v in graph[u]:\n            if v!= parent:\n                dfs(v, u)\n                company_count[u] += company_count[v]\n\n    dfs(root, -1)\n\n    # Step 3: Perform BFS to distribute the roads among the companies\n    result = [0] * (n - 1)\n    remaining_roads = n - 1\n    queue = deque([(root, 1)])\n    visited = [False] * n\n\n    while queue:\n        u, company = queue.popleft()\n        if visited[u]:\n            continue\n        visited[u] = True\n        if company_count[u] <= 2:\n            result[remaining_roads] = company\n            remaining_roads -= 1\n            for v in graph[u]:\n                queue.append((v, company))\n        else:\n            result[remaining_roads] = company\n            result[remaining_roads + 1] = company + 1\n            remaining_roads -= 2\n            for v in graph[u]:\n                queue.append((v, company + 1))\n\n    return max(result),''.join(map(str, result))\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n\n    r, c = solve(n, roads)\n    print(r)\n    print(c)\n```\n\nThis code first performs a DFS to calculate the number of different companies for each city. Then, it performs a BFS to distribute the roads among the companies. The result is the minimum number of roads assigned to the most used company and the list of companies assigned to each road."}]}