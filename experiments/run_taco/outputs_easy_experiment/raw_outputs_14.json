{"id": 14, "input": "Given a string 's'. The task is to find the smallest window length that contains all the characters of the given string at least one time.\nFor eg. A = aabcbcdbca, then the result would be 4 as of the smallest window will be dbca.\n \nExample 1:\nInput : \"AABBBCBBAC\"\nOutput : 3\nExplanation : Sub-string -> \"BAC\"\nExample 2:\nInput : \"aaab\"\nOutput : 2\nExplanation : Sub-string -> \"ab\"\n \nExample 3:\nInput : \"GEEKSGEEKSFOR\"\nOutput : 8\nExplanation : Sub-string -> \"GEEKSFOR\"\n \nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function findSubString() which takes the string  S as input and returns the length of the smallest such window of the string.\nExpected Time Complexity: O(256.N)\nExpected Auxiliary Space: O(256)\n \nConstraints:\n1 \u2264 |S| \u2264 10^{5}\nString may contain both type of English Alphabets.\n#User function Template for python3\n\n\n\nclass Solution:\n\n    def findSubString(self, str):\n\n        # Your code goes here\n\n    \n\n    \n\n    ", "difficulty": "MEDIUM", "generations": [{"generated_text": "Here's a Python solution that uses a sliding window approach along with a dictionary to store the frequency of characters in the string.\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n\n    def findSubString(self, str):\n        # Create a dictionary to store the frequency of characters\n        freq = defaultdict(int)\n        \n        # Calculate the frequency of characters in the string\n        for char in str:\n            freq[char] += 1\n        \n        # Initialize variables to store the minimum window length\n        min_len = float('inf')\n        \n        # Initialize variables to store the start and end of the window\n        start = 0\n        end = 0\n        \n        # Initialize a variable to store the number of unique characters\n        unique_chars = len(freq)\n        \n        # Initialize a dictionary to store the frequency of characters in the current window\n        window_freq = defaultdict(int)\n        \n        # Initialize a variable to store the number of unique characters in the current window\n        unique_chars_in_window = 0\n        \n        # Traverse the string\n        while end < len(str):\n            # Add the character at the end of the window to the window frequency\n            char = str[end]\n            window_freq[char] += 1\n            \n            # If the frequency of the character is 1, increment the number of unique characters in the window\n            if window_freq[char] == 1:\n                unique_chars_in_window += 1\n            \n            # While the number of unique characters in the window is equal to the number of unique characters in the string\n            while unique_chars_in_window == unique_chars:\n                # Update the minimum window length\n                min_len = min(min_len, end - start + 1)\n                \n                # Remove the character at the start of the window from the window frequency\n                char = str[start]\n                window_freq[char] -= 1\n                \n                # If the frequency of the character is 0, decrement the number of unique characters in the window\n                if window_freq[char] == 0:\n                    unique_chars_in_window -= 1\n                \n                # Move the start of the window to the right\n                start += 1\n            \n            # Move the end of the window to the right\n            end += 1\n        \n        # Return the minimum window length\n        return min_len\n```\n\nThis solution has a time complexity of O(256.N) and an auxiliary space complexity of O(256), where N is the length of the string."}, {"generated_text": "To solve this problem, we can use a sliding window approach along with a frequency dictionary to keep track of the characters we've seen so far. Here's a Python solution for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        # Create a frequency dictionary for the entire string\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Initialize variables to keep track of the sliding window\n        min_len = float('inf')\n        start = 0\n        formed = 0\n        window_counts = {}\n        \n        # Initialize the window to the start of the string\n        for end in range(len(str)):\n            # Add the current character to the window\n            char = str[end]\n            if char in freq:\n                window_counts[char] = window_counts.get(char, 0) + 1\n                if window_counts[char] == freq[char]:\n                    formed += 1\n            \n            # Try to minimize the window\n            while formed == len(freq):\n                # Update the minimum length\n                min_len = min(min_len, end - start + 1)\n                \n                # Remove the character at the start of the window\n                char = str[start]\n                if char in freq:\n                    window_counts[char] -= 1\n                    if window_counts[char] < freq[char]:\n                        formed -= 1\n                start += 1\n        \n        # Return the minimum length if it's not infinity\n        return min_len if min_len!= float('inf') else 0\n```\n\nThis solution works by maintaining a sliding window and expanding it to the right until we've seen all the characters we're interested in (i.e., the frequency of each character in the window is equal to the frequency of that character in the entire string). We then try to minimize the window by moving the start of the window to the right. The minimum length of the window is updated whenever we find a smaller window that contains all the characters we're interested in.\n\nThe time complexity of this solution is O(256.N) because we're iterating over the string and potentially adding/removing characters from the frequency dictionary for each character. The auxiliary space complexity is O(256) because we're using a dictionary to store the frequency of each character in the window."}, {"generated_text": "Here's a Python program to solve the given problem using the sliding window technique. The idea is to maintain a frequency dictionary of characters in the string and another frequency dictionary of characters in the current window. We move the window to the right and update the frequency dictionary of the current window. If the frequency dictionary of the current window is equal to the frequency dictionary of the string, it means that the current window contains all the characters of the string.\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a frequency dictionary of the string\n        freq_dict = defaultdict(int)\n        for char in str:\n            freq_dict[char] += 1\n        \n        # Initialize variables for the sliding window\n        min_window = n + 1\n        left = 0\n        window_freq_dict = defaultdict(int)\n        \n        # Initialize the count of unique characters in the window\n        unique_chars = 0\n        \n        # Traverse the string\n        for right in range(n):\n            # Add the character at the right of the window to the frequency dictionary\n            char = str[right]\n            window_freq_dict[char] += 1\n            \n            # If the frequency of the character is equal to the frequency in the string, increment the count of unique characters\n            if window_freq_dict[char] == freq_dict[char]:\n                unique_chars += 1\n            \n            # While the window contains all unique characters, try to minimize the window\n            while unique_chars == len(freq_dict):\n                min_window = min(min_window, right - left + 1)\n                \n                # Remove the character at the left of the window from the frequency dictionary\n                char = str[left]\n                window_freq_dict[char] -= 1\n                \n                # If the frequency of the character is less than the frequency in the string, decrement the count of unique characters\n                if window_freq_dict[char] < freq_dict[char]:\n                    unique_chars -= 1\n                \n                # Move the window to the right\n                left += 1\n        \n        # Return the minimum window length\n        return min_window if min_window!= n + 1 else 0\n```\n\nThis solution has a time complexity of O(256.N) and an auxiliary space complexity of O(256), where N is the length of the string and 256 is the number of possible ASCII characters. The solution uses the sliding window technique to efficiently find the smallest window that contains all the characters of the string."}, {"generated_text": "To solve this problem, we can use a sliding window approach along with a hash map to keep track of the frequency of characters in the string and the current window. Here is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        char_count = {}\n        for char in str:\n            char_count[char] = char_count.get(char, 0) + 1\n\n        unique_chars = len(char_count)\n        min_len = float('inf')\n        left = 0\n        formed = 0\n\n        window_counts = {}\n\n        for right in range(n):\n            char = str[right]\n            window_counts[char] = window_counts.get(char, 0) + 1\n\n            if window_counts[char] == char_count[char]:\n                formed += 1\n\n            while left <= right and formed == unique_chars:\n                char = str[left]\n\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n\n                window_counts[char] -= 1\n                if window_counts[char] < char_count[char]:\n                    formed -= 1\n\n                left += 1\n\n        return min_len if min_len!= float('inf') else 0\n```\n\nThis code works by maintaining a sliding window `[left, right]` and expanding it to the right by incrementing `right`. When the window contains all unique characters (i.e., `formed == unique_chars`), we try to minimize the window by moving `left` to the right. We keep track of the minimum length of the window that contains all unique characters in `min_len`. If no such window exists, we return `0`.\n\nThe time complexity of this code is O(256.N), where N is the length of the string, and the auxiliary space complexity is O(256), which is used to store the hash map `char_count` and `window_counts`."}, {"generated_text": "Here's the Python code that meets the requirements:\n\n```python\nclass Solution:\n    def findSubString(self, str):\n        # Create a dictionary to store the frequency of each character\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Calculate the total number of unique characters\n        unique_chars = len(freq)\n        \n        # Initialize the required window size\n        req_window_size = unique_chars\n        \n        # Initialize the minimum window size\n        min_window_size = float('inf')\n        \n        # Initialize the left and right pointers of the window\n        left = 0\n        right = 0\n        \n        # Initialize a dictionary to store the frequency of characters in the current window\n        window_freq = {}\n        \n        # Initialize the count of unique characters in the current window\n        unique_chars_in_window = 0\n        \n        # Traverse the string using the sliding window technique\n        while right < len(str):\n            # Add the character at the right pointer to the window\n            char = str[right]\n            if char in freq:\n                if char in window_freq:\n                    window_freq[char] += 1\n                else:\n                    window_freq[char] = 1\n                \n                # If the frequency of the character in the window is equal to the frequency in the string, increment the count of unique characters in the window\n                if window_freq[char] == freq[char]:\n                    unique_chars_in_window += 1\n            \n            # While the window size is greater than or equal to the required window size and the left pointer is less than the right pointer\n            while right - left + 1 >= req_window_size and left <= right:\n                # Update the minimum window size\n                min_window_size = min(min_window_size, right - left + 1)\n                \n                # Remove the character at the left pointer from the window\n                char = str[left]\n                if char in window_freq:\n                    window_freq[char] -= 1\n                    \n                    # If the frequency of the character in the window is less than the frequency in the string, decrement the count of unique characters in the window\n                    if window_freq[char] < freq[char]:\n                        unique_chars_in_window -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n            \n            # Move the right pointer to the right\n            right += 1\n        \n        # Return the minimum window size\n        return min_window_size\n```\n\nThis solution uses the sliding window technique to find the smallest window size that contains all the characters of the given string at least once. The time complexity is O(256.N) and the auxiliary space complexity is O(256), where N is the length of the input string."}, {"generated_text": "To find the smallest window length that contains all the characters of the given string at least one time, we can use a dictionary to store the frequency of each character in the string. Then, we can use two pointers to find the smallest window.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n\n        n = len(str)\n        char_freq = {}\n        min_length = n\n\n        # Calculate the frequency of each character\n        for char in str:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n\n        # Initialize the window boundaries\n        left = 0\n        formed = 0\n\n        # Create a dictionary to store the frequency of each character in the window\n        window_freq = {}\n\n        for right in range(n):\n            char = str[right]\n            window_freq[char] = window_freq.get(char, 0) + 1\n\n            # If the frequency of the character in the window is equal to the frequency in the string\n            if window_freq[char] == char_freq[char]:\n                formed += 1\n\n            # Try to minimize the window\n            while formed == len(char_freq):\n                min_length = min(min_length, right - left + 1)\n\n                char = str[left]\n                window_freq[char] -= 1\n\n                # If the frequency of the character in the window is less than the frequency in the string\n                if window_freq[char] < char_freq[char]:\n                    formed -= 1\n\n                left += 1\n\n        return min_length\n```\n\nIn this code:\n\n1.  We first calculate the frequency of each character in the string.\n2.  Then, we use two pointers, `left` and `right`, to create a sliding window.\n3.  We calculate the frequency of each character in the window and check if it is equal to the frequency in the string.\n4.  If the frequency is equal, we increment the `formed` variable.\n5.  We try to minimize the window by moving the `left` pointer to the right.\n6.  If the frequency of a character in the window is less than the frequency in the string, we decrement the `formed` variable.\n7.  We repeat steps 3-6 until the `formed` variable is equal to the number of unique characters in the string.\n8.  Finally, we return the minimum length of the window.\n\nThe time complexity of this code is O(256.N) because we are iterating over the string once to calculate the frequency of each character and once to create the sliding window. The auxiliary space complexity is O(256) because we are using a dictionary to store the frequency of each character."}, {"generated_text": "To find the smallest window length that contains all characters of the given string at least once, we can use a sliding window approach along with a dictionary to keep track of the frequency of characters in the current window. Here's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, s):\n        n = len(s)\n        \n        # Create a dictionary to store the frequency of characters in the string\n        freq = {}\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Initialize variables for the sliding window\n        required_chars = len(freq)\n        formed_chars = 0\n        window_freq = {}\n        min_window = n + 1\n        left = 0\n        \n        # Traverse the string using the sliding window\n        for right in range(n):\n            # Add the current character to the window\n            char = s[right]\n            window_freq[char] = window_freq.get(char, 0) + 1\n            \n            # If the current character is in the frequency dictionary and its frequency in the window is equal to its frequency in the string, increment the formed_chars count\n            if char in freq and window_freq[char] == freq[char]:\n                formed_chars += 1\n            \n            # Try to minimize the window by moving the left pointer\n            while left <= right and formed_chars == required_chars:\n                char = s[left]\n                \n                # Update the minimum window size\n                if right - left + 1 < min_window:\n                    min_window = right - left + 1\n                \n                # Remove the leftmost character from the window\n                window_freq[char] -= 1\n                \n                # If the leftmost character is in the frequency dictionary and its frequency in the window is less than its frequency in the string, decrement the formed_chars count\n                if char in freq and window_freq[char] < freq[char]:\n                    formed_chars -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window size\n        return min_window if min_window!= n + 1 else 0\n```\n\nThis code works by maintaining a sliding window of characters that contains all the characters of the string at least once. It uses a dictionary to keep track of the frequency of characters in the window and in the string. The time complexity of this code is O(256.N), where N is the length of the string, and the auxiliary space complexity is O(256), which is the size of the frequency dictionary."}, {"generated_text": "To solve this problem, we can use a sliding window approach along with a frequency counter to keep track of the characters we've seen so far. Here's a Python solution using this approach:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        char_freq = {}\n        min_window = float('inf')\n\n        for char in str:\n            if char not in char_freq:\n                char_freq[char] = 0\n            char_freq[char] += 1\n\n        unique_chars = len(char_freq)\n\n        left = 0\n        formed = 0\n\n        char_freq_copy = char_freq.copy()\n\n        for right in range(n):\n            char = str[right]\n            if char in char_freq_copy:\n                char_freq_copy[char] -= 1\n                if char_freq_copy[char] == 0:\n                    formed += 1\n\n            while left <= right and formed == unique_chars:\n                char = str[left]\n\n                min_window = min(min_window, right - left + 1)\n\n                if char in char_freq_copy:\n                    char_freq_copy[char] += 1\n                    if char_freq_copy[char] > 0:\n                        formed -= 1\n\n                left += 1\n\n        return min_window if min_window!= float('inf') else 0\n```\n\nThis solution works as follows:\n\n1.  We first create a frequency counter `char_freq` to store the frequency of each character in the string.\n2.  We then iterate over the string, and for each character, we decrement its frequency in `char_freq_copy` (a copy of `char_freq`). If a character's frequency becomes 0, we increment the `formed` counter, which represents the number of unique characters we've seen so far.\n3.  We maintain a sliding window `[left, right]` and expand it to the right by incrementing `right`. When `formed` equals `unique_chars`, it means we've seen all unique characters at least once within the current window.\n4.  We then try to minimize the window size by moving the `left` pointer to the right. If a character's frequency becomes 0, we decrement the `formed` counter. We update `min_window` with the minimum window size seen so far.\n5.  Finally, we return `min_window` if it's not infinity, which means we've found a valid window containing all unique characters at least once. Otherwise, we return 0.\n\nThis solution has a time complexity of O(256.N), where 256 is the number of possible ASCII characters, and N is the length of the input string. The auxiliary space complexity is O(256), as we need to store the frequency of each character."}, {"generated_text": "Here's a Python program that uses a sliding window approach along with a frequency dictionary to solve the problem.\n\n```python\nclass Solution:\n    def findSubString(self, str):\n        # Calculate the frequency of each character in the string\n        char_freq = {}\n        for char in str:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n        \n        # Initialize variables for the sliding window\n        min_len = float('inf')\n        required_chars = len(char_freq)\n        window_counts = {}\n        formed_chars = 0\n        \n        # Initialize the sliding window\n        window_start = 0\n        for window_end in range(len(str)):\n            char = str[window_end]\n            window_counts[char] = window_counts.get(char, 0) + 1\n            \n            # If the character is in the frequency dictionary and its count in the window is equal to its frequency, increment the formed_chars count\n            if char in char_freq and window_counts[char] == char_freq[char]:\n                formed_chars += 1\n            \n            # Try to minimize the window\n            while window_start <= window_end and formed_chars == required_chars:\n                char = str[window_start]\n                min_len = min(min_len, window_end - window_start + 1)\n                \n                # If the character is in the frequency dictionary and its count in the window is equal to its frequency, decrement the formed_chars count\n                if char in char_freq and window_counts[char] == char_freq[char]:\n                    formed_chars -= 1\n                \n                # Move the window to the right\n                window_counts[char] -= 1\n                window_start += 1\n        \n        # Return the minimum length\n        return min_len\n```\n\nThis program works by maintaining a sliding window of characters and trying to minimize it while ensuring that all characters in the frequency dictionary are present in the window at least once.\n\nThe time complexity of this program is O(256.N) where N is the length of the string, because it needs to traverse the string once to calculate the frequency of each character and then it needs to traverse the string again to find the minimum window.\n\nThe auxiliary space complexity of this program is O(256), because it needs to store the frequency of each character in the frequency dictionary."}, {"generated_text": "To solve this problem, we will use a sliding window approach along with a hash map to store the frequency of characters in the string. We will try to minimize the window size by moving the start of the window to the right.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def findSubString(self, str):\n        n = len(str)\n        char_count = {}\n        \n        # Store the frequency of characters in the string\n        for char in str:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # Initialize variables for the sliding window\n        required_chars = len(char_count)\n        formed_chars = 0\n        window_counts = {}\n        min_len = n + 1\n        left = 0\n        \n        # Try to minimize the window size\n        for right in range(n):\n            char = str[right]\n            window_counts[char] = window_counts.get(char, 0) + 1\n            \n            # If the frequency of the character in the window is equal to the frequency in the string, increment the formed_chars count\n            if window_counts[char] == char_count[char]:\n                formed_chars += 1\n            \n            # If all characters are formed in the window, try to minimize the window size\n            while left <= right and formed_chars == required_chars:\n                char = str[left]\n                \n                # Update the minimum length\n                min_len = min(min_len, right - left + 1)\n                \n                # Remove the leftmost character from the window\n                window_counts[char] -= 1\n                \n                # If the frequency of the character in the window is less than the frequency in the string, decrement the formed_chars count\n                if window_counts[char] < char_count[char]:\n                    formed_chars -= 1\n                \n                # Move the window to the right\n                left += 1\n        \n        # Return the minimum window size\n        return min_len\n```\n\nThis solution works by maintaining a sliding window and trying to minimize its size. It uses a hash map to store the frequency of characters in the string and another hash map to store the frequency of characters in the current window. The time complexity of this solution is O(256.N) and the auxiliary space complexity is O(256), where N is the length of the string."}, {"generated_text": "To solve this problem, we can use a sliding window approach along with a frequency dictionary to keep track of the characters and their counts in the string. Here's the Python code to solve the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a frequency dictionary for the string\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Initialize the minimum window size\n        min_window = n\n        \n        # Initialize the left and right pointers of the window\n        left = 0\n        \n        # Initialize the frequency dictionary for the current window\n        window_freq = {}\n        \n        # Initialize the number of unique characters in the window\n        unique_chars = 0\n        \n        # Iterate over the string to find the smallest window\n        for right in range(n):\n            # Add the current character to the window frequency dictionary\n            char = str[right]\n            if char in freq:\n                window_freq[char] = window_freq.get(char, 0) + 1\n                if window_freq[char] == freq[char]:\n                    unique_chars += 1\n            \n            # Try to shrink the window from the left\n            while unique_chars == len(freq):\n                # Update the minimum window size\n                min_window = min(min_window, right - left + 1)\n                \n                # Remove the leftmost character from the window frequency dictionary\n                char = str[left]\n                if char in freq:\n                    if window_freq[char] == freq[char]:\n                        unique_chars -= 1\n                    window_freq[char] -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window size\n        return min_window\n```\n\nThis code first creates a frequency dictionary for the input string. It then initializes the minimum window size to the length of the string and the left and right pointers of the window. The code also initializes the frequency dictionary for the current window and the number of unique characters in the window.\n\nThe code then iterates over the string to find the smallest window. For each character, it adds the character to the window frequency dictionary and checks if the number of unique characters in the window is equal to the number of unique characters in the string. If it is, the code tries to shrink the window from the left by removing the leftmost character from the window frequency dictionary and moving the left pointer to the right.\n\nFinally, the code returns the minimum window size.\n\nThe time complexity of this code is O(256.N) because it iterates over the string once and uses a frequency dictionary to keep track of the characters and their counts. The auxiliary space complexity is O(256) because the code uses a frequency dictionary to store the characters and their counts."}, {"generated_text": "Here's a Python solution for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        if not str:\n            return 0\n        \n        # Create a dictionary to store the frequency of each character\n        char_freq = {}\n        for char in str:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n        \n        # Initialize variables to keep track of the minimum window\n        min_window_len = float('inf')\n        required_chars = len(char_freq)\n        formed_chars = 0\n        \n        # Initialize the window boundaries\n        window_counts = {}\n        left = 0\n        \n        # Traverse the string\n        for right in range(len(str)):\n            character = str[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            \n            # If the character is in char_freq and its frequency in the window is equal to its frequency in char_freq, increment formed_chars\n            if character in char_freq and window_counts[character] == char_freq[character]:\n                formed_chars += 1\n            \n            # If all characters are formed, try to minimize the window\n            while left <= right and formed_chars == required_chars:\n                character = str[left]\n                \n                # Update the minimum window length\n                min_window_len = min(min_window_len, right - left + 1)\n                \n                # Remove the character from the window\n                window_counts[character] -= 1\n                \n                # If the character is in char_freq and its frequency in the window is less than its frequency in char_freq, decrement formed_chars\n                if character in char_freq and window_counts[character] < char_freq[character]:\n                    formed_chars -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window length\n        return min_window_len if min_window_len!= float('inf') else 0\n```\n\nThis solution uses a sliding window approach with two pointers (left and right) to traverse the string. It maintains a dictionary `char_freq` to store the frequency of each character in the string and another dictionary `window_counts` to store the frequency of each character in the current window. The `formed_chars` variable keeps track of the number of characters that have been formed in the current window. The `required_chars` variable stores the total number of unique characters in the string. The minimum window length is updated whenever a valid window is found."}, {"generated_text": "To solve this problem, we can use a sliding window approach along with a frequency map to track the count of characters in the current window. We will expand the window to the right until we have all unique characters in the string, then we will contract the window from the left until we have only one character that is missing. The size of this window will be our answer.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        # Create a frequency map of the string\n        freq_map = {}\n        for char in str:\n            if char in freq_map:\n                freq_map[char] += 1\n            else:\n                freq_map[char] = 1\n\n        # Initialize variables\n        min_len = float('inf')\n        window_start = 0\n        count = len(freq_map)\n        unique_chars = set()\n        formed = 0\n\n        # Traverse the string\n        for window_end in range(len(str)):\n            # Add the character at the end of the window to the unique characters\n            right_char = str[window_end]\n            if right_char in freq_map:\n                unique_chars.add(right_char)\n                freq_map[right_char] -= 1\n                if freq_map[right_char] == 0:\n                    formed += 1\n\n            # Shrink the window from the left until we have only one character missing\n            while formed == count:\n                # Update the minimum length\n                min_len = min(min_len, window_end - window_start + 1)\n\n                # Remove the character at the start of the window from the unique characters\n                left_char = str[window_start]\n                if left_char in freq_map:\n                    if freq_map[left_char] == 0:\n                        formed -= 1\n                    freq_map[left_char] += 1\n                window_start += 1\n\n        return min_len if min_len!= float('inf') else 0\n```\n\nThis code first creates a frequency map of the input string. Then it initializes variables to keep track of the minimum window length, the start of the window, the count of unique characters, and the number of formed characters. It traverses the string and expands the window to the right, adding characters to the unique characters and decrementing their frequency in the frequency map. When all characters are formed, it shrinks the window from the left, removing characters from the unique characters and incrementing their frequency in the frequency map. The minimum window length is updated whenever a smaller window is found. Finally, it returns the minimum window length if it is not infinity, otherwise it returns 0.\n\nThis code has a time complexity of O(256.N) and an auxiliary space complexity of O(256), where N is the length of the input string."}, {"generated_text": "Here's a Python program that uses a sliding window approach with the help of a frequency counter to solve the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        # Create a frequency dictionary\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n\n        # Initialize variables\n        n = len(str)\n        min_len = n\n        left = 0\n        formed = 0\n\n        # Create a window frequency dictionary\n        window_counts = {}\n\n        # Iterate over the string\n        for right in range(n):\n            # Add the current character to the window\n            character = str[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            # If the current character is in the frequency dictionary and its count in the window is equal to its count in the frequency dictionary, increment the formed variable\n            if character in freq and window_counts[character] == freq[character]:\n                formed += 1\n\n            # While the window contains all characters and the left pointer is not at the beginning of the string\n            while left <= right and formed == len(freq):\n                # Update the minimum length\n                min_len = min(min_len, right - left + 1)\n\n                # Remove the character at the left pointer from the window\n                character = str[left]\n                window_counts[character] -= 1\n\n                # If the count of the character at the left pointer in the window is less than its count in the frequency dictionary, decrement the formed variable\n                if character in freq and window_counts[character] < freq[character]:\n                    formed -= 1\n\n                # Move the left pointer to the right\n                left += 1\n\n        return min_len\n```\n\nThis program works by maintaining a sliding window over the string. It uses a frequency dictionary to keep track of the frequency of each character in the string and a window frequency dictionary to keep track of the frequency of each character in the current window. The program iterates over the string, adding characters to the window and updating the window frequency dictionary. When the window contains all characters and the left pointer is not at the beginning of the string, it updates the minimum length and removes characters from the window. The program returns the minimum length of the window that contains all characters at least once."}, {"generated_text": "To solve this problem, we will use a sliding window approach along with a hash map to keep track of the characters and their frequencies. \n\nHere is the Python code:\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a hash map to store the frequency of each character\n        freq_map = defaultdict(int)\n        for char in str:\n            freq_map[char] += 1\n        \n        # Initialize variables to keep track of the minimum window\n        min_window = float('inf')\n        unique_chars = len(freq_map)\n        \n        # Initialize the left and right pointers of the sliding window\n        left = 0\n        formed = 0\n        \n        # Initialize the hash map to store the frequency of characters in the current window\n        window_freq = defaultdict(int)\n        \n        # Traverse the string from left to right\n        for right in range(n):\n            # Add the character at the right pointer to the window\n            char = str[right]\n            window_freq[char] += 1\n            \n            # If the frequency of the character in the window is equal to the frequency in the string,\n            # increment the 'formed' counter\n            if freq_map[char] == window_freq[char]:\n                formed += 1\n            \n            # Try to minimize the window by moving the left pointer\n            while left <= right and formed == unique_chars:\n                # Update the minimum window\n                min_window = min(min_window, right - left + 1)\n                \n                # Remove the character at the left pointer from the window\n                char = str[left]\n                window_freq[char] -= 1\n                \n                # If the frequency of the character in the window is less than the frequency in the string,\n                # decrement the 'formed' counter\n                if freq_map[char] > window_freq[char]:\n                    formed -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window length\n        return min_window\n```\n\nThis code first creates a hash map to store the frequency of each character in the string. Then, it initializes variables to keep track of the minimum window and the number of unique characters.\n\nIt uses a sliding window approach by maintaining two pointers, `left` and `right`, which represent the start and end of the window, respectively. It also uses a hash map to store the frequency of characters in the current window.\n\nAs it traverses the string from left to right, it adds characters to the window and updates the `formed` counter if the frequency of a character in the window is equal to the frequency in the string.\n\nWhen the `formed` counter is equal to the number of unique characters, it tries to minimize the window by moving the `left` pointer to the right. It updates the minimum window length and removes characters from the window until the `formed` counter is less than the number of unique characters.\n\nFinally, it returns the minimum window length.\n\nThe time complexity of this code is O(256.N), where N is the length of the string, because it needs to traverse the string and update the hash maps. The auxiliary space complexity is O(256), which is the maximum number of characters in the string, because it needs to store the frequency of each character in the string and the window."}, {"generated_text": "To solve this problem, we can use a sliding window approach with the help of a frequency dictionary to keep track of the characters and their frequencies in the string. We can also use a set to keep track of the unique characters in the string.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a frequency dictionary\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Find the minimum window size\n        min_window_size = float('inf')\n        \n        # Initialize the left and right pointers\n        left = 0\n        formed = 0\n        \n        # Create a window frequency dictionary\n        window_freq = {}\n        \n        # Traverse the string\n        for right in range(n):\n            # Add the character to the window frequency dictionary\n            char = str[right]\n            window_freq[char] = window_freq.get(char, 0) + 1\n            \n            # If the character is in the frequency dictionary and its frequency in the window is equal to its frequency in the frequency dictionary, increment the formed count\n            if char in freq and window_freq[char] == freq[char]:\n                formed += 1\n            \n            # While the window is valid and the left pointer is not at the beginning of the string\n            while left <= right and formed == len(freq):\n                # Update the minimum window size\n                min_window_size = min(min_window_size, right - left + 1)\n                \n                # Remove the character at the left pointer from the window frequency dictionary\n                char = str[left]\n                window_freq[char] -= 1\n                \n                # If the character is in the frequency dictionary and its frequency in the window is less than its frequency in the frequency dictionary, decrement the formed count\n                if char in freq and window_freq[char] < freq[char]:\n                    formed -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window size if it is not infinity, otherwise return 0\n        return min_window_size if min_window_size!= float('inf') else 0\n```\n\nThis code works by maintaining a sliding window of characters and expanding it to the right while keeping track of the characters and their frequencies. When the window is valid (i.e., all characters are present at least once), it tries to minimize the window size by moving the left pointer to the right. The minimum window size is updated whenever a valid window is found. Finally, it returns the minimum window size if it is not infinity, otherwise it returns 0."}, {"generated_text": "Here is the Python solution for the problem. The idea is to use a sliding window approach along with a frequency dictionary to keep track of the characters in the string. \n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a frequency dictionary to store the frequency of each character\n        freq = {}\n        for char in str:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Initialize variables to keep track of the window\n        window_start = 0\n        min_len = float('inf')\n        formed = 0\n        \n        # Create a frequency dictionary to store the frequency of each character in the current window\n        window_freq = {}\n        \n        # Traverse the string\n        for window_end in range(n):\n            right_char = str[window_end]\n            \n            # If the character is in the frequency dictionary, decrement its count\n            if right_char in freq:\n                if right_char in window_freq:\n                    window_freq[right_char] += 1\n                else:\n                    window_freq[right_char] = 1\n                \n                # If the count of the character in the window is equal to the count in the string, increment the formed variable\n                if window_freq[right_char] == freq[right_char]:\n                    formed += 1\n            \n            # If all characters in the string are present in the window, try to minimize the window\n            while window_start <= window_end and formed == len(freq):\n                left_char = str[window_start]\n                \n                # Update the minimum length\n                min_len = min(min_len, window_end - window_start + 1)\n                \n                # If the character is in the frequency dictionary, increment its count\n                if left_char in freq:\n                    window_freq[left_char] -= 1\n                    if window_freq[left_char] < freq[left_char]:\n                        formed -= 1\n                \n                # Move the window to the right\n                window_start += 1\n        \n        # Return the minimum length\n        return min_len\n```\n\nThis solution has a time complexity of O(256.N) because we are iterating over the string and the frequency dictionary. The space complexity is O(256) because we are storing the frequency of each character in the string. \n\nThis solution assumes that the input string only contains English alphabets. If the string can contain other characters, the frequency dictionary and the window frequency dictionary should be modified accordingly. \n\nThe function `findSubString` takes the string `str` as input and returns the length of the smallest window that contains all the characters of the string at least once. \n\nYou can use this function in the following way:\n\n```python\nsolution = Solution()\nprint(solution.findSubString(\"AABBBCBBAC\"))  # Output: 3\nprint(solution.findSubString(\"aaab\"))  # Output: 2\nprint(solution.findSubString(\"GEEKSGEEKSFOR\"))  # Output: 8\n```"}, {"generated_text": "Here's the Python code that solves the problem using a sliding window approach.\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a dictionary to store the frequency of each character\n        freq = {}\n        for char in str:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Initialize variables to keep track of the minimum window\n        min_window = float('inf')\n        \n        # Initialize variables to keep track of the current window\n        left = 0\n        formed = 0\n        \n        # Create a dictionary to store the frequency of characters in the current window\n        window_counts = {}\n        \n        # Traverse the string\n        for right in range(n):\n            # Add the current character to the window\n            character = str[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            \n            # If the current character is in the frequency dictionary and its frequency in the window is equal to its frequency in the string, increment the formed variable\n            if character in freq and window_counts[character] == freq[character]:\n                formed += 1\n            \n            # While the window is valid and the left pointer is not at the beginning of the string\n            while left <= right and formed == len(freq):\n                # Update the minimum window\n                min_window = min(min_window, right - left + 1)\n                \n                # Remove the leftmost character from the window\n                character = str[left]\n                window_counts[character] -= 1\n                \n                # If the frequency of the leftmost character in the window is less than its frequency in the string, decrement the formed variable\n                if character in freq and window_counts[character] < freq[character]:\n                    formed -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window size if it is not infinity, otherwise return 0\n        return min_window if min_window!= float('inf') else 0\n```\n\nThis solution works by maintaining a sliding window of characters. It expands the window to the right by adding characters to the `window_counts` dictionary and checks if the window is valid by comparing the frequencies of characters in the window with their frequencies in the `freq` dictionary. When the window is valid, it tries to minimize the window size by moving the left pointer to the right. The minimum window size is updated whenever a valid window is found.\n\nThe time complexity of this solution is O(256.N) because it iterates over the string once and uses a dictionary to store the frequency of each character. The space complexity is O(256) because it uses a dictionary to store the frequency of each character.\n\nYou can test this function with the examples you provided:\n\n```python\nsolution = Solution()\n\nprint(solution.findSubString(\"AABBBCBBAC\"))  # Output: 3\nprint(solution.findSubString(\"aaab\"))  # Output: 2\nprint(solution.findSubString(\"GEEKSGEEKSFOR\"))  # Output: 8\n```"}, {"generated_text": "Here's a Python solution for the problem using a dictionary to store the frequency of characters in the string and another dictionary to store the frequency of characters in the current window.\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n\n        # Calculate the length of the string\n        n = len(str)\n        \n        # Create a dictionary to store the frequency of characters in the string\n        freq_str = {}\n        for char in str:\n            if char in freq_str:\n                freq_str[char] += 1\n            else:\n                freq_str[char] = 1\n        \n        # Initialize the minimum window length to infinity\n        min_window = float('inf')\n        \n        # Initialize the left and right pointers of the sliding window\n        left = 0\n        right = 0\n        \n        # Initialize the formed count to 0\n        formed = 0\n        \n        # Create a dictionary to store the frequency of characters in the current window\n        window_counts = {}\n        \n        # Traverse the string using the sliding window technique\n        while right < n:\n            # Add the character at the right pointer to the window\n            character = str[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            \n            # If the frequency of the character in the window is equal to the frequency in the string, increment the formed count\n            if window_counts[character] == freq_str.get(character, 0):\n                formed += 1\n            \n            # While the window is valid and the left pointer is less than the right pointer, try to shrink the window\n            while left <= right and formed == len(freq_str):\n                # Update the minimum window length\n                min_window = min(min_window, right - left + 1)\n                \n                # Remove the character at the left pointer from the window\n                character = str[left]\n                window_counts[character] -= 1\n                \n                # If the frequency of the character in the window is less than the frequency in the string, decrement the formed count\n                if window_counts[character] < freq_str.get(character, 0):\n                    formed -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n            \n            # Move the right pointer to the right\n            right += 1\n        \n        # Return the minimum window length if it's not infinity, otherwise return 0\n        return 0 if min_window == float('inf') else min_window\n```\n\nThis solution has a time complexity of O(256.N) and an auxiliary space complexity of O(256), where N is the length of the string. The time complexity is O(256.N) because we're iterating over the string and using a dictionary to store the frequency of characters in the string and the current window. The auxiliary space complexity is O(256) because the maximum size of the dictionary is 256, which is the number of possible characters in the string."}, {"generated_text": "Here is the Python solution for the problem:\n\n```python\nclass Solution:\n\n    def findSubString(self, str):\n        n = len(str)\n        \n        # Create a dictionary to store the frequency of each character\n        char_freq = {}\n        for char in str:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n        \n        # Calculate the total number of unique characters\n        total_unique_chars = len(char_freq)\n        \n        # Initialize the minimum window length to infinity\n        min_window_length = float('inf')\n        \n        # Initialize the left pointer of the sliding window\n        left = 0\n        \n        # Initialize a dictionary to store the frequency of characters in the current window\n        window_freq = {}\n        \n        # Initialize the number of unique characters in the current window\n        unique_chars_in_window = 0\n        \n        # Traverse the string with the right pointer of the sliding window\n        for right in range(n):\n            # Add the character at the right pointer to the window frequency dictionary\n            char = str[right]\n            if char in window_freq:\n                window_freq[char] += 1\n                if window_freq[char] == char_freq[char]:\n                    unique_chars_in_window += 1\n            else:\n                window_freq[char] = 1\n            \n            # While the window contains all unique characters, try to minimize the window\n            while unique_chars_in_window == total_unique_chars:\n                # Update the minimum window length\n                min_window_length = min(min_window_length, right - left + 1)\n                \n                # Remove the character at the left pointer from the window frequency dictionary\n                char = str[left]\n                window_freq[char] -= 1\n                if window_freq[char] < char_freq[char]:\n                    unique_chars_in_window -= 1\n                \n                # Move the left pointer to the right\n                left += 1\n        \n        # Return the minimum window length\n        return min_window_length if min_window_length!= float('inf') else 0\n```\n\nThis solution uses a sliding window approach with two pointers, `left` and `right`, to traverse the string. It maintains a dictionary `window_freq` to store the frequency of characters in the current window and another dictionary `char_freq` to store the frequency of characters in the entire string. The solution keeps track of the number of unique characters in the current window and updates the minimum window length whenever it finds a window that contains all unique characters. The time complexity of this solution is O(256.N) and the auxiliary space complexity is O(256), where N is the length of the input string."}]}