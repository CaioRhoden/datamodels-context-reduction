{"id": 21, "input": "You are given a tree T with n vertices (numbered 1 through n) and a letter in each vertex. The tree is rooted at vertex 1.\n\nLet's look at the subtree Tv of some vertex v. It is possible to read a string along each simple path starting at v and ending at some vertex in Tv (possibly v itself). Let's denote the number of distinct strings which can be read this way as <image>. \n\nAlso, there's a number cv assigned to each vertex v. We are interested in vertices with the maximum value of <image>.\n\nYou should compute two statistics: the maximum value of <image> and the number of vertices v with the maximum <image>.\n\nInput\n\nThe first line of the input contains one integer n (1 \u2264 n \u2264 300 000) \u2014 the number of vertices of the tree.\n\nThe second line contains n space-separated integers ci (0 \u2264 ci \u2264 109).\n\nThe third line contains a string s consisting of n lowercase English letters \u2014 the i-th character of this string is the letter in vertex i.\n\nThe following n - 1 lines describe the tree T. Each of them contains two space-separated integers u and v (1 \u2264 u, v \u2264 n) indicating an edge between vertices u and v.\n\nIt's guaranteed that the input will describe a tree.\n\nOutput\n\nPrint two lines. \n\nOn the first line, print <image> over all 1 \u2264 i \u2264 n. \n\nOn the second line, print the number of vertices v for which <image>.\n\nExamples\n\nInput\n\n10\n1 2 7 20 20 30 40 50 50 50\ncacabbcddd\n1 2\n6 8\n7 2\n6 2\n5 4\n5 9\n3 10\n2 5\n2 3\n\n\nOutput\n\n51\n3\n\n\nInput\n\n6\n0 2 4 1 1 1\nraaaba\n1 2\n2 3\n2 4\n2 5\n3 6\n\n\nOutput\n\n6\n2\n\nNote\n\nIn the first sample, the tree looks like this:\n\n<image>\n\nThe sets of strings that can be read from individual vertices are:\n\n<image>\n\nFinally, the values of <image> are:\n\n<image>\n\nIn the second sample, the values of <image> are (5, 4, 2, 1, 1, 1). The distinct strings read in T2 are <image>; note that <image> can be read down to vertices 3 or 4.\n", "difficulty": "VERY_HARD", "generations": [{"generated_text": "Here is a Python solution to the problem using depth-first search.\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.c = []\n        self.s = ''\n        self.g = defaultdict(list)\n        self.max_val = 0\n        self.max_cnt = 0\n        self.children = defaultdict(list)\n\n    def dfs(self, u, p):\n        self.children[u].append(p)\n        self.children[p].append(u)\n        cnt = 0\n        for v in self.children[u]:\n            if v!= p:\n                self.dfs(v, u)\n                cnt += 1\n        if cnt == 0:\n            self.max_val = 1\n            self.max_cnt = 1\n            self.children[u].append(u)\n            return\n\n        for v in self.children[u]:\n            if v!= p:\n                self.children[u].sort(key=lambda x: self.arr[x])\n                self.children[v].sort(key=lambda x: self.arr[x])\n                i = 0\n                j = 0\n                cur_cnt = 1\n                while i < len(self.children[u]) and j < len(self.children[v]):\n                    if self.arr[self.children[u][i]] < self.arr[self.children[v][j]]:\n                        cur_cnt *= (len(self.children[u]) - i)\n                        i += 1\n                    else:\n                        cur_cnt *= (len(self.children[v]) - j)\n                        j += 1\n                self.max_val = max(self.max_val, cur_cnt)\n                if self.max_val == cur_cnt:\n                    self.max_cnt = 1\n                elif self.max_val > cur_cnt:\n                    self.max_cnt = 0\n                else:\n                    self.max_cnt += 1\n                cur_cnt = 1\n                i = 0\n                j = 0\n                while i < len(self.children[u]) and j < len(self.children[v]):\n                    if self.arr[self.children[v][j]] < self.arr[self.children[u][i]]:\n                        cur_cnt *= (len(self.children[v]) - j)\n                        j += 1\n                    else:\n                        cur_cnt *= (len(self.children[u]) - i)\n                        i += 1\n                self.max_val = max(self.max_val, cur_cnt)\n                if self.max_val == cur_cnt:\n                    self.max_cnt = 1\n                elif self.max_val > cur_cnt:\n                    self.max_cnt = 0\n                else:\n                    self.max_cnt += 1\n\n    def solve(self):\n        self.n = int(input())\n        self.c = list(map(int, input().split()))\n        self.s = input()\n        self.arr = [-1] * (self.n + 1)\n        for i in range(self.n):\n            self.arr[i + 1] = ord(self.s[i]) - ord('a')\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.g[u].append(v)\n            self.g[v].append(u)\n        self.dfs(1, 0)\n        print(self.max_val)\n        print(self.max_cnt)\n\nif __name__ == '__main__':\n    solution = Solution()\n    solution.solve()\n```\nThis program first reads the input, then initializes the array `self.arr` to store the letters in each vertex. It uses a dictionary `self.children` to store the children of each vertex. The `dfs` function performs a depth-first search on the tree and calculates the maximum value of `cv` for each vertex. The `solve` function reads the input, calls the `dfs` function, and prints the maximum value and the number of vertices with the maximum value."}, {"generated_text": "To solve this problem, we will use a depth-first search (DFS) to traverse the tree and calculate the number of distinct strings that can be read from each vertex.\n\n```python\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(300000)\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj_list = [[] for _ in range(n)]\n        self.c = [0]*n\n        self.s = [0]*n\n        self.max_count = 0\n        self.max_count_vertices = 0\n        self.count_map = defaultdict(int)\n\n    def add_edge(self, u, v):\n        self.adj_list[u-1].append(v-1)\n        self.adj_list[v-1].append(u-1)\n\n    def dfs(self, u, parent, path):\n        self.c[u-1] = self.s[u-1]\n        self.count_map[\"\".join(path)] += 1\n        self.max_count = max(self.max_count, self.count_map[\"\".join(path)])\n        \n        for v in self.adj_list[u]:\n            if v!= parent:\n                path.append(self.s[v-1])\n                self.dfs(v, u, path)\n                path.pop()\n\n    def solve(self):\n        self.dfs(1, -1, [])\n        \n        max_count = self.max_count\n        for count in self.count_map.values():\n            if count == max_count:\n                self.max_count_vertices += 1\n\n        print(max_count)\n        print(self.max_count_vertices)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    self.c = [int(x) for x in input().split()]\n    self.s = input()\n    for _ in range(n-1):\n        u, v = [int(x) for x in input().split()]\n        g.add_edge(u, v)\n\n    g.solve()\n```\n\nIn the above code, we define a `Graph` class to represent the tree. The `add_edge` method is used to add edges to the graph, the `dfs` method is a recursive depth-first search function to traverse the tree and calculate the number of distinct strings that can be read from each vertex. The `solve` method is the main function to solve the problem.\n\nThis code first reads the input data, then creates a `Graph` object and adds edges to it. Finally, it calls the `solve` method to solve the problem.\n\nThe time complexity of this code is O(n * m), where n is the number of vertices and m is the number of edges. The space complexity is O(n), which is the space required to store the graph and the count map.\n\nNote that this code assumes that the input data is valid and does not contain any errors. In a real-world scenario, you should add error checking and handling code to handle potential errors."}, {"generated_text": "```python\nfrom collections import defaultdict\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, parent):\n    children = [i for i in graph[node] if i!= parent]\n    max_len = 0\n    for child in children:\n        max_len = max(max_len, dfs(child, node))\n    if node == 1:\n        max_len = len(string) - 1\n    elif parent == 0:\n        max_len = 1\n    dp[node][0] = max_len + 1\n    dp[node][1] = 1\n    for child in children:\n        dp[node][0] += dp[child][0]\n        dp[node][1] += dp[child][1]\n        if dp[child][0] == max_len:\n            dp[node][1] += dp[child][1]\n        elif dp[child][0] > max_len:\n            dp[node][1] = dp[child][1]\n            max_len = dp[child][0]\n    return max_len\n\ndef dfs2(node, parent, max_len):\n    children = [i for i in graph[node] if i!= parent]\n    if node == 1:\n        max_len = len(string) - 1\n    elif parent == 0:\n        max_len = 1\n    for child in children:\n        if dp[child][0] == max_len:\n            dfs2(child, node, max_len)\n        elif dp[child][0] > max_len:\n            max_len = dp[child][0]\n            dfs2(child, node, max_len)\n    count[node] = 1\n    for child in children:\n        if dp[child][0] == max_len:\n            count[node] += count[child]\n        elif dp[child][0] > max_len:\n            max_len = dp[child][0]\n            count[node] = count[child]\n            dfs2(child, node, max_len)\n\nn = int(input())\nci = list(map(int, input().split()))\nstring = input()\ngraph = defaultdict(list)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndp = [[0, 0] for _ in range(n + 1)]\ncount = [0] * (n + 1)\ndfs(1, 0)\nmax_len = 0\nfor i in range(n + 1):\n    max_len = max(max_len, dp[i][0])\ndfs2(1, 0, max_len)\nprint(max_len)\nprint(count[1])\n```\n\nThis solution works by first performing a depth-first search (DFS) to calculate the number of distinct strings that can be read from each vertex. It uses a dynamic programming approach to keep track of the maximum length of distinct strings that can be read from a subtree rooted at each vertex. \n\nAfter calculating the maximum length, it performs another DFS to count the number of vertices with the maximum length. The count is updated recursively as it traverses the tree.\n\nThe time complexity of this solution is O(n), where n is the number of vertices in the tree. The space complexity is also O(n) due to the use of the dynamic programming array and the graph data structure."}, {"generated_text": "Here's a Python program to solve the problem using DFS:\n\n```python\nfrom collections import defaultdict\nimport sys\n\nclass TreeNode:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n\nclass Tree:\n    def __init__(self):\n        self.n = 0\n        self.ci = []\n        self.s = ''\n        self.tree = defaultdict(list)\n        self.max_distinct_strings = 0\n        self.max_vertices = 0\n        self.max_distinct_strings_count = 0\n\n    def read_input(self):\n        self.n = int(input())\n        self.ci = list(map(int, input().split()))\n        self.s = input()\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.tree[u].append(v)\n            self.tree[v].append(u)\n\n    def dfs(self, node, parent, prefix, distinct_strings):\n        if self.max_distinct_strings < distinct_strings:\n            self.max_distinct_strings = distinct_strings\n            self.max_vertices = 1\n            self.max_distinct_strings_count = 1\n        elif self.max_distinct_strings == distinct_strings:\n            self.max_vertices += 1\n            self.max_distinct_strings_count += 1\n\n        for child in self.tree[node]:\n            if child!= parent:\n                self.dfs(child, node, prefix + self.s[child - 1], distinct_strings + 1 if self.s[child - 1] not in prefix else distinct_strings)\n\n    def solve(self):\n        self.dfs(1, -1, '', 0)\n        print(self.max_distinct_strings)\n        print(self.max_vertices)\n\ndef main():\n    t = Tree()\n    t.read_input()\n    t.solve()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a Tree class to represent the tree structure and a TreeNode class to represent individual nodes. The Tree class has methods to read input, perform DFS, and solve the problem. The DFS method is used to count the number of distinct strings that can be read from each subtree. The solve method is used to find the maximum number of distinct strings and the number of vertices with that maximum value."}, {"generated_text": "Here is a Python solution to the problem using a depth-first search (DFS) approach.\n\n```python\nfrom collections import defaultdict\nimport sys\n\nclass Node:\n    def __init__(self, value, parent=None, children=None):\n        self.value = value\n        self.parent = parent\n        self.children = children if children else []\n\ndef read_input():\n    n = int(input())\n    ci = list(map(int, input().split()))\n    s = input()\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    return n, ci, s, edges\n\ndef build_tree(n, edges):\n    tree = {}\n    for i in range(1, n + 1):\n        tree[i] = Node(i)\n    for u, v in edges:\n        tree[u].children.append(tree[v])\n        tree[v].children.append(tree[u])\n    return tree\n\ndef dfs(node, tree, ci, s):\n    children = [child for child in node.children]\n    if not children:\n        node.value = 1\n        return 1\n    max_value = 0\n    count = 0\n    for child in children:\n        child_value, child_count = dfs(child, tree, ci, s)\n        max_value = max(max_value, child_value)\n        count += child_count\n    node.value = max_value + 1\n    if max_value == node.value - 1:\n        count += 1\n    return node.value, count\n\ndef main():\n    n, ci, s, edges = read_input()\n    tree = build_tree(n, edges)\n    root = tree[1]\n    max_value, count = dfs(root, tree, ci, s)\n    print(max_value)\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis Python solution defines a `Node` class to represent each vertex in the tree. It reads the input data, builds the tree, and performs a DFS traversal to calculate the maximum value of `cv` and the count of vertices with the maximum value.\n\nThe DFS function recursively traverses the tree, updating the `value` attribute of each node with the maximum value of `cv` in its subtree. When a node has the maximum value, it increments the count.\n\nFinally, the solution prints the maximum value and the count of vertices with the maximum value.\n\nNote that this solution uses a depth-first search approach to avoid visiting the same subtree multiple times, which would lead to incorrect results."}, {"generated_text": "Here's a Python solution to the problem using a depth-first search (DFS) and a trie data structure:\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, string):\n        node = self.root\n        for char in string:\n            index = ord(char) - ord('a')\n            if node.children[index] is None:\n                node.children[index] = TrieNode()\n            node = node.children[index]\n            node.count += 1\n\n    def query(self, string):\n        node = self.root\n        for char in string:\n            index = ord(char) - ord('a')\n            if node.children[index] is None:\n                return 0\n            node = node.children[index]\n        return node.count\n\nclass Solution:\n    def __init__(self):\n        self.ans = 0\n        self.max_count = 0\n        self.counts = {}\n\n    def dfs(self, u, p, tree, c, s, trie):\n        node = trie.root\n        for i, char in enumerate(s[u-1]):\n            index = ord(char) - ord('a')\n            if i >= len(s[p-1]):\n                node = node.children[index]\n            else:\n                index2 = ord(s[p-1][i]) - ord('a')\n                if node.children[index2] is None:\n                    node.children[index2] = TrieNode()\n                node = node.children[index2]\n                node.count += trie.query(s[p-1][i+1:])\n        self.ans += node.count\n        self.counts[node.count] = self.counts.get(node.count, 0) + 1\n        if self.ans > self.max_count:\n            self.max_count = self.ans\n            self.max_count_nodes = 1\n        elif self.ans == self.max_count:\n            self.max_count_nodes += 1\n        for v in tree[u]:\n            if v!= p:\n                self.dfs(v, u, tree, c, s, trie)\n\n    def solve(self, n, c, s, edges):\n        tree = [[] for _ in range(n+1)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        trie = Trie()\n        for i in range(n):\n            trie.insert(s[i])\n        self.dfs(1, 0, tree, c, s, trie)\n        print(self.max_count)\n        print(self.max_count_nodes)\n\ndef main():\n    n = int(input())\n    c = list(map(int, input().split()))\n    s = input()\n    edges = []\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    solution = Solution()\n    solution.solve(n, c, s, edges)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution uses a depth-first search to traverse the tree and a trie data structure to store the strings. The trie is used to count the number of distinct strings that can be read from each vertex. The maximum value of the number of distinct strings is stored in `self.max_count` and the number of vertices with this maximum value is stored in `self.max_count_nodes`. The solution then prints `self.max_count` and `self.max_count_nodes`."}, {"generated_text": "Here is a Python program that will solve the problem.\n\n```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.c = []\n        self.s = \"\"\n        self.graph = defaultdict(list)\n\n    def read_input(self):\n        self.n = int(input())\n        self.c = list(map(int, input().split()))\n        self.s = input()\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n\n    def dfs(self, node: int, parent: int) -> int:\n        if node > 1:\n            self.c[node - 1] += 1\n        self.max_count[node] = 1\n        self.counts[node] = 1\n        self.letters[node] = self.s[node - 1]\n        for child in self.graph[node]:\n            if child!= parent:\n                self.max_count[node] = max(self.max_count[node], 1 + self.dfs(child, node))\n        return self.max_count[node]\n\n    def get_max_count(self) -> int:\n        self.max_count = [1] * self.n\n        self.counts = [1] * self.n\n        self.letters = [\"\"] * self.n\n        self.dfs(1, 0)\n        max_count = max(self.max_count)\n        return max_count\n\n    def get_vertices(self, max_count: int) -> List[int]:\n        self.max_count = [1] * self.n\n        self.counts = [1] * self.n\n        self.letters = [\"\"] * self.n\n        self.dfs(1, 0)\n        return [node + 1 for node in range(self.n) if self.max_count[node] == max_count]\n\n    def solve(self):\n        max_count = self.get_max_count()\n        vertices = self.get_vertices(max_count)\n        print(max_count)\n        print(len(vertices))\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    solution.read_input()\n    solution.solve()\n```\n\nIn the above code, we use a depth-first search (DFS) to calculate the maximum count of strings that can be read for each vertex. We store the maximum count and the count of each vertex in two separate lists. We then use these lists to find the maximum count and the number of vertices with this maximum count. \n\nThe `read_input` method reads the input from the standard input. The `dfs` method performs a DFS from a given node and returns the maximum count of strings that can be read. The `get_max_count` method calls the `dfs` method to calculate the maximum count for each vertex and returns the maximum count. The `get_vertices` method calls the `dfs` method to calculate the count of each vertex and returns the vertices with the maximum count. The `solve` method calls the `get_max_count` and `get_vertices` methods to solve the problem."}, {"generated_text": "To solve this problem, we can use a recursive approach along with depth-first search (DFS) traversal of the tree. Here's a Python solution for the given problem:\n\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.n = 0\n        self.ci = []\n        self.s = ''\n        self.max_val = 0\n        self.max_count = 0\n        self.count = 0\n\n    def read_input(self):\n        self.n = int(input())\n        self.ci = list(map(int, input().split()))\n        self.s = input()\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n\n    def dfs(self, node, parent, child_count, child_max, child_str):\n        self.child_count = child_count\n        self.child_max = child_max\n        self.child_str = child_str\n        self.child_count[node] = 1\n        self.child_max[node] = 1\n        self.child_str[node] = 1\n        for child in self.graph[node]:\n            if child!= parent:\n                self.dfs(child, node, self.child_count, self.child_max, self.child_str)\n\n        for child in self.graph[node]:\n            if child!= parent:\n                self.child_count[node] += self.child_count[child]\n                self.child_max[node] = max(self.child_max[node], self.child_max[child])\n                self.child_str[node] = max(self.child_str[node], self.child_str[child] + self.s[node - 1])\n\n        self.child_max[node] = max(self.child_max[node], self.child_str[node])\n\n    def solve(self):\n        self.child_count = [0] * (self.n + 1)\n        self.child_max = [0] * (self.n + 1)\n        self.child_str = [0] * (self.n + 1)\n        self.dfs(1, -1, self.child_count, self.child_max, self.child_str)\n\n        for i in range(1, self.n + 1):\n            self.max_val = max(self.max_val, self.child_max[i])\n\n        for i in range(1, self.n + 1):\n            if self.child_max[i] == self.max_val:\n                self.count += 1\n\n        print(self.max_val)\n        print(self.count)\n\nsolution = Solution()\nsolution.read_input()\nsolution.solve()\n```\n\nThis Python code first reads the input from the standard input and constructs the graph. It then performs a DFS traversal of the tree and updates the counts and maximum values of the subtrees. Finally, it prints the maximum value of the counts and the number of vertices with the maximum count.\n\nThis code assumes that the input is well-formed and does not contain any errors. It uses a recursive approach to solve the problem and uses a depth-first search (DFS) traversal of the tree."}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\nfrom collections import deque\n\ndef max_distinct_strings(n, ci, s, edges):\n    # Build the adjacency list\n    graph = [[] for _ in range(n+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Initialize the result\n    max_val = 0\n    max_count = 0\n\n    # Perform DFS\n    stack = deque([(1, s[0], 1, 1)])\n    parent = [-1] * (n+1)\n    distinct_strings = [set() for _ in range(n+1)]\n\n    while stack:\n        u, c, p, depth = stack.pop()\n        max_val = max(max_val, depth)\n        if u == p:\n            if len(distinct_strings[u]) == max_val:\n                max_count += 1\n        else:\n            distinct_strings[u].add(c)\n            for c2 in distinct_strings[p]:\n                distinct_strings[u].add(c + c2)\n\n        for v in graph[u]:\n            if v!= p:\n                stack.append((v, c, u, depth + 1))\n\n    return max_val, max_count\n\n\n# Input\nn = int(input())\nci = list(map(int, input().split()))\ns = input()\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Call the function\nmax_val, max_count = max_distinct_strings(n, ci, s, edges)\nprint(max_val)\nprint(max_count)\n```\n\nThis program performs a depth-first search (DFS) on the tree and keeps track of the maximum depth and the number of vertices with that maximum depth. The maximum depth is the maximum number of distinct strings that can be read along a simple path from the root vertex to a vertex in the subtree rooted at that vertex. The number of vertices with the maximum depth is the number of vertices for which the maximum value of the number of distinct strings is achieved."}, {"generated_text": "To solve this problem, we can use a depth-first search (DFS) approach. We will first build the tree from the given edges, and then perform a DFS traversal of the tree. During the DFS, we will keep track of the number of distinct strings that can be read from each vertex.\n\n```python\nclass Vertex:\n    def __init__(self, index, letter):\n        self.index = index\n        self.letter = letter\n        self.children = []\n        self.parent = None\n\ndef dfs(vertex, visited, children, max_distinct_strings, max_count):\n    visited.add(vertex.index)\n    max_distinct_strings[vertex.index] = 1\n    distinct_strings = {}\n\n    for child in vertex.children:\n        if child.index not in visited:\n            dfs(child, visited, children, max_distinct_strings, max_count)\n\n    for child in vertex.children:\n        if child.index in visited:\n            parent_index = child.parent.index\n            if parent_index not in distinct_strings:\n                distinct_strings[parent_index] = set()\n            distinct_strings[parent_index].add(vertex.letter + child.letter)\n\n    for child in vertex.children:\n        if child.index in visited:\n            max_distinct_strings[vertex.index] += max_distinct_strings[child.index]\n            for key, value in distinct_strings[child.index].items():\n                if key not in distinct_strings[parent_index]:\n                    distinct_strings[parent_index][key] = 0\n                distinct_strings[parent_index][key] += value\n\n    max_distinct_strings[vertex.index] = len(distinct_strings.get(parent_index, {})) + 1\n    if max_distinct_strings[vertex.index] > max_distinct_strings[max_count[0]]:\n        max_count[0] = vertex.index\n    elif max_distinct_strings[vertex.index] == max_distinct_strings[max_count[0]]:\n        max_count[1] += 1\n\ndef main():\n    n = int(input())\n    ci = list(map(int, input().split()))\n    s = input()\n    vertices = [Vertex(i, s[i-1]) for i in range(1, n+1)]\n\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        vertices[u-1].children.append(vertices[v-1])\n        vertices[v-1].children.append(vertices[u-1])\n        vertices[u-1].parent = vertices[v-1]\n        vertices[v-1].parent = vertices[u-1]\n\n    max_distinct_strings = [0] * (n + 1)\n    max_count = [0, 0]\n    visited = set()\n    dfs(vertices[0], visited, vertices, max_distinct_strings, max_count)\n\n    print(max(max_distinct_strings[1:]))\n    print(max_count[1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code first constructs the tree from the given edges, and then performs a DFS traversal of the tree. During the DFS, it keeps track of the number of distinct strings that can be read from each vertex. The maximum value of the number of distinct strings and the number of vertices with the maximum value are then printed.\n\nNote that the code uses a set to keep track of the visited vertices to avoid revisiting them. It also uses a dictionary to keep track of the distinct strings that can be read from each vertex. The maximum value of the number of distinct strings and the number of vertices with the maximum value are then updated accordingly."}, {"generated_text": "To solve this problem, we will use a recursive approach with a depth-first search (DFS) to traverse the tree. We will store the number of distinct strings for each vertex in a dictionary.\n\n```python\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            node = node.children[char]\n            node.count += 1\n\n    def dfs(self, node):\n        self.count = max(self.count, node.count)\n        for child in node.children.values():\n            self.dfs(child)\n\ndef main():\n    n = int(input())\n    c = list(map(int, input().split()))\n    s = input()\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    trie = Trie()\n    trie.insert(s)\n\n    def dfs(node, parent):\n        for child in graph[node]:\n            if child!= parent:\n                dfs(child, node)\n        trie.insert(s[node - 1] + trie.root.count * '')\n        trie.dfs(trie.root)\n        max_count = trie.count\n        ans.append(max_count)\n\n    ans = []\n    dfs(1, -1)\n    max_count = max(ans)\n    count = ans.count(max_count)\n    print(max_count)\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script works as follows:\n\n1.  It first reads the input, including the number of vertices `n`, the values `c`, the string `s`, and the edges of the graph.\n2.  It creates a Trie data structure to store the distinct strings.\n3.  It performs a DFS traversal of the graph, inserting the string for each vertex into the Trie and recursively traversing its children.\n4.  It keeps track of the maximum count of distinct strings and the number of vertices with this maximum count.\n5.  Finally, it prints the maximum count and the number of vertices with this maximum count."}, {"generated_text": "```python\nfrom collections import deque\nfrom string import ascii_lowercase\n\ndef dfs(u, p, adj, c, s):\n    \"\"\"\n    Depth-first search to calculate the number of distinct strings for each vertex.\n    \n    :param u: The current vertex.\n    :param p: The parent vertex.\n    :param adj: The adjacency list of the tree.\n    :param c: The count array.\n    :param s: The string representation of the tree.\n    \"\"\"\n    children = []\n    for v in adj[u]:\n        if v!= p:\n            children.append(v)\n            dfs(v, u, adj, c, s)\n            c[u] += c[v]\n    for v in children:\n        for ch in ascii_lowercase:\n            if s[v] == ch and s[u]!= ch:\n                c[u] += 1\n            elif s[v] == ch and s[u] == ch:\n                c[u] += c[v]\n\ndef max_strings(n, c, s, edges):\n    \"\"\"\n    Compute the maximum number of distinct strings and the number of vertices with the maximum number.\n    \n    :param n: The number of vertices.\n    :param c: The count array.\n    :param s: The string representation of the tree.\n    :param edges: The list of edges.\n    \"\"\"\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    dfs(1, -1, adj, c, s)\n    max_val = max(c[1:])\n    count = sum(1 for i in c[1:] if i == max_val)\n    print(max_val)\n    print(count)\n\ndef main():\n    n = int(input())\n    c = list(map(int, input().split()))\n    s = input()\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    max_strings(n, c, s, edges)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code uses a depth-first search (DFS) approach to calculate the number of distinct strings for each vertex. The DFS function recursively explores the tree, updating the count array `c` with the number of distinct strings for each vertex. The `max_strings` function computes the maximum number of distinct strings and the number of vertices with the maximum number. The `main` function reads the input and calls `max_strings` to compute the result."}, {"generated_text": "To solve this problem, we can use a depth-first search (DFS) to traverse the tree and calculate the number of distinct strings that can be read from each vertex. We will use a Trie data structure to efficiently count the number of distinct strings.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, s):\n        node = self.root\n        for c in s:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n            node.count += 1\n\n    def query(self, s):\n        node = self.root\n        for c in s:\n            if c not in node.children:\n                return 0\n            node = node.children[c]\n        return node.count\n\ndef max_value_and_count(tree, values, s, n):\n    trie = Trie()\n    trie.insert(s)\n\n    max_value = 0\n    max_count = 0\n    visited = [False] * (n + 1)\n\n    def dfs(node):\n        nonlocal max_value, max_count\n        visited[node] = True\n        value = trie.query(s[node - 1])\n        if value > max_value:\n            max_value = value\n            max_count = 1\n        elif value == max_value:\n            max_count += 1\n\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(1)\n    return max_value, max_count\n\ndef main():\n    n = int(input())\n    values = list(map(int, input().split()))\n    s = input()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n\n    max_value, max_count = max_value_and_count(tree, values, s, n)\n    print(max_value)\n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIn this code, we first read the input and create the tree data structure. We then use a Trie to efficiently count the number of distinct strings that can be read from each vertex. The `max_value_and_count` function performs a depth-first search (DFS) to traverse the tree and calculate the maximum value and count of vertices with the maximum value. Finally, we print the maximum value and count."}, {"generated_text": "To solve this problem, we will use a recursive depth-first search (DFS) traversal of the tree. During the traversal, we will keep track of the number of distinct strings that can be read for each vertex. We will also keep track of the maximum number of distinct strings that can be read for any vertex.\n\n```python\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, s):\n        node = self.root\n        for c in s:\n            node = node.children[c]\n            node.count += 1\n\ndef dfs(u, p, tree, s, trie):\n    # count the number of distinct strings that can be read for vertex u\n    node = trie.root\n    for i in range(len(s)):\n        if tree[u][i]!= p:\n            node = node.children[s[tree[u][i]]]\n            node.count += 1\n\n    # update the maximum number of distinct strings that can be read for any vertex\n    trie.max_count = max(trie.max_count, node.count)\n\n    # recursively count the number of distinct strings that can be read for all children of vertex u\n    for v in tree[u]:\n        if v!= p:\n            dfs(v, u, tree, s, trie)\n\ndef main():\n    n = int(input())\n    ci = list(map(int, input().split()))\n    s = input()\n    tree = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n\n    trie = Trie()\n    trie.max_count = 0\n    dfs(0, -1, tree, s, trie)\n\n    print(trie.max_count)\n    count = 0\n    for i in range(n):\n        node = trie.root\n        for j in range(len(s)):\n            if tree[i][j]!= -1:\n                node = node.children[s[tree[i][j]]]\n        if node.count == trie.max_count:\n            count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a Trie data structure to efficiently count the number of distinct strings that can be read for each vertex. The `dfs` function recursively traverses the tree and updates the Trie for each vertex. The maximum number of distinct strings that can be read for any vertex is stored in the `max_count` attribute of the Trie. Finally, the program counts the number of vertices for which the number of distinct strings that can be read is equal to the maximum number."}, {"generated_text": "To solve this problem, we need to perform a depth-first search on the tree and use dynamic programming to count the number of distinct strings that can be read from each vertex. We also need to keep track of the maximum value and the number of vertices that achieve this maximum value.\n\nHere is a Python program that solves the problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(u, parent, graph, ci, s, n):\n    children = []\n    for v in graph[u]:\n        if v!= parent:\n            children.append(v)\n            dfs(v, u, graph, ci, s, n)\n    \n    dp[u] = [1]\n    strings = {s[u - 1]}\n    for v in children:\n        dp[u].append(dp[v][-1] + 1)\n        strings |= set(s[v - 1] + c for c in s[u - 1])\n    \n    count[u] = len(strings)\n    if count[u] > max_count:\n        max_count = count[u]\n        max_count_vertices = [u]\n    elif count[u] == max_count:\n        max_count_vertices.append(u)\n\nn = int(input())\nci = list(map(int, input().split()))\ns = list(input())\ngraph = defaultdict(list)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndp = [0] * (n + 1)\ncount = [0] * (n + 1)\nmax_count = 0\nmax_count_vertices = []\n\ndfs(1, 0, graph, ci, s, n)\n\nprint(max_count)\nprint(len(max_count_vertices))\n```\n\nThis program first reads the input and initializes the graph and other data structures. Then it performs a depth-first search on the tree, using dynamic programming to count the number of distinct strings that can be read from each vertex. Finally, it prints the maximum value and the number of vertices that achieve this maximum value."}, {"generated_text": "To solve this problem, we will use a depth-first search (DFS) traversal of the tree and a hash set to keep track of unique strings. We will also use a dictionary to store the maximum value of distinct strings and the number of vertices with this maximum value.\n\nHere is the Python code for the problem:\n\n```python\nfrom collections import defaultdict\nfrom sys import stdin, stdout\n\ndef dfs(graph, vertex, parent, s, ci, visited, unique_strings, max_distinct_strings, max_count):\n    visited[vertex] = True\n    unique_strings[vertex] = set([s[vertex - 1]])\n    max_distinct_strings[vertex] = 1\n    count = 1\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            child_s = s[vertex - 1] + s[neighbor - 1]\n            dfs(graph, neighbor, vertex, child_s, ci, visited, unique_strings, max_distinct_strings, max_count)\n            unique_strings[vertex].update(unique_strings[neighbor])\n            max_distinct_strings[vertex] += max_distinct_strings[neighbor]\n            count += max_count[neighbor]\n    max_distinct_strings[vertex] += ci[vertex - 1]\n    count += 1\n    if max_distinct_strings[vertex] > max_distinct_strings[1]:\n        max_distinct_strings[1] = max_distinct_strings[vertex]\n        max_count[1] = count\n    elif max_distinct_strings[vertex] == max_distinct_strings[1]:\n        max_count[1] += count\n\ndef main():\n    n = int(stdin.readline())\n    ci = list(map(int, stdin.readline().split()))\n    s = stdin.readline().strip()\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    unique_strings = defaultdict(set)\n    max_distinct_strings = defaultdict(int)\n    max_count = defaultdict(int)\n    dfs(graph, 1, 0, \"\", ci, visited, unique_strings, max_distinct_strings, max_count)\n    stdout.write(str(max_distinct_strings[1]) + \"\\n\")\n    stdout.write(str(max_count[1]) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIn this code, we first read the input and create an adjacency list representation of the graph. We then perform a DFS traversal of the graph, keeping track of the unique strings that can be read from each vertex and the maximum value of distinct strings. Finally, we print the maximum value of distinct strings and the number of vertices with this maximum value."}, {"generated_text": "```python\nfrom collections import deque\nfrom typing import Dict, List\n\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.c = []\n        self.s = \"\"\n        self.adj = [[] for _ in range(300001)]\n        self.hashed_strings = {}\n\n    def read_input(self):\n        self.n = int(input())\n        self.c = [0] + list(map(int, input().split()))\n        self.s = input()\n        for _ in range(self.n - 1):\n            u, v = map(int, input().split())\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n\n    def dfs(self, u: int, p: int) -> Dict[str, List[int]]:\n        \"\"\"Return a dictionary of hashed strings and their counts\"\"\"\n        result = {'': 1}\n        for v in self.adj[u]:\n            if v == p:\n                continue\n            child_result = self.dfs(v, u)\n            for string, count in list(child_result.items()):\n                for i in range(len(string)):\n                    new_string = string[:i] + string[i+1:]\n                    result[new_string] = result.get(new_string, 0) + count\n        return result\n\n    def solve(self):\n        result = self.dfs(1, -1)\n        max_count = max(result.values())\n        count_max_count = sum(count == max_count for count in result.values())\n\n        print(max_count)\n        print(count_max_count)\n\nsolution = Solution()\nsolution.read_input()\nsolution.solve()\n```\n\nThis Python program reads the input, performs a depth-first search on the tree to count the number of distinct strings at each vertex, and then prints the maximum count and the number of vertices with the maximum count.\n\nThe `dfs` method recursively visits each vertex in the tree, and for each vertex, it counts the number of distinct strings that can be read by traversing the subtree rooted at that vertex. The counts are stored in a dictionary, where the keys are the hashed strings and the values are the counts. The maximum count and the number of vertices with the maximum count are then calculated from this dictionary.\n\nNote that this solution uses a recursive approach to perform the depth-first search. The recursion is necessary to handle the case where a vertex has a large number of children, and the tree is very deep. If the tree is very deep, a recursive solution may exceed the maximum recursion depth. In such cases, an iterative solution using a stack may be necessary."}, {"generated_text": "Here's a Python program that uses Depth-First Search (DFS) and memoization to solve the problem.\n\n```python\nfrom collections import defaultdict\nfrom typing import Dict\n\ndef main():\n    n = int(input())\n    ci = list(map(int, input().split()))\n    s = input()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_freq = 0\n    max_vertices = 0\n    subtree_freqs: Dict[int, int] = {1: 1}\n    parent_freqs: Dict[int, int] = {1: 0}\n    visited = set()\n    dfs(1, 1, ci, s, adj, visited, subtree_freqs, parent_freqs, max_freq, max_vertices)\n\n    print(max_freq)\n    print(max_vertices)\n\n\ndef dfs(v: int, parent: int, ci: list, s: str, adj: Dict[int, list], visited: set, subtree_freqs: Dict[int, int], parent_freqs: Dict[int, int], max_freq: int, max_vertices: int) -> None:\n    visited.add(v)\n    for u in adj[v]:\n        if u not in visited:\n            dfs(u, v, ci, s, adj, visited, subtree_freqs, parent_freqs, max_freq, max_vertices)\n\n    freq = 1\n    for u in adj[v]:\n        if u in visited:\n            freq = max(freq, parent_freqs[u] + 1)\n\n    subtree_freqs[v] = freq\n    max_freq = max(max_freq, freq)\n\n    if freq == max_freq:\n        max_vertices += 1\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program first reads the input and constructs an adjacency list for the tree. It then uses DFS to traverse the tree, calculating the maximum frequency of strings that can be read from each subtree. The frequency is calculated by recursively traversing the subtree and keeping track of the maximum frequency encountered so far. If the current subtree has a maximum frequency equal to the overall maximum frequency, it increments the count of vertices with the maximum frequency. The program finally prints the maximum frequency and the count of vertices with the maximum frequency."}, {"generated_text": "Here is the Python code that solves the problem:\n```python\nfrom collections import deque\nimport sys\n\ndef dfs(node, parent, tree, letters, children):\n    children[node].append(parent)\n    for child in children[node]:\n        dfs(child, node, tree, letters, children)\n    tree[node] = [1, letters[node-1]]\n    for child in children[node]:\n        subtree = tree[child]\n        if len(subtree) > 1:\n            max_len = max(subtree)\n            tree[node][0] += max_len[0] * (max_len[1]!= subtree[1])\n        else:\n            tree[node][0] += tree[child][0]\n\ndef main():\n    n = int(input())\n    ci = list(map(int, input().split()))\n    letters = list(input())\n    tree = [[0, ''] for _ in range(n)]\n    children = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        children[u-1].append(v-1)\n        children[v-1].append(u-1)\n\n    dfs(0, -1, tree, letters, children)\n\n    max_count = max(tree, key=lambda x: x[0])[0]\n    max_count_vertices = sum(1 for x in tree if x[0] == max_count)\n\n    print(max_count)\n    print(max_count_vertices)\n\nif __name__ == \"__main__\":\n    main()\n```\nThis code uses a depth-first search (DFS) to traverse the tree, keeping track of the number of distinct strings that can be read from each subtree. It uses a separate array `children` to store the children of each node. The DFS function `dfs` updates the `tree` array with the number of distinct strings that can be read from each subtree. The `main` function reads the input, calls the `dfs` function, and prints the maximum count and the number of vertices with the maximum count.\n\nNote that this code assumes that the input is well-formed and does not contain any errors. In a real-world setting, you would want to add error checking and handling code to deal with potential issues."}, {"generated_text": "To solve this problem, we'll use an approach known as depth-first search (DFS) to traverse the tree and compute the number of distinct strings that can be read from each vertex. We'll use a dictionary to store the parent of each vertex and a dictionary to store the adjacency list of the tree.\n\nHere's the Python code to solve the problem:\n\n```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, c, s, adj, ans, max_val, max_count):\n    # Base case\n    if node not in adj:\n        ans[node] = 1\n        max_val[node] = 1\n        max_count[node] = 1\n        return\n\n    # Initialize variables\n    cnt = defaultdict(int)\n    max_cnt = 0\n    for child in adj[node]:\n        if child!= parent:\n            dfs(child, node, c, s, adj, ans, max_val, max_count)\n            cnt[max_val[child]] += 1\n            max_cnt = max(max_cnt, max_val[child])\n\n    # Compute the number of distinct strings\n    max_val[node] = 1\n    for i in range(1, max_cnt + 1):\n        if i in cnt:\n            max_val[node] *= (cnt[i] + 1)\n            max_val[node] //= (cnt[i] + 1 - 1)\n    ans[node] = max_val[node]\n\n    # Count the number of vertices with the maximum value\n    if max_val[node] == max_val[parent]:\n        max_count[node] += 1\n    max_count[node] = max(max_count[node], max_count[parent])\n\ndef solve():\n    n = int(input())\n    c = list(map(int, input().split()))\n    s = input()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Initialize variables\n    ans = {}\n    max_val = {}\n    max_count = {}\n    dfs(1, 0, c, s, adj, ans, max_val, max_count)\n\n    # Print the maximum value and the number of vertices\n    print(max(max_val.values()))\n    print(max(max_count.values()))\n\nsolve()\n```\n\nIn this code, we first read the input and initialize the data structures. Then we use a recursive DFS function to traverse the tree and compute the number of distinct strings that can be read from each vertex. Finally, we print the maximum value and the number of vertices with the maximum value.\n\nThe time complexity of this code is O(n), where n is the number of vertices in the tree. The space complexity is also O(n) due to the recursion stack and the data structures used."}]}