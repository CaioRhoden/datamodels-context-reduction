{"id": 6, "input": "Given a number s(in string form). Find the Smallest number (Not leading Zeros) which can be obtained by rearranging the digits of given number.\n \nExample 1:\nInput: s = \"846903\"\nOutput: 304689\nExplanation: 304689 is the smallest number\nby rearranging the digits.\nExample 2:\nInput: s = \"55010\"\nOutput: 10055\nExplanation: 10055 is the smallest number \nby rearranging the digts.\n \nYour Task:\nYou don't need to read or print anything. Your task is to complete the function minimum_number() which takes the number as input parameter and returns the smallest number than can be formed without leading zeros by rearranging the digits of the number.\n \nExpected Time Complexity: O(N * log(N)) where N is the number of digits of the given number\nExpected Space Complexity: O(1)\n \nConstraints:\n1 <= N <= 10^{5}\n#User function Template for python3\n\n\n\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\n\t\t# Code here", "difficulty": "EASY", "generations": [{"generated_text": "Here's the Python function that solves the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        # Convert string to list of integers\n        digits = [int(x) for x in s]\n        \n        # Sort the list in ascending order\n        digits.sort()\n        \n        # Initialize result string\n        result = ''\n        \n        # Initialize flag to track if we have a zero at the beginning\n        has_zero = False\n        \n        # Iterate through the sorted list\n        for digit in digits:\n            # If the digit is not zero or we already have a zero at the beginning, append it to the result\n            if digit!= 0 or has_zero:\n                result += str(digit)\n                # If the digit is zero and we don't have a zero at the beginning, set the flag to True\n                if digit == 0:\n                    has_zero = True\n            # If the digit is zero and we already have a zero at the beginning, skip it\n        \n        # If the result is empty (i.e., all zeros), return '0'\n        if not result:\n            return '0'\n        \n        # Return the result as an integer\n        return int(result)\n```\n\nThis function works by first converting the input string to a list of integers. It then sorts this list in ascending order. After that, it iterates through the sorted list and appends each digit to the result string, except for zeros. If a zero is encountered and we don't have a zero at the beginning, we set a flag to True. If we have a zero at the beginning and a zero is encountered, we skip it. Finally, we return the result string as an integer."}, {"generated_text": "Here's a Python function that will generate the smallest possible number without leading zeros by rearranging the digits of the given number:\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Count the frequency of each digit\n        count = [0] * 10\n        for c in s:\n            count[int(c)] += 1\n\n        # Initialize the result and the index\n        res = []\n        index = 0\n\n        # Process each non-zero digit\n        while index < 9 and count[index] > 0:\n            for _ in range(count[index]):\n                res.append(str(index))\n            index += 1\n\n        # Process the remaining digits\n        for i in range(index, 10):\n            for _ in range(count[i]):\n                res.append(str(i))\n\n        # Convert the list to a string and return\n        return int(''.join(res))\n```\n\nThis function works by first counting the frequency of each digit in the input string. Then, it iterates over the digits from 1 to 9, appending each digit to the result as many times as it appears in the input string. Finally, it appends the remaining digits to the result and returns the result as an integer.\n\nThis solution has a time complexity of O(N) and a space complexity of O(1), where N is the number of digits in the input string."}, {"generated_text": "To solve this problem, we will use the concept of counting the frequency of each digit and then arranging them in ascending order. However, we need to make sure that the first digit is not zero.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        # Count the frequency of each digit\n        freq = [0] * 10\n        for char in s:\n            freq[int(char)] += 1\n\n        # Initialize the result string\n        res = ''\n\n        # Add the smallest non-zero digit\n        for i in range(1, 10):\n            if freq[i] > 0:\n                res += str(i) * freq[i]\n                break\n\n        # Add the rest of the digits in ascending order\n        for i in range(10):\n            if i == 0 and freq[i] > 0:\n                continue\n            res += str(i) * freq[i]\n\n        return int(res)\n```\n\nThis code works by first counting the frequency of each digit in the input string. Then, it initializes an empty result string. It adds the smallest non-zero digit to the result string and then adds the rest of the digits in ascending order. The result is returned as an integer.\n\nThe time complexity of this code is O(N * log(N)) where N is the number of digits of the given number, because we are iterating over the input string and the digits are stored in an array of size 10. The space complexity is O(1) because we are using a fixed amount of space to store the frequency array and the result string."}, {"generated_text": "Here is the Python code that meets the requirements:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        # Convert string to list for easier manipulation\n        s = list(s)\n        \n        # Sort the list in ascending order\n        s.sort()\n        \n        # Initialize an empty string to store the result\n        result = \"\"\n        \n        # Initialize a flag to track if the result has a leading zero\n        has_zero = False\n        \n        # Iterate over the sorted list\n        for char in s:\n            # If the character is '0' and the result is empty, skip it\n            if char == '0' and not result:\n                continue\n            # Append the character to the result\n            result += char\n            # If the character is '0', set the flag to True\n            if char == '0':\n                has_zero = True\n        # If the result starts with a zero and the input string has more than one digit, remove the leading zero\n        if len(result) > 1 and result[0] == '0':\n            result = result[1:]\n        # Return the result as a string\n        return result\n```\n\nThis code sorts the digits of the input number in ascending order, then iterates over the sorted list, appending each digit to the result string. If a digit is '0' and the result string is empty, it skips that digit. If the result string starts with '0' and has more than one digit, it removes the leading zero. The result is then returned as a string.\n\nThe time complexity of this code is O(N log N) due to the sorting step, where N is the number of digits in the input number. The space complexity is O(N), as we need to store the sorted list of digits.\n\nExample use cases:\n\n```python\nsolution = Solution()\nprint(solution.minimum_Number(\"846903\"))  # Output: \"304689\"\nprint(solution.minimum_Number(\"55010\"))  # Output: \"10055\"\n```"}, {"generated_text": "To solve this problem, we can use the concept of counting sort to count the frequency of each digit in the given string. Then we can create a list of digits in descending order, replacing zeros with the smallest available non-zero digit. Finally, we can join the digits together to form the smallest possible number.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n\n        # Create a dictionary to store the frequency of each digit\n        freq = {}\n        for char in s:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n\n        # Create a list of digits in descending order\n        digits = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\n        # Create a list of non-zero digits in descending order\n        non_zero_digits = [digit for digit, count in digits if digit!= '0']\n\n        # Replace zeros with the smallest available non-zero digit\n        for i in range(len(s)):\n            if s[i] == '0':\n                for digit in non_zero_digits:\n                    if freq[digit] > 0:\n                        s = s[:i] + digit + s[i+1:]\n                        freq[digit] -= 1\n                        break\n\n        # Join the digits together to form the smallest possible number\n        return int(''.join(s))\n```\n\nThis solution has a time complexity of O(N * log(N)) because we are sorting the digits in descending order, and a space complexity of O(1) because we are using a constant amount of space to store the frequency of each digit."}, {"generated_text": "To solve this problem, we can use the concept of counting the frequency of each digit in the given string and then sorting them in ascending order while making sure that the digit '0' is placed at the end if it appears more than once.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Count the frequency of each digit\n        count = [0] * 10\n        for char in s:\n            count[int(char)] += 1\n\n        # Initialize the result string\n        result = ''\n\n        # Add non-zero digits to the result string\n        for i in range(1, 10):\n            if count[i] > 0:\n                result += str(i) * count[i]\n\n        # Add the remaining zero digits to the end of the result string\n        if count[0] > 0:\n            result += '0' * count[0]\n\n        # If the result string starts with '0' and has more than one character, remove the first character\n        if len(result) > 1 and result[0] == '0':\n            result = result[1:]\n\n        return int(result)\n```\n\nThis code works by first counting the frequency of each digit in the given string. Then it constructs the smallest possible number by adding non-zero digits in ascending order, followed by the remaining zero digits. Finally, it checks if the resulting string starts with '0' and has more than one character, and if so, it removes the first character to ensure that the result string does not start with '0'."}, {"generated_text": "Here's a Python function that uses counting sort to find the smallest number that can be obtained by rearranging the digits of a given number.\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Count the frequency of each digit\n        count = [0] * 10\n        for c in s:\n            count[int(c)] += 1\n        \n        # Sort the digits to find the smallest number\n        sorted_digits = sorted(str(i) for i in range(10) if count[i])\n        \n        # Special handling for the case when there's a '0' in the middle\n        if sorted_digits[0] == '0':\n            zero_index = sorted_digits.index('0')\n            smallest_num = int(''.join(sorted_digits[:zero_index] + sorted_digits[zero_index+1:] + ['0']))\n        else:\n            smallest_num = int(''.join(sorted_digits))\n        \n        return smallest_num\n```\n\nThis function works by first counting the frequency of each digit in the input string. It then sorts the digits to find the smallest number that can be obtained by rearranging them. If there's a '0' in the middle of the sorted digits, it needs to be handled separately to avoid leading zeros. The smallest number is then constructed by joining the sorted digits together.\n\nThe time complexity of this function is O(N * log(N)) where N is the number of digits in the input string, because the sorting operation takes O(N * log(N)) time in the worst case. The space complexity is O(1) because the space used does not grow with the size of the input string."}, {"generated_text": "Here's a Python solution for the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        # Convert the string into a list of integers for easier sorting\n        digits = [int(d) for d in s]\n        \n        # Sort the list of digits in ascending order\n        digits.sort()\n        \n        # Initialize the result string\n        result = ''\n        \n        # Initialize a flag to track if we've seen a zero\n        seen_zero = False\n        \n        # Iterate over the sorted list of digits\n        for digit in digits:\n            # If we've seen a zero and the current digit is zero, skip it\n            if seen_zero and digit == 0:\n                continue\n            # Otherwise, add the digit to the result string\n            result += str(digit)\n            # If the current digit is zero, set the flag to True\n            if digit == 0:\n                seen_zero = True\n        \n        # If the result string is empty, it means all digits were zeros\n        if not result:\n            return '0'\n        \n        # Return the result string as an integer\n        return int(result)\n```\n\nThis solution works by first converting the input string into a list of integers, sorting the list in ascending order, and then iterating over the sorted list to construct the smallest possible number. It uses a flag to keep track of whether a zero has been seen, so that it can be skipped in the result string if it appears after a non-zero digit. The time complexity of this solution is O(N * log(N)) due to the sorting, where N is the number of digits in the input string. The space complexity is O(1) because we're not using any additional space that scales with the input size."}, {"generated_text": "To solve this problem, we need to first count the frequency of each digit in the given string. Then, we will sort the digits in ascending order while considering the constraints of the problem.\n\nHere's the Python code that implements this:\n\n```python\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\t\t# Count the frequency of each digit\n\t\tdigit_count = [0] * 10\n\t\tfor digit in s:\n\t\t\tdigit_count[int(digit)] += 1\n\n\t\t# Sort the digits while considering the constraints\n\t\tmin_num = []\n\t\tfor i in range(1, 10):\n\t\t\tmin_num.extend([str(i)] * digit_count[i])\n\t\tif digit_count[0] > 0 and min_num[0] == '0':\n\t\t\tmin_num.insert(0, '0')\n\n\t\t# Join the sorted digits to form the smallest number\n\t\treturn ''.join(min_num)\n```\n\nIn this code, we first count the frequency of each digit in the given string. Then, we sort the digits in ascending order while considering the constraints of the problem. We use a list to store the sorted digits and then join them to form the smallest number.\n\nThe time complexity of this code is O(N * log(N)) where N is the number of digits of the given number. This is because we are sorting the digits, which takes O(N * log(N)) time in Python's built-in sorting function. The space complexity is O(1), which means the space required does not change with the size of the input."}, {"generated_text": "Here's a Python solution that uses counting sort and a custom sorting function to achieve the desired time complexity and space complexity.\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        count = [0] * 10\n        \n        # Count the occurrences of each digit\n        for char in s:\n            count[int(char)] += 1\n        \n        # Sort the digits in ascending order, except for 0\n        # Since we want to keep 0 at the end, we put all non-zero digits first\n        # and then the zeros\n        for i in range(1, 10):\n            while count[i] > 0:\n                s = s[:i] + s[i:].replace(str(i), '', 1) + str(i)\n                count[i] -= 1\n        \n        # Remove any leading zeros\n        while s and s[0] == '0':\n            s = s[1:]\n        \n        return s\n```\n\nHere's an explanation of how the code works:\n\n1. We first count the occurrences of each digit in the input string.\n2. We then sort the digits in ascending order, except for 0. We put all non-zero digits first and then the zeros. This is because we want to keep 0 at the end of the sorted string.\n3. We use a custom sorting function to achieve this. We replace each non-zero digit with its sorted position in the string.\n4. Finally, we remove any leading zeros from the sorted string.\n\nThis solution has a time complexity of O(N * log(N)) because we are using a custom sorting function to sort the digits. The space complexity is O(1) because we are using a fixed amount of space to store the count of each digit.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.minimum_Number(\"846903\"))  # Output: 304689\nprint(solution.minimum_Number(\"55010\"))  # Output: 10055\n```"}, {"generated_text": "To solve this problem, we can use a sorting approach. The idea is to first count the frequency of each digit, then sort the digits based on their frequency and value. We will use a stable sorting algorithm like Timsort (Python's default sorting algorithm) which maintains the relative order of equal elements. Finally, we will construct the smallest number by concatenating the sorted digits.\n\nHowever, to avoid leading zeros, we need to handle the case where there are multiple zeros in the number. In this case, we will move all non-zero digits to the front and then append the zeros.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\n\t\t# Count the frequency of each digit\n\t\tcount = [0] * 10\n\t\tfor num in s:\n\t\t\tcount[int(num)] += 1\n\n\t\t# Sort the digits based on their frequency and value\n\t\tsort = []\n\t\tfor i in range(9, -1, -1):\n\t\t\tsort.extend([str(i)] * count[i])\n\n\t\t# Handle the case where there are multiple zeros in the number\n\t\tif count[0] > 1:\n\t\t\tsort = ['0'] * (count[0] - 1) + sort\n\n\t\t# Construct the smallest number\n\t\treturn ''.join(sort)\n```\n\nThis code first counts the frequency of each digit in the input number `s`. Then it sorts the digits based on their frequency and value. If there are multiple zeros in the number, it moves all non-zero digits to the front and then appends the zeros. Finally, it constructs the smallest number by concatenating the sorted digits.\n\nThe time complexity of this code is O(N * log(N)), where N is the number of digits of the given number. This is because the sorting step takes O(N * log(N)) time. The space complexity is O(1), as the space usage does not depend on the input size."}, {"generated_text": "Here is the Python program to solve the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        # Convert the string into a list of digits for easier manipulation\n        digits = [int(i) for i in s]\n        \n        # Sort the list of digits in ascending order\n        digits.sort()\n        \n        # If the smallest digit is 0, find the smallest position to place it\n        if digits[0] == 0:\n            # Initialize the index of the first non-zero digit\n            first_non_zero = 0\n            \n            # Find the first non-zero digit\n            while first_non_zero < len(digits) and digits[first_non_zero] == 0:\n                first_non_zero += 1\n            \n            # Swap the smallest digit with the first non-zero digit\n            digits[0], digits[first_non_zero] = digits[first_non_zero], digits[0]\n        \n        # Join the sorted digits back into a string and return\n        return ''.join(map(str, digits))\n```\n\n**Explanation:**\n\n1. First, we convert the input string into a list of digits for easier manipulation.\n2. Then, we sort the list of digits in ascending order.\n3. If the smallest digit is 0, we find the smallest position to place it to avoid leading zeros.\n4. We swap the smallest digit with the first non-zero digit to get the smallest possible number.\n5. Finally, we join the sorted digits back into a string and return it.\n\n**Example Use Cases:**\n\n```python\nsolution = Solution()\nprint(solution.minimum_Number(\"846903\"))  # Output: 304689\nprint(solution.minimum_Number(\"55010\"))  # Output: 10055\n```\n\n**Time Complexity:** O(N * log(N)) where N is the number of digits of the given number.\n\n**Space Complexity:** O(1) as we are only using a constant amount of space to store the list of digits and the indices."}, {"generated_text": "Here's the Python code to find the smallest number that can be obtained by rearranging the digits of a given number without leading zeros:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n        n = len(s)\n        count = [0] * 10\n        for i in range(n):\n            count[int(s[i])] += 1\n\n        # Count the number of zeros at the end\n        zeros_at_end = 0\n        while n > 0 and s[n - 1] == '0':\n            zeros_at_end += 1\n            n -= 1\n\n        ans = ''\n        for i in range(9, -1, -1):\n            if count[i] > 0:\n                ans += str(i) * min(count[i], n - zeros_at_end)\n            n -= min(count[i], n - zeros_at_end)\n\n        # Add the remaining zeros to the end\n        ans += '0' * zeros_at_end\n\n        return ans\n```\n\nThis solution first counts the frequency of each digit. Then it constructs the smallest number by iterating over the digits from 9 to 0. For each digit, it adds it to the answer string as many times as it appears in the input string and there are available positions left. Finally, it adds the remaining zeros to the end of the answer string.\n\nThe time complexity of this solution is O(N * log(N)) where N is the number of digits of the given number, and the space complexity is O(1)."}, {"generated_text": "Here's the Python solution for the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n\n        # Convert the string to a list of digits\n        digits = sorted(s)\n        \n        # Initialize an empty string to store the result\n        result = \"\"\n        \n        # Initialize a flag to track if the first digit is zero\n        first_digit_is_zero = False\n        \n        # Iterate over the sorted digits\n        for digit in digits:\n            # If the result is empty or the current digit is not zero, append it to the result\n            if not result or digit!= '0':\n                result += digit\n            # If the current digit is zero and the first digit of the result is not zero, append it to the result\n            elif first_digit_is_zero:\n                result += digit\n            # If the current digit is zero and the first digit of the result is zero, set the flag to True\n            else:\n                first_digit_is_zero = True\n        \n        # Return the result\n        return int(result)\n```\n\nThis solution first sorts the digits in ascending order. Then, it iterates over the sorted digits and appends them to the result string. If a digit is zero and the first digit of the result is also zero, it sets a flag to True. If a digit is not zero or the first digit of the result is not zero, it appends the digit to the result. Finally, it returns the result as an integer.\n\nThis solution has a time complexity of O(N log N) due to the sorting operation, where N is the number of digits in the input string. The space complexity is O(N) for storing the sorted digits and the result string."}, {"generated_text": "To solve this problem, we can use a greedy approach along with sorting. The idea is to sort the digits in ascending order and then handle the zeros separately. Here's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def minimum_Number(self, s):\n\n        # Convert the string to a list of digits\n        digits = [int(x) for x in s]\n        \n        # Sort the digits in ascending order\n        digits.sort()\n        \n        # Initialize an empty string to store the result\n        result = ''\n        \n        # Initialize a flag to track if a non-zero digit has been encountered\n        non_zero_encountered = False\n        \n        # Iterate over the sorted digits\n        for digit in digits:\n            # If the digit is not zero, add it to the result and set the flag to True\n            if digit!= 0:\n                result += str(digit)\n                non_zero_encountered = True\n            # If the digit is zero and a non-zero digit has been encountered, add it to the result\n            elif non_zero_encountered:\n                result += str(digit)\n        \n        # If the result is empty (i.e., all digits were zeros), return 0\n        if not result:\n            return 0\n        # Otherwise, return the result\n        else:\n            return int(result)\n```\n\nThis solution works by first sorting the digits in ascending order. Then, it iterates over the sorted digits and adds them to the result string. If a non-zero digit is encountered, it sets a flag to True and adds the digit to the result. If a zero is encountered after a non-zero digit has been encountered, it adds the zero to the result. If all digits were zeros, it returns 0. Otherwise, it returns the result as an integer.\n\nThis solution has a time complexity of O(N * log(N)) due to the sorting operation, where N is the number of digits in the input string. The space complexity is O(1) since we're not using any data structures that grow with the input size."}, {"generated_text": "To solve this problem, we can use a greedy approach. The idea is to sort the digits in ascending order and then append them to the result. However, we need to handle the case where there are multiple zeros, because a leading zero would make the number larger than necessary.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Convert the input string into a list of digits\n        digits = [int(i) for i in s]\n        \n        # Sort the digits in ascending order\n        digits.sort()\n        \n        # Initialize the result\n        result = ''\n        \n        # Check if there is at least one non-zero digit\n        non_zero_found = False\n        for digit in digits:\n            if digit!= 0:\n                result += str(digit)\n                non_zero_found = True\n                break\n        \n        # If all digits are zeros, the result should be 0\n        if not non_zero_found:\n            result = '0'\n        \n        # Append the remaining digits to the result\n        for digit in digits:\n            if digit!= 0:\n                result += str(digit)\n        \n        return int(result)\n```\n\nThis code works by first converting the input string into a list of digits. It then sorts the digits in ascending order. The result is initialized as an empty string. It then checks if there is at least one non-zero digit in the list. If there is, it appends that digit to the result and sets a flag to indicate that a non-zero digit has been found. If all digits are zeros, the result should be 0, so it sets the result to '0'. Finally, it appends the remaining digits to the result and returns the result as an integer.\n\nThis solution has a time complexity of O(N log N) due to the sorting step, where N is the number of digits in the input string. The space complexity is O(N) because we need to store the list of digits."}, {"generated_text": "Here's a Python solution for the given problem. This program uses counting sort to count the frequency of each digit and then constructs the smallest possible number without leading zeros.\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Create a list to store the frequency of each digit\n        freq = [0] * 10\n        \n        # Count the frequency of each digit\n        for num in s:\n            freq[int(num)] += 1\n        \n        # Initialize the result string\n        res = ''\n        \n        # Add 0's to the end of the result string if the first digit is 0\n        if freq[0] > 0:\n            for _ in range(freq[0] - 1):\n                res += '0'\n        \n        # Add the smallest digits to the result string\n        for i in range(1, 10):\n            res += str(i) * freq[i]\n        \n        return int(res)\n```\n\n**Explanation**\n\nThis solution works as follows:\n\n1.  We first create a list `freq` to store the frequency of each digit from 0 to 9.\n2.  Then we count the frequency of each digit in the input string `s` by iterating over the string and incrementing the corresponding index in the `freq` list.\n3.  Next, we initialize an empty string `res` to store the result.\n4.  If the frequency of 0 is greater than 0, we add 0's to the end of the `res` string to ensure that the result does not start with a leading zero. We add 0's `freq[0] - 1` times because we will add a 0 at the beginning of the result string later.\n5.  Then, we add the smallest digits (1 to 9) to the `res` string in order, with each digit repeated by its frequency. This ensures that the result is the smallest possible number that can be formed by rearranging the digits of the input string.\n6.  Finally, we convert the `res` string to an integer and return it as the result.\n\n**Time Complexity**\n\nThe time complexity of this solution is O(N), where N is the number of digits in the input string. This is because we iterate over the input string once to count the frequency of each digit, and then we iterate over the digits from 1 to 9 to add them to the result string.\n\n**Space Complexity**\n\nThe space complexity of this solution is O(1), which means that the space used does not grow with the size of the input. This is because we use a fixed-size list `freq` to store the frequency of each digit, regardless of the size of the input string."}, {"generated_text": "To solve this problem, we can use the counting sort technique to count the frequency of each digit and then construct the smallest possible number.\n\nHere is the Python code to achieve this:\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Create a list to store the frequency of each digit\n        freq = [0] * 10\n\n        # Count the frequency of each digit\n        for char in s:\n            freq[int(char)] += 1\n\n        # Initialize the result string\n        res = ''\n\n        # Add the smallest non-zero digits first\n        for i in range(1, 10):\n            while freq[i] > 0:\n                res += str(i)\n                freq[i] -= 1\n\n        # Add the zero digits at the end if any\n        for i in range(1, 10):\n            while freq[i] > 0:\n                res += '0' * freq[i]\n                break\n\n        # If the result string is empty, it means the input string was all zeros\n        if not res:\n            return '0'\n\n        # If the result string starts with a zero, remove it\n        if res[0] == '0':\n            res = res[1:]\n\n        return res\n```\n\nThis code first counts the frequency of each digit in the input string. Then, it constructs the smallest possible number by adding the smallest non-zero digits first and the zero digits at the end if any. Finally, it checks if the result string is empty or starts with a zero and handles these cases accordingly.\n\nThe time complexity of this code is O(N * log(N)) where N is the number of digits in the input string, and the space complexity is O(1) as required."}, {"generated_text": "Here's a Python function that solves the problem by counting the frequency of each digit, sorting them, and then joining them to form the smallest possible number.\n\n```python\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\t\t# Count the frequency of each digit\n\t\tcount = [0] * 10\n\t\tfor char in s:\n\t\t\tcount[int(char)] += 1\n\n\t\t# Sort the digits\n\t\tsorted_digits = []\n\t\tfor i in range(9, -1, -1):\n\t\t\tfor _ in range(count[i]):\n\t\t\t\tsorted_digits.append(str(i))\n\n\t\t# Handle the case where there is at least one '0'\n\t\tif sorted_digits[-1] == '0':\n\t\t\tfor i in range(len(sorted_digits) - 1, 0, -1):\n\t\t\t\tif sorted_digits[i]!= '0':\n\t\t\t\t\tsorted_digits[i], sorted_digits[-1] = sorted_digits[-1], sorted_digits[i]\n\t\t\t\t\tbreak\n\n\t\t# Join the sorted digits to form the smallest possible number\n\t\treturn ''.join(sorted_digits)\n```\n\nThis function works by first counting the frequency of each digit in the input string. Then, it sorts the digits in descending order, with the most frequent digit first. If there is at least one '0' in the sorted digits, it swaps the last '0' with the first non-'0' digit to ensure that the resulting number does not start with '0'. Finally, it joins the sorted digits to form the smallest possible number.\n\nThe time complexity of this function is O(N * log(N)) because we are using the `sorted` function to sort the digits, which has a time complexity of O(N * log(N)) in Python. The space complexity is O(1) because we are only using a constant amount of space to store the count array and the sorted digits.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.minimum_Number(\"846903\"))  # Output: \"304689\"\nprint(solution.minimum_Number(\"55010\"))  # Output: \"10055\"\n```"}, {"generated_text": "To solve this problem, we can use a greedy approach. The idea is to place zeros at the end of the string and then sort the remaining digits in ascending order.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def minimum_Number(self, s):\n        # Create a dictionary to store the frequency of each digit\n        freq = {}\n        for digit in s:\n            if digit in freq:\n                freq[digit] += 1\n            else:\n                freq[digit] = 1\n        \n        # Initialize an empty string to store the result\n        res = ''\n        \n        # Place zeros at the end\n        freq['0'] = freq['0'] - 1\n        \n        # Sort the remaining digits in ascending order\n        sorted_digits = sorted([digit for digit in freq if digit!= '0'])\n        \n        # Add the digits to the result\n        for digit in sorted_digits:\n            res += digit * freq[digit]\n        \n        # Add the remaining zeros to the result\n        res += '0' * freq['0']\n        \n        # Return the result\n        return int(res)\n```\n\nThis code works as follows:\n\n1. It first creates a dictionary `freq` to store the frequency of each digit in the string `s`.\n2. It then initializes an empty string `res` to store the result.\n3. It places zeros at the end of the string by subtracting 1 from the frequency of '0' in the `freq` dictionary.\n4. It sorts the remaining digits in ascending order using the `sorted()` function.\n5. It adds the sorted digits to the `res` string by iterating over the sorted list of digits and repeating each digit according to its frequency.\n6. Finally, it adds the remaining zeros to the `res` string and returns the result as an integer.\n\nThis code has a time complexity of O(N * log(N)) where N is the number of digits in the string `s`, since it sorts the digits in ascending order. It has a space complexity of O(1) since it uses a constant amount of space to store the result."}]}