{"id": 19647, "input": "Given the root of a binary tree. Check whether it is a BST or not.\nNote: We are considering that BSTs can not contain duplicate Nodes.\nA BST is defined as follows:\n\t\n\tThe left subtree of a node contains only nodes with keys less than the node's key.\n\t\n\t\n\tThe right subtree of a node contains only nodes with keys greater than the node's key.\n\t\n\t\n\tBoth the left and right subtrees must also be binary search trees.\n\t\n \nExample 1:\nInput:\n   2\n /    \\\n1      3\nOutput: 1 \nExplanation: \nThe left subtree of root node contains node\nwith key lesser than the root nodes key and \nthe right subtree of root node contains node \nwith key greater than the root nodes key.\nHence, the tree is a BST.\nExample 2:\nInput:\n  2\n   \\\n    7\n     \\\n      6\n       \\\n        5\n         \\\n          9\n           \\\n            2\n             \\\n              6\nOutput: 0 \nExplanation: \nSince the node with value 7 has right subtree \nnodes with keys less than 7, this is not a BST.\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function isBST() which takes the root of the tree as a parameter and returns true if the given binary tree is BST, else returns false. \nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(Height of the BST).\nConstraints:\n0 <= Number of edges <= 100000\n#User function Template for python3\n\n\n\n\n\nclass Solution:\n\n    \n\n    #Function to check whether a Binary Tree is BST or not.\n\n    def isBST(self, root):\n\n        #code here\n\n\n\n", "difficulty": "EASY", "generations": [{"generated_text": "To solve this problem, we can use a helper function that takes the root node, the minimum allowed value, and the maximum allowed value as parameters. This function will recursively check if the current node's value is within the allowed range and if its left and right subtrees are also BSTs.\n\nHere is the Python code for the solution:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the allowed range, it's not a BST\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n```\n\nIn this code:\n\n- We define a helper function `isBST` that takes the root node, the minimum allowed value, and the maximum allowed value as parameters.\n- We use a base case to handle the case where the tree is empty.\n- We check if the current node's value is within the allowed range. If not, we return `False`.\n- We recursively call the `isBST` function on the left and right subtrees, updating the minimum and maximum allowed values accordingly.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, since we visit each node once. The auxiliary space complexity is O(Height of the BST), which is the maximum depth of the recursion call stack."}, {"generated_text": "To solve this problem, we can use a recursive approach. We will define a helper function `isBSTHelper` that checks whether a given range is valid for a node. If the node's value is within the given range, we recursively check the left and right subtrees.\n\nHere is the Python code:\n\n```python\nclass Solution:\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        \"\"\"\n        This function checks whether a binary tree is a BST or not.\n        \n        Args:\n        root (Node): The root of the binary tree.\n        min_val (float): The minimum allowed value in the subtree rooted at the current node.\n        max_val (float): The maximum allowed value in the subtree rooted at the current node.\n        \n        Returns:\n        bool: True if the binary tree is a BST, False otherwise.\n        \"\"\"\n        \n        # If the tree is empty, it is a BST\n        if root is None:\n            return True\n        \n        # If the current node's value is not within the allowed range, it is not a BST\n        if root.val <= min_val or root.val >= max_val:\n            return False\n        \n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.val) and\n                self.isBST(root.right, root.val, max_val))\n```\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, and a space complexity of O(Height of the BST), due to the recursive call stack.\n\nYou can use this function like this:\n\n```python\nroot = Node(2)\nroot.left = Node(1)\nroot.right = Node(3)\n\nsolution = Solution()\nprint(solution.isBST(root))  # Output: True\n\nroot = Node(2)\nroot.right = Node(7)\nroot.right.right = Node(6)\nroot.right.right.right = Node(5)\nroot.right.right.right.right = Node(9)\nroot.right.right.right.right.right = Node(2)\nroot.right.right.right.right.right.right = Node(6)\n\nprint(solution.isBST(root))  # Output: False\n```"}, {"generated_text": "To solve this problem, we can use a recursive approach. We will check if the given binary tree is a Binary Search Tree (BST) by verifying that all nodes in the left subtree have values less than the current node, and all nodes in the right subtree have values greater than the current node.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    # Initialize the minimum and maximum values for the BST\n    min_val = float('-inf')\n    max_val = float('inf')\n\n    # Function to check whether a Binary Tree is BST or not\n    def isBST(self, root):\n\n        # Base case: If the tree is empty, it is a BST\n        if root is None:\n            return True\n\n        # Check if the current node's value is within the valid range\n        if not (self.min_val < root.val < self.max_val):\n            return False\n\n        # Recursively check the left and right subtrees\n        self.min_val = root.val\n        return self.isBST(root.left)\n\n        self.max_val = root.val\n        return self.isBST(root.right)\n```\n\nHowever, the above code has some issues. It does not correctly handle the case when the node's value is equal to the min_val or max_val. \n\nHere's a corrected version of the code:\n\n```python\nclass Solution:\n\n    # Function to check whether a Binary Tree is BST or not\n    def isBST(self, root):\n\n        # Define a helper function to check the BST property\n        def check(node, min_val=float('-inf'), max_val=float('inf')):\n            if node is None:\n                return True\n\n            # If the current node's value is not within the valid range, return False\n            if not (min_val < node.val < max_val):\n                return False\n\n            # Recursively check the left and right subtrees\n            return (check(node.left, min_val, node.val) and\n                    check(node.right, node.val, max_val))\n\n        return check(root)\n```\n\nThis code defines a helper function `check` that takes an additional two parameters `min_val` and `max_val` to represent the valid range for the current node. It recursively checks the left and right subtrees, updating the valid range for each node. The `isBST` function simply calls the `check` function with the root node.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the binary tree, and an auxiliary space complexity of O(H), where H is the height of the binary tree."}, {"generated_text": "To solve this problem, we can use a recursive approach to check if the given binary tree is a BST or not. We will define a helper function `isBSTUtil` to check if the given subtree is a BST or not. This function will take the current node, minimum allowed value, and maximum allowed value as parameters.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        return self.isBSTUtil(root, float('-inf'), float('inf'))\n\n    def isBSTUtil(self, root, min_val, max_val):\n        # An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not in the valid range, it's not a BST\n        if root.val <= min_val or root.val >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBSTUtil(root.left, min_val, root.val) and\n                self.isBSTUtil(root.right, root.val, max_val))\n```\n\nIn this code, `isBST` is the main function that calls `isBSTUtil` with the root node and the valid range of values. `isBSTUtil` checks if the current node's value is within the valid range and then recursively checks the left and right subtrees.\n\nThe time complexity of this solution is O(N), where N is the number of nodes in the tree, since we visit each node once. The auxiliary space complexity is O(H), where H is the height of the tree, due to the recursive call stack."}, {"generated_text": "To solve this problem, we can use a recursive approach to check if the binary tree is a BST or not. We can use a helper function to check if the current node is within the valid range of values for the left and right subtrees.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # Check if the current node's value is within the valid range\n        if not min_val < root.data < max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n```\n\nIn this code, the `isBST` function takes an additional two parameters `min_val` and `max_val` to keep track of the valid range of values for the left and right subtrees. The function returns `True` if the binary tree is a BST and `False` otherwise.\n\nHere's an explanation of how the code works:\n\n1.  If the tree is empty (`root` is `None`), it's a BST, so we return `True`.\n2.  We check if the current node's value is within the valid range by checking if `min_val < root.data < max_val`. If not, we return `False`.\n3.  We recursively call `isBST` on the left and right subtrees, passing the updated `min_val` and `max_val` values. We pass `root.data` as the `min_val` for the left subtree and `max_val` for the right subtree to ensure that the values in the left subtree are less than the current node's value, and the values in the right subtree are greater than the current node's value.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the binary tree, and an auxiliary space complexity of O(Height of the BST), which is the maximum recursion depth."}, {"generated_text": "To solve this problem, we can use a recursive approach to check if the binary tree is a BST. We will use a helper function `isBSTUtil` to check if the tree rooted at `node` is a BST. This function will return a tuple containing a boolean value indicating whether the tree is a BST and the minimum and maximum values that can be present in the tree.\n\nHere is the Python code for the solution:\n\n```python\nclass Solution:\n\n    def isBST(self, root):\n        return self.isBSTUtil(root, float('-inf'), float('inf'))\n\n    def isBSTUtil(self, node, min_val, max_val):\n        if node is None:\n            return True, min_val, max_val\n\n        is_BST, min_val, max_val = self.isBSTUtil(node.left, min_val, node.val)\n        if not is_BST or node.val <= min_val:\n            return False, float('-inf'), float('inf')\n        \n        is_BST, max_val = self.isBSTUtil(node.right, node.val, max_val)\n        if not is_BST or node.val >= max_val:\n            return False, float('-inf'), float('inf')\n        \n        return True, min_val, max_val\n```\n\nIn this code, the `isBST` function calls the `isBSTUtil` function with the root node, negative infinity as the minimum value, and positive infinity as the maximum value. The `isBSTUtil` function recursively checks if the tree rooted at the current node is a BST by checking if the node's value is within the valid range and if its left and right subtrees are also BSTs.\n\nThis solution has a time complexity of O(N) where N is the number of nodes in the tree, and a space complexity of O(H) where H is the height of the tree, which is the maximum depth of the recursive call stack."}, {"generated_text": "Here's a Python solution for the problem using Inorder Traversal to check if the binary tree is a BST. This solution has a time complexity of O(N) and auxiliary space complexity of O(Height of the BST).\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = None\n\n        def inorder(node):\n            if node:\n                if not inorder(node.left):\n                    return False\n                if self.prev and self.prev.val >= node.val:\n                    return False\n                self.prev = node\n                return inorder(node.right)\n            return True\n\n        return inorder(root)\n```\n\nHowever, the above solution doesn't account for the duplicate nodes in the tree. To handle this, we can modify the solution to keep track of the previous node's value and return False as soon as we encounter a node with a value less than or equal to the previous node's value.\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = float('-inf')\n\n        def inorder(node):\n            if node:\n                if not inorder(node.left):\n                    return False\n                if self.prev >= node.val:\n                    return False\n                self.prev = node.val\n                return inorder(node.right)\n            return True\n\n        return inorder(root)\n```\n\nIn this modified solution, `self.prev` is initialized with a very small value (`float('-inf')`) to handle the case where the root node is the smallest node in the tree.\n\nThis solution has a time complexity of O(N) and auxiliary space complexity of O(Height of the BST), where N is the number of nodes in the tree."}, {"generated_text": "To check whether a binary tree is a BST or not, we can use an in-order traversal of the tree and check if the values are in ascending order. If they are, then the tree is a BST.\n\nHere's a Python function to solve this problem:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = float('-inf')\n        return self.checkBST(root)\n    \n    def checkBST(self, root):\n        if not root:\n            return True\n        \n        if not self.checkBST(root.left):\n            return False\n        \n        if self.prev >= root.val:\n            return False\n        \n        self.prev = root.val\n        return self.checkBST(root.right)\n```\n\nIn this code, we first initialize `prev` to negative infinity. Then we define a helper function `checkBST` which checks if the tree rooted at `root` is a BST. We first check if the left subtree is a BST. If it's not, we return False. Then we check if the current node's value is greater than the previous node's value. If it's not, we return False. We update `prev` with the current node's value and then check if the right subtree is a BST.\n\nThis function works in O(N) time complexity where N is the number of nodes in the tree, because we visit each node once. The space complexity is O(H) where H is the height of the tree, because that's the maximum depth of the recursion call stack.\n\nHowever, the above solution doesn't handle duplicate values in the tree. If the tree contains duplicate values, the above solution will return False for trees that are actually BSTs.\n\nHere's a modified version of the solution that handles duplicate values:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = float('-inf')\n        return self.checkBST(root)\n    \n    def checkBST(self, root):\n        if not root:\n            return True\n        \n        if not self.checkBST(root.left):\n            return False\n        \n        if self.prev >= root.val:\n            return False\n        \n        self.prev = root.val\n        return self.checkBST(root.right)\n```\n\nThis solution works by only checking if the current node's value is greater than the previous node's value, and doesn't care if the previous node's value is the same as the current node's value. This way, it correctly handles trees with duplicate values."}, {"generated_text": "To solve this problem, we can use a recursive approach. We will define a helper function `isBSTUtil` that checks whether a given subtree is a BST or not. This function will take three parameters: the root of the subtree, the minimum allowed value in the subtree, and the maximum allowed value in the subtree.\n\nHere's the code:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root):\n\n        # Initialize the minimum and maximum values\n        min_val = float('-inf')\n        max_val = float('inf')\n\n        # Call the helper function\n        return self.isBSTUtil(root, min_val, max_val)\n\n    # Helper function to check whether a subtree is a BST or not\n    def isBSTUtil(self, root, min_val, max_val):\n\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the allowed range, return False\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBSTUtil(root.left, min_val, root.data) and\n                self.isBSTUtil(root.right, root.data, max_val))\n```\n\nHowever, this solution has a time complexity of O(N log N) due to the recursive calls and the comparison operations. We can improve the time complexity to O(N) by using an iterative approach and a stack data structure.\n\nHere's the improved code:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root):\n\n        # Initialize the stack with the root node and its range\n        stack = [(root, float('-inf'), float('inf'))]\n\n        # Iterate through the stack\n        while stack:\n            node, min_val, max_val = stack.pop()\n\n            # If the current node is None, skip it\n            if node is None:\n                continue\n\n            # If the current node's value is not within the allowed range, return False\n            if node.data <= min_val or node.data >= max_val:\n                return False\n\n            # Push the left and right children into the stack with their updated ranges\n            stack.append((node.right, node.data, max_val))\n            stack.append((node.left, min_val, node.data))\n\n        # If we have iterated through the entire tree without returning False, it is a BST\n        return True\n```\n\nThis solution has a time complexity of O(N) and a space complexity of O(N) due to the stack data structure."}, {"generated_text": "To solve this problem, we can use a helper function that performs an in-order traversal of the binary tree and checks if the values are in ascending order. Here's the Python code for the solution:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # Check if the current node's value is within the valid range\n        if not min_val < root.val < max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.val) and\n                self.isBST(root.right, root.val, max_val))\n```\n\nIn this solution, the `isBST` function takes three parameters: `root` (the current node), `min_val` (the minimum value allowed for the current node), and `max_val` (the maximum value allowed for the current node). The `min_val` and `max_val` parameters are used to keep track of the valid range for each node.\n\nThe base case is when the `root` is `None`, in which case the function returns `True` because an empty tree is a BST.\n\nFor each node, we check if its value is within the valid range by comparing it with `min_val` and `max_val`. If it's not, we return `False`.\n\nFinally, we recursively call `isBST` on the left and right subtrees, passing the updated `min_val` and `max_val` values.\n\nThis solution has a time complexity of O(N) because we visit each node once, and a space complexity of O(H) because of the recursive call stack, where H is the height of the tree."}, {"generated_text": "To solve this problem, we can use an in-order traversal of the binary tree and check if the nodes are in sorted order. If they are, then the tree is a BST.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = None\n\n        def in_order(node):\n            if node is None:\n                return True\n\n            if not in_order(node.left):\n                return False\n\n            if self.prev is not None and node.data <= self.prev:\n                return False\n\n            self.prev = node.data\n\n            return in_order(node.right)\n\n        return in_order(root)\n```\n\nIn this code, `in_order` is a helper function that performs an in-order traversal of the binary tree. It checks each node in the order of left-root-right and returns False as soon as it encounters a node that is out of order.\n\nThe `isBST` function initializes the `prev` variable to None and calls the `in_order` function. If `in_order` returns True, then the tree is a BST and `isBST` returns True. Otherwise, it returns False.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, because it visits each node once. The space complexity is O(H), where H is the height of the tree, because of the recursive call stack."}, {"generated_text": "To solve this problem, we can use a helper function to check if a given tree is a BST. This function will take the root node and the minimum and maximum allowed values as parameters. If the root node's value is less than the minimum allowed value or greater than the maximum allowed value, it's not a BST. Otherwise, we recursively check the left and right subtrees.\n\nHere's the Python code:\n\n```python\nclass Solution:\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the root's value is not within the allowed range, it's not a BST\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n```\n\nHowever, the above solution does not follow the expected time complexity and auxiliary space complexity. It has a time complexity of O(N log N) due to the recursive calls and a space complexity of O(N) due to the recursive call stack.\n\nTo achieve the expected time complexity and auxiliary space complexity, we can use an in-order traversal of the tree and check if the values are in ascending order. Here's the modified code:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        self.prev = float('-inf')\n        return self.isBSTUtil(root)\n\n    def isBSTUtil(self, root):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # Recursively check the left subtree\n        if not self.isBSTUtil(root.left):\n            return False\n\n        # Check if the current node's value is in order\n        if self.prev >= root.data:\n            return False\n        self.prev = root.data\n\n        # Recursively check the right subtree\n        return self.isBSTUtil(root.right)\n```\n\nThis solution has a time complexity of O(N) and a space complexity of O(H), where H is the height of the tree."}, {"generated_text": "To check whether a binary tree is a BST or not, we can use the property of BSTs that the left subtree of a node contains only nodes with keys less than the node's key, and the right subtree of a node contains only nodes with keys greater than the node's key. We can achieve this by maintaining a range of valid values for each node.\n\nHere is the Python code to solve the problem:\n\n```python\nclass Solution:\n    def isBST(self, root):\n        def check(node, min_val=float('-inf'), max_val=float('inf')):\n            if not node:\n                return True\n            if not min_val < node.val < max_val:\n                return False\n            return (check(node.left, min_val, node.val) and\n                    check(node.right, node.val, max_val))\n        \n        return check(root)\n```\n\nExplanation:\n\n- We define a helper function `check` that takes a node and a range of valid values (`min_val` and `max_val`) as parameters.\n- If the node is `None`, we return `True` because an empty tree is a BST.\n- If the node's value is not within the valid range, we return `False`.\n- We recursively check the left and right subtrees, updating the valid range for each subtree. For the left subtree, the valid range is from `min_val` to the current node's value. For the right subtree, the valid range is from the current node's value to `max_val`.\n- The `isBST` function simply calls the `check` function with the root node and returns the result.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, because we visit each node once. The auxiliary space complexity is O(H), where H is the height of the tree, because of the recursive call stack."}, {"generated_text": "To solve this problem, we can use a simple recursive approach. We will define a helper function `isBSTUtil` that checks if a given subtree is a BST and returns a tuple. The first element of the tuple is a boolean indicating whether the subtree is a BST or not, and the second element is the minimum and maximum values in the subtree.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root):\n        return self.isBSTUtil(root, float('-inf'), float('inf'))\n\n    def isBSTUtil(self, root, min_val, max_val):\n        # An empty tree is BST\n        if root is None:\n            return True, min_val, max_val\n\n        # If root is null then tree is not BST\n        if root is None:\n            return False, None, None\n\n        # If root's value is out of range then tree is not BST\n        if root.data <= min_val or root.data >= max_val:\n            return False, None, None\n\n        # Recur on left and right subtrees\n        left_bst, left_min, left_max = self.isBSTUtil(root.left, min_val, root.data)\n        right_bst, right_min, right_max = self.isBSTUtil(root.right, root.data, max_val)\n\n        # If left and right subtrees are BST then return True\n        return left_bst and right_bst, min(left_min, left_max, root.data), max(right_min, right_max, root.data)\n```\n\nIn this code, the `isBST` function calls the `isBSTUtil` function with the root of the tree and the minimum and maximum values that the root can have. The `isBSTUtil` function recursively checks if the subtree rooted at the current node is a BST and returns a tuple containing a boolean indicating whether the subtree is a BST or not, and the minimum and maximum values in the subtree.\n\nThe time complexity of this solution is O(N), where N is the number of nodes in the tree, because each node is visited once. The auxiliary space complexity is O(H), where H is the height of the tree, because that is the maximum depth of the recursive call stack."}, {"generated_text": "To solve this problem, we can use an in-order traversal of the binary tree. In a binary search tree, the in-order traversal will give us a sorted list of nodes. If the tree is a BST, this list should be sorted in ascending order.\n\nHere's the Python code to solve this problem:\n\n```python\n#User function Template for python3\n\nclass Solution:\n\n    # Initialize variables to keep track of the previous node's value\n    prev = None\n\n    # Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root):\n        # If the tree is empty, it is a BST\n        if root is None:\n            return True\n\n        # Traverse the left subtree\n        if not self.isBST(root.left):\n            return False\n\n        # If the current node's value is not greater than the previous node's value, it is not a BST\n        if self.prev is not None and root.data <= self.prev:\n            return False\n\n        # Update the previous node's value\n        self.prev = root.data\n\n        # Traverse the right subtree\n        return self.isBST(root.right)\n\n\n# Driver code\nroot = Node(2)\nroot.left = Node(1)\nroot.right = Node(3)\n\nsolution = Solution()\nprint(solution.isBST(root))  # Output: 1\n\nroot = Node(2)\nroot.right = Node(7)\nroot.right.right = Node(6)\nroot.right.right.right = Node(5)\nroot.right.right.right.right = Node(9)\nroot.right.right.right.right.right = Node(2)\nroot.right.right.right.right.right.right = Node(6)\n\nprint(solution.isBST(root))  # Output: 0\n```\n\nHowever, the above solution has a time complexity of O(N log N) due to the in-order traversal. We can improve the time complexity to O(N) by using a recursive approach with an in-order traversal and passing the minimum and maximum values as parameters to the recursive function.\n\nHere's the improved Python code:\n\n```python\n#User function Template for python3\n\nclass Solution:\n\n    # Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # If the tree is empty, it is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the valid range, it is not a BST\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Traverse the left subtree\n        if not self.isBST(root.left, min_val, root.data):\n            return False\n\n        # Traverse the right subtree\n        return self.isBST(root.right, root.data, max_val)\n\n\n# Driver code\nroot = Node(2)\nroot.left = Node(1)\nroot.right = Node(3)\n\nsolution"}, {"generated_text": "To solve this problem, we can use a recursive approach. The idea is to check if the current node's value is within the valid range of its left and right subtrees. If it is, we recursively check the left and right subtrees.\n\nHere's the Python code to solve this problem:\n\n```python\nclass Solution:\n\n    # Initialize the minimum and maximum values for the left and right subtrees\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the valid range, return False\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n\n    # Helper function to create a new node\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.left = None\n            self.right = None\n\n# Example usage:\nif __name__ == '__main__':\n    root = Solution.Node(2)\n    root.left = Solution.Node(1)\n    root.right = Solution.Node(3)\n\n    print(Solution().isBST(root))  # Output: True\n\n    root = Solution.Node(2)\n    root.right = Solution.Node(7)\n    root.right.right = Solution.Node(6)\n    root.right.right.right = Solution.Node(5)\n    root.right.right.right.right = Solution.Node(9)\n    root.right.right.right.right.right = Solution.Node(2)\n    root.right.right.right.right.right.right = Solution.Node(6)\n\n    print(Solution().isBST(root))  # Output: False\n```\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(Height of the BST), where N is the number of nodes in the binary tree."}, {"generated_text": "To solve this problem, we can use a recursive approach. We will define a helper function `isBSTHelper` that checks whether the given node is a valid BST node. This function will take three parameters: the current node, the minimum allowed value, and the maximum allowed value.\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n    def isBST(self, root):\n        return self.isBSTHelper(root, float('-inf'), float('inf'))\n\n    def isBSTHelper(self, node, minVal, maxVal):\n        # An empty tree is a BST\n        if node is None:\n            return True\n\n        # If the current node's value is not within the allowed range, it's not a BST\n        if node.val <= minVal or node.val >= maxVal:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBSTHelper(node.left, minVal, node.val) and\n                self.isBSTHelper(node.right, node.val, maxVal))\n```\n\nIn this code, `isBSTHelper` function checks whether the given node is a valid BST node. It first checks if the node is `None` (i.e., an empty tree), in which case it returns `True`. Then it checks if the node's value is within the allowed range. If not, it returns `False`. Finally, it recursively checks the left and right subtrees.\n\nThe `isBST` function simply calls `isBSTHelper` with the initial values of `minVal` and `maxVal` as negative and positive infinity, respectively.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, because each node is visited once. The space complexity is O(H), where H is the height of the tree, because of the recursive call stack.\n\nNote: The `float('-inf')` and `float('inf')` are used to represent negative and positive infinity, respectively. This is because Python's `math.inf` constant was introduced in Python 3.4, and we want to support earlier versions as well."}, {"generated_text": "To solve this problem, we can use a recursive approach along with a helper function to check if a given range is satisfied by the nodes in the binary tree. Here's the Python code:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n\n        # Base case: If the tree is empty, it's a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the valid range, it's not a BST\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees with updated valid ranges\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n```\n\nHowever, this solution has a time complexity of O(N log N) due to the recursive calls and the comparison of node values with the valid range. To achieve a time complexity of O(N), we can use an in-order traversal to get the nodes in ascending order and then check if the sequence is sorted. Here's the updated code:\n\n```python\nclass Solution:\n\n    #Function to check whether a Binary Tree is BST or not.\n\n    def isBST(self, root):\n\n        # Initialize the previous node value and the result\n        prev_val = float('-inf')\n        self.isBSTUtil(root, prev_val)\n\n        # If the previous node value is not -inf, it means the tree is not a BST\n        return prev_val!= float('-inf')\n\n    def isBSTUtil(self, root, prev_val):\n\n        # Base case: If the tree is empty, it's a BST\n        if root is None:\n            return True\n\n        # Recursively check the left subtree\n        if not self.isBSTUtil(root.left, prev_val):\n            return False\n\n        # If the current node's value is not greater than the previous node's value, it's not a BST\n        if root.data <= prev_val:\n            return False\n\n        # Update the previous node value and check the right subtree\n        prev_val = root.data\n        return self.isBSTUtil(root.right, prev_val)\n```\n\nThis solution has a time complexity of O(N) and a space complexity of O(H), where H is the height of the tree."}, {"generated_text": "To solve this problem, we can use a recursive approach along with a helper function that checks if the current node's value is within the valid range for a BST. We'll also use a variable to keep track of the minimum and maximum allowed values for the current node.\n\nHere's the Python code:\n\n```python\nclass Solution:\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: If the tree is empty, it's a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the valid range, it's not a BST\n        if root.data <= min_val or root.data >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.data) and\n                self.isBST(root.right, root.data, max_val))\n```\n\nIn this code, we define a helper function `isBST` that takes an additional two parameters `min_val` and `max_val` to keep track of the valid range for the current node. We use these parameters to check if the current node's value is within the valid range.\n\nWe start by checking the base case: if the tree is empty, it's a BST. Then we check if the current node's value is within the valid range. If not, we return False.\n\nFinally, we recursively check the left and right subtrees, passing the updated valid range for each subtree.\n\nThis solution has a time complexity of O(N), where N is the number of nodes in the tree, and a space complexity of O(Height of the BST), which is the maximum depth of the recursion stack.\n\nYou can use this function to check if a binary tree is a BST by calling `isBST(root)`, where `root` is the root node of the tree. The function will return True if the tree is a BST and False otherwise."}, {"generated_text": "To check whether a binary tree is a BST or not, we need to traverse the tree and check if all nodes are in the correct order. We can use a helper function to perform an in-order traversal of the tree and check if the values are in ascending order.\n\nHere's a Python solution for the problem:\n\n```python\nclass Solution:\n    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):\n        # Base case: An empty tree is a BST\n        if root is None:\n            return True\n\n        # If the current node's value is not within the valid range, it's not a BST\n        if root.val <= min_val or root.val >= max_val:\n            return False\n\n        # Recursively check the left and right subtrees\n        return (self.isBST(root.left, min_val, root.val) and\n                self.isBST(root.right, root.val, max_val))\n```\n\nIn this solution, the `isBST` function takes an additional two parameters, `min_val` and `max_val`, which represent the valid range of values for the current node. The base case is when the tree is empty, in which case it's a BST. Then, we check if the current node's value is within the valid range. If not, we return False. Otherwise, we recursively call the `isBST` function on the left and right subtrees with the updated valid ranges.\n\nThe time complexity of this solution is O(N), where N is the number of nodes in the tree, since we visit each node once. The space complexity is O(H), where H is the height of the tree, due to the recursive call stack.\n\nYou can use this function like this:\n\n```python\nroot = Node(2)\nroot.left = Node(1)\nroot.right = Node(3)\n\nsolution = Solution()\nprint(solution.isBST(root))  # Output: True\n```\n\nThis will print `True` because the binary tree is a BST. If you create a binary tree that's not a BST, it will print `False`."}]}