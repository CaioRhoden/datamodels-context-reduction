{"id": 14290, "input": "Given an array a[] of size N which contains elements from 0 to N-1, you need to find all the elements occurring more than once in the given array. Return the answer in ascending order.\nNote: The extra space is only for the array to be returned.\nTry and perform all operations within the provided array. \nExample 1:\nInput:\nN = 4\na[] = {0,3,1,2}\nOutput: -1\nExplanation: N=4 and all elements from 0\nto (N-1 = 3) are present in the given\narray. Therefore output is -1.\nExample 2:\nInput:\nN = 5\na[] = {2,3,1,2,3}\nOutput: 2 3 \nExplanation: 2 and 3 occur more than once\nin the given array.\nYour Task:\nComplete the function duplicates() which takes array a[] and n as input as parameters and returns a list of elements that occur more than once in the given array in a sorted manner. If no such element is found, return list containing [-1]. \nExpected Time Complexity: O(n).\nExpected Auxiliary Space: O(n).\nConstraints:\n1 <= N <= 10^{5}\n0 <= A[i] <= N-1, for each valid i\nclass Solution:\n\n    def duplicates(self, arr, n): \n\n    \t# code here\n\n    \t    ", "difficulty": "EASY", "generations": [{"generated_text": "Here's the Python code to solve the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a boolean array, mark all elements as False\n        mark = [False] * n\n        \n        # Create a list to store duplicate elements\n        duplicates = []\n        \n        # Traverse the array\n        for i in range(n):\n            # If the element is within the valid range and not marked\n            if 0 <= arr[i] < n and not mark[arr[i]]:\n                # Mark the element as True\n                mark[arr[i]] = True\n            else:\n                # If the element is not within the valid range or already marked\n                # it means this element is a duplicate, so add it to the list\n                if 0 <= arr[i] < n:\n                    duplicates.append(arr[i])\n        \n        # If no duplicates found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the list of duplicates in sorted order\n        return sorted(duplicates)\n```\n\nThis solution works as follows:\n\n- It first creates a boolean array `mark` of size `n` and initializes all elements as `False`.\n- Then it iterates through the array `arr`. For each element, it checks if the element is within the valid range (`0 <= arr[i] < n`) and not marked (`not mark[arr[i]]`). If both conditions are true, it marks the element as `True`.\n- If the element is not within the valid range or already marked, it means this element is a duplicate, so it adds it to the list `duplicates`.\n- Finally, if no duplicates are found, it returns `[-1]`. Otherwise, it returns the list of duplicates in sorted order.\n\nThis solution has a time complexity of O(n) and an auxiliary space complexity of O(n), as required."}, {"generated_text": "To solve this problem, we can use a dictionary to count the frequency of each element in the array. Then, we can iterate over the dictionary to find the elements that occur more than once.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a dictionary to store the frequency of each element\n        freq = {}\n        \n        # Count the frequency of each element\n        for num in arr:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        # Find the elements that occur more than once\n        duplicates = [num for num in freq if freq[num] > 1]\n        \n        # If no such element is found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the list of duplicates in sorted order\n        return sorted(duplicates)\n```\n\nHowever, the problem requires us to perform all operations within the provided array, i.e., we cannot use any extra space outside the array. In this case, we can use the XOR operation to mark the elements that occur more than once.\n\nHere is the modified Python code:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Initialize the result array\n        res = [-1]\n        \n        # Initialize the XOR value\n        xor = 0\n        \n        # Count the XOR of all numbers from 0 to n-1\n        for i in range(n):\n            xor ^= i\n        \n        # If XOR value is 0, then all numbers from 0 to n-1 are present in the array\n        if xor == 0:\n            return res\n        \n        # Mark the elements that occur more than once using XOR\n        for num in arr:\n            xor ^= num\n        \n        # Find the duplicate element\n        duplicate = xor\n        \n        # Mark the elements that occur more than once in the result array\n        for num in arr:\n            if num == duplicate:\n                res = [duplicate]\n                break\n            elif num ^ duplicate == num:\n                res.append(num)\n        \n        # Return the result array in sorted order\n        return sorted(res)\n```\n\nThis code uses the XOR operation to mark the elements that occur more than once, and then it finds the duplicate element and marks the other elements that occur more than once in the result array."}, {"generated_text": "Here's a Python solution for the problem. This solution uses a hash map to count the frequency of each element in the array and then returns the elements that occur more than once.\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Count the frequency of each element\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Find the elements that occur more than once and return them in sorted order\n        duplicates = [num for num in freq_map if freq_map[num] > 1]\n        \n        # If no such element is found, return list containing [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the duplicates in sorted order\n        return sorted(duplicates)\n```\n\nHere's an explanation of the solution:\n\n1. We create a hash map `freq_map` to store the frequency of each element in the array.\n2. We iterate through the array and count the frequency of each element. If an element is already in the hash map, we increment its count. Otherwise, we add it to the hash map with a count of 1.\n3. We find the elements that occur more than once by iterating through the hash map and checking if the count of each element is greater than 1. We store these elements in a list `duplicates`.\n4. If no such element is found, we return a list containing [-1].\n5. Otherwise, we return the duplicates in sorted order using the `sorted` function.\n\nThis solution has a time complexity of O(n) because we are iterating through the array once to count the frequency of each element, and then iterating through the hash map to find the duplicates. The space complexity is also O(n) because in the worst case, we might need to store all elements in the hash map.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```"}, {"generated_text": "To solve this problem, we can use a hash map to store the frequency of each element in the array. Then, we can iterate over the array and check if the frequency of each element is more than one. If it is, we add it to the result list.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Create a list to store the result\n        result = []\n        \n        # Iterate over the array and update the frequency map\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Iterate over the array again and check if the frequency of each element is more than one\n        for num in arr:\n            if freq_map[num] > 1:\n                result.append(num)\n        \n        # If no such element is found, return list containing [-1]\n        if not result:\n            return [-1]\n        \n        # Return the result list in ascending order\n        return sorted(result)\n```\n\nHowever, the above solution has a time complexity of O(n^2) due to the nested loop. We can improve it to O(n) by iterating over the array only once and using a boolean array to mark the visited elements.\n\nHere is the improved Python code:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Create a boolean array to mark the visited elements\n        visited = [False] * n\n        \n        # Create a list to store the result\n        result = []\n        \n        # Iterate over the array and update the frequency map and mark the visited elements\n        for num in arr:\n            if num < n and not visited[num]:\n                freq_map[num] = freq_map.get(num, 0) + 1\n                visited[num] = True\n        \n        # Iterate over the array and check if the frequency of each element is more than one\n        for num in arr:\n            if num < n and freq_map[num] > 1:\n                result.append(num)\n        \n        # If no such element is found, return list containing [-1]\n        if not result:\n            return [-1]\n        \n        # Return the result list in ascending order\n        return sorted(result)\n```\n\nThis improved solution has a time complexity of O(n) and an auxiliary space complexity of O(n), as required by the problem constraints."}, {"generated_text": "To solve this problem, we can use the concept of a frequency array. We will create a frequency array of size N and mark the frequency of each element in the given array. Then, we will iterate over the frequency array and add the indices of elements with frequency more than 1 to the result list.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a frequency array of size N\n        freq = [0] * n\n        \n        # Mark the frequency of each element in the given array\n        for num in arr:\n            freq[num] += 1\n        \n        # Initialize a list to store the result\n        result = []\n        \n        # Iterate over the frequency array and add the indices of elements with frequency more than 1 to the result list\n        for i in range(n):\n            if freq[i] > 1:\n                result.append(i)\n        \n        # If no such element is found, return list containing [-1]\n        if not result:\n            result = [-1]\n        \n        # Return the result list in a sorted manner\n        return sorted(result)\n```\n\nThis code has a time complexity of O(n) and an auxiliary space complexity of O(n), where n is the size of the given array. It first creates a frequency array of size N and then iterates over the frequency array to find the elements with frequency more than 1. Finally, it returns the result list in a sorted manner.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```"}, {"generated_text": "Here's the Python program to solve the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a frequency array and mark the indices where frequency is more than 1\n        freq = [0] * n\n        for num in arr:\n            if num < n and freq[num] == 1:\n                freq[num] += 1\n            elif num < n:\n                freq[num] += 1\n        \n        # Create a list to store the duplicates\n        duplicates = []\n        for i in range(n):\n            if freq[i] > 1:\n                duplicates.append(i)\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the duplicates in sorted order\n        return sorted(duplicates)\n\n# Example usage:\nsolution = Solution()\nprint(solution.duplicates([0,3,1,2], 4))  # Output: [-1]\nprint(solution.duplicates([2,3,1,2,3], 5))  # Output: [1, 2, 3]\n```\n\nThis solution works by first creating a frequency array `freq` of size `n`, where `freq[i]` represents the frequency of the number `i` in the input array. We then iterate over the input array, incrementing the frequency of each number in the `freq` array. If a number's frequency is already 1, we increment it to 2 to mark it as a duplicate.\n\nNext, we create a list `duplicates` to store the indices of the numbers that occur more than once. We iterate over the `freq` array and add the indices of the numbers with frequency more than 1 to the `duplicates` list.\n\nFinally, we check if the `duplicates` list is empty. If it is, we return `[-1]` as there are no duplicates. Otherwise, we return the `duplicates` list in sorted order using the `sorted` function."}, {"generated_text": "Here is the Python solution for the problem. This solution uses the concept of counting the frequency of each element and storing them in a set for efficient lookup.\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a frequency array to store the count of each element\n        freq = [0] * n\n        \n        # Count the frequency of each element\n        for num in arr:\n            freq[num] += 1\n        \n        # Initialize a set to store the elements that occur more than once\n        duplicates = set()\n        \n        # Iterate over the frequency array and add elements with count greater than 1 to the set\n        for i in range(n):\n            if freq[i] > 1:\n                duplicates.add(i)\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the duplicates in a sorted manner\n        return sorted(list(duplicates))\n```\n\nHere's an explanation of the code:\n\n1. We create a frequency array `freq` of size `n` to store the count of each element in the input array.\n2. We iterate over the input array and increment the count of each element in the `freq` array.\n3. We create a set `duplicates` to store the elements that occur more than once.\n4. We iterate over the `freq` array and add elements with count greater than 1 to the `duplicates` set.\n5. If no duplicates are found, we return `[-1]`.\n6. Otherwise, we return the duplicates in a sorted manner by converting the set to a list and sorting it.\n\nThis solution has a time complexity of O(n) and an auxiliary space complexity of O(n), as required."}, {"generated_text": "To solve this problem, we can use a hash set to store the elements we have seen so far. We will iterate over the array and for each element, we will check if it is already present in the hash set. If it is, we will add it to the result list. Finally, we will return the result list in ascending order.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash set to store the elements we have seen so far\n        seen = set()\n        result = set()\n\n        # Iterate over the array\n        for num in arr:\n            # If the current element is already present in the hash set, add it to the result list\n            if num in seen:\n                result.add(num)\n            # Otherwise, add the current element to the hash set\n            seen.add(num)\n\n        # If no duplicates are found, return [-1]\n        if len(result) == 0:\n            return [-1]\n        # Otherwise, return the result list in ascending order\n        else:\n            return sorted(list(result))\n```\n\nThis code has a time complexity of O(n) and an auxiliary space complexity of O(n), where n is the size of the input array.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```"}, {"generated_text": "To solve this problem, we can use a hash map to keep track of the frequency of each element in the array. Then, we can iterate over the array and add the elements that have a frequency greater than 1 to the result list. Finally, we can sort the result list in ascending order.\n\nHere is the Python code to solve the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Initialize an empty list to store the duplicate elements\n        duplicates = []\n        \n        # Iterate over the array and update the frequency of each element in the hash map\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Iterate over the array again and add the elements with frequency greater than 1 to the result list\n        for num in arr:\n            if freq_map[num] > 1 and num not in duplicates:\n                duplicates.append(num)\n        \n        # If no duplicates are found, return a list containing -1\n        if not duplicates:\n            return [-1]\n        \n        # Sort the result list in ascending order\n        duplicates.sort()\n        \n        # Return the result list\n        return duplicates\n```\n\nThis solution has a time complexity of O(n) and an auxiliary space complexity of O(n), where n is the size of the input array.\n\nExample usage:\n\n```python\nsolution = Solution()\n\n# Example 1\narr = [0, 3, 1, 2]\nn = 4\nprint(solution.duplicates(arr, n))  # Output: [-1]\n\n# Example 2\narr = [2, 3, 1, 2, 3]\nn = 5\nprint(solution.duplicates(arr, n))  # Output: [2, 3]\n```\n\nThis code defines a class `Solution` with a method `duplicates` that takes an array `arr` and its size `n` as input and returns a list of duplicate elements in the array. The method uses a hash map to count the frequency of each element and a list to store the duplicate elements. The result list is sorted in ascending order before being returned. If no duplicates are found, the method returns a list containing -1."}, {"generated_text": "To solve this problem, we can use a HashMap to store the frequency of each element in the array. Then we can iterate over the HashMap to find the elements with frequency greater than 1.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a HashMap to store the frequency of each element\n        freq_map = {}\n        \n        # Iterate over the array and update the frequency of each element\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Find the elements with frequency greater than 1\n        duplicates = [num for num, freq in freq_map.items() if freq > 1]\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the duplicates in ascending order\n        duplicates.sort()\n        \n        return duplicates\n```\n\nThis solution has a time complexity of O(n) because we are iterating over the array and the HashMap once. The auxiliary space complexity is also O(n) because in the worst case, we need to store all elements in the HashMap.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```\n\nNote: This solution assumes that the input array contains elements from 0 to N-1 as specified in the problem statement. If the input array can contain other elements, the solution may need to be modified accordingly."}, {"generated_text": "Here is the Python solution for the problem. This solution uses a hash map to store the frequency of each element in the array. If the frequency of an element is more than 1, it is added to the result list.\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Create a list to store the duplicate elements\n        duplicates = []\n        \n        # Iterate through the array to count the frequency of each element\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Iterate through the hash map to find the elements with frequency more than 1\n        for num, freq in freq_map.items():\n            if freq > 1:\n                duplicates.append(num)\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the duplicates list in ascending order\n        duplicates.sort()\n        \n        return duplicates\n\n# Example usage:\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```\n\nThis solution has a time complexity of O(n) because it involves two iterations through the array. The auxiliary space complexity is also O(n) because in the worst case, all elements in the array could be stored in the hash map."}, {"generated_text": "Here's a Python solution for the given problem using a hash map to count the frequency of each element and then filtering out the elements that occur more than once.\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash map to store the frequency of each element\n        freq_map = {}\n        \n        # Count the frequency of each element\n        for num in arr:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        # Filter out the elements that occur more than once\n        duplicates = [num for num in freq_map if freq_map[num] > 1]\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the duplicates in ascending order\n        duplicates.sort()\n        \n        return duplicates\n```\n\n**Example Use Cases:**\n\n```python\nsolution = Solution()\n\n# Example 1:\narr = [0, 3, 1, 2]\nn = 4\nprint(solution.duplicates(arr, n))  # Output: [-1]\n\n# Example 2:\narr = [2, 3, 1, 2, 3]\nn = 5\nprint(solution.duplicates(arr, n))  # Output: [2, 3]\n\n# Example 3:\narr = [1, 2, 3, 4, 5]\nn = 5\nprint(solution.duplicates(arr, n))  # Output: [-1]\n```\n\nThis solution has a time complexity of O(n) as it makes a single pass through the array to count the frequency of each element. The space complexity is also O(n) as in the worst case, we might need to store all elements in the frequency map."}, {"generated_text": "Here is a Python program to solve the problem. This program uses a dictionary to count the frequency of each element in the array and then returns a list of elements that occur more than once.\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a dictionary to store frequency of elements\n        freq = {}\n        \n        # Count frequency of each element\n        for num in arr:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        # Find elements with frequency more than 1 and sort them\n        duplicates = sorted([num for num, count in freq.items() if count > 1])\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        return duplicates\n\n# Test the function\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```\n\nThis program runs in O(n) time complexity because it makes a single pass through the array to count frequencies, and then makes another pass through the dictionary to find duplicates. The auxiliary space complexity is also O(n) because in the worst case, we might need to store all elements in the dictionary."}, {"generated_text": "To solve this problem, we can use a hash set to store the elements we have seen so far and their frequencies. We can then iterate through the array again to find the elements that occur more than once.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a hash set to store the elements and their frequencies\n        freq = {}\n        \n        # Initialize an empty list to store the duplicates\n        duplicates = []\n        \n        # Iterate through the array to find the elements and their frequencies\n        for num in arr:\n            if num in freq:\n                # If the number is already in the hash set, increment its frequency\n                freq[num] += 1\n            else:\n                # If the number is not in the hash set, add it with a frequency of 1\n                freq[num] = 1\n        \n        # Iterate through the hash set to find the elements that occur more than once\n        for num, count in freq.items():\n            if count > 1:\n                # If the frequency of the number is more than 1, add it to the duplicates list\n                duplicates.append(num)\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the duplicates list in ascending order\n        duplicates.sort()\n        \n        # Return the duplicates list\n        return duplicates\n\n# Example usage:\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```\n\nThis solution has a time complexity of O(n) and an auxiliary space complexity of O(n), where n is the size of the input array."}, {"generated_text": "Here is a Python program that uses a dictionary to count the occurrences of each element in the array and then returns the elements that occur more than once in ascending order.\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a dictionary to store the count of each element\n        count_dict = {}\n        \n        # Count the occurrences of each element\n        for num in arr:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n        \n        # Find the elements that occur more than once and store them in a list\n        duplicates = [num for num, count in count_dict.items() if count > 1]\n        \n        # If no such element is found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the list of duplicates in ascending order\n        duplicates.sort()\n        \n        return duplicates\n\n# Example usage\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```\n\nThis program runs in O(n) time complexity because it makes two passes through the array: one to count the occurrences of each element and another to find the duplicates. It uses O(n) auxiliary space to store the count dictionary and the list of duplicates.\n\nAlternatively, you can use the `Counter` class from the `collections` module to count the occurrences of each element in a more concise way:\n\n```python\nfrom collections import Counter\n\nclass Solution:\n    def duplicates(self, arr, n):\n        count = Counter(arr)\n        duplicates = [num for num, count in count.items() if count > 1]\n        if not duplicates:\n            return [-1]\n        duplicates.sort()\n        return duplicates\n```\n\nThis version of the program is also O(n) in time complexity and uses O(n) auxiliary space."}, {"generated_text": "Here's the Python code to solve the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a boolean array, mark as true if the element is seen before\n        seen = [False] * n\n        \n        # Create a list to store duplicate elements\n        duplicates = []\n        \n        # Iterate over the array\n        for i in range(n):\n            # If the element is seen before, add it to the duplicates list\n            if seen[arr[i]]:\n                duplicates.append(arr[i])\n            # Mark the element as seen\n            seen[arr[i]] = True\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the duplicates list and return it\n        return sorted(duplicates)\n```\n\n**Explanation:**\n\n*   We create a boolean array `seen` of size `n` to keep track of the elements we've seen so far.\n*   We create an empty list `duplicates` to store the elements that occur more than once.\n*   We iterate over the input array `arr`. For each element, we check if it's seen before by checking the corresponding index in the `seen` array. If it's seen before, we add it to the `duplicates` list.\n*   We mark the element as seen by setting the corresponding index in the `seen` array to `True`.\n*   After iterating over the entire array, we check if the `duplicates` list is empty. If it is, we return `[-1]` because no duplicates were found.\n*   Finally, we sort the `duplicates` list using the `sorted` function and return it.\n\n**Example Use Cases:**\n\n```python\nsolution = Solution()\n\n# Example 1\narr = [0, 3, 1, 2]\nn = 4\nprint(solution.duplicates(arr, n))  # Output: [-1]\n\n# Example 2\narr = [2, 3, 1, 2, 3]\nn = 5\nprint(solution.duplicates(arr, n))  # Output: [2, 3]\n```\n\nThis solution has a time complexity of O(n) because we're iterating over the input array once, and an auxiliary space complexity of O(n) because we're using a boolean array of size `n` and a list to store the duplicates."}, {"generated_text": "Here's the Python solution for the given problem. The idea is to use a dictionary to store the frequency of each element in the array and then return the elements with frequency more than 1.\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a dictionary to store frequency of elements\n        freq = {}\n        \n        # Initialize an empty list to store duplicate elements\n        duplicates = []\n        \n        # Iterate over the array and count frequency of each element\n        for num in arr:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        # Iterate over the dictionary and add elements with frequency more than 1 to the list\n        for num, count in freq.items():\n            if count > 1:\n                duplicates.append(num)\n        \n        # If no duplicate elements are found, return [-1]\n        if len(duplicates) == 0:\n            return [-1]\n        \n        # Return the list of duplicate elements in sorted order\n        return sorted(duplicates)\n```\n\nHere's an explanation of the code:\n\n*   We create an empty dictionary `freq` to store the frequency of each element in the array.\n*   We initialize an empty list `duplicates` to store the elements with frequency more than 1.\n*   We iterate over the array and count the frequency of each element using the dictionary.\n*   We iterate over the dictionary and add elements with frequency more than 1 to the `duplicates` list.\n*   If no duplicate elements are found, we return the list `[-1]`.\n*   Finally, we return the list of duplicate elements in sorted order using the `sorted()` function.\n\nThe time complexity of this solution is O(n) because we are iterating over the array and dictionary once. The auxiliary space complexity is also O(n) because in the worst case, we might need to store all elements in the dictionary."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a boolean array and initialize all entries as false\n        visited = [False] * n\n        \n        # Create a list to store the duplicates\n        duplicates = []\n        \n        # Iterate through the array\n        for i in range(n):\n            # If the current element is within the bounds of the array and it's not visited\n            if 0 <= arr[i] < n and not visited[arr[i]]:\n                # Mark the current element as visited\n                visited[arr[i]] = True\n            else:\n                # If the current element is within the bounds of the array but it's already visited\n                if 0 <= arr[i] < n:\n                    # Add the current element to the duplicates list\n                    duplicates.append(arr[i])\n        \n        # If no duplicates are found, return [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Return the duplicates list in sorted order\n        return sorted(duplicates)\n```\n\n**Explanation:**\n\n*   We create a boolean array `visited` of size `n` to keep track of the elements we've seen so far.\n*   We iterate through the input array `arr`.\n*   For each element, we check if it's within the bounds of the array and if it's not visited yet. If it's not visited, we mark it as visited.\n*   If the element is within the bounds of the array but it's already visited, we add it to the `duplicates` list.\n*   After iterating through the entire array, we check if any duplicates were found. If not, we return `[-1]`.\n*   Finally, we return the `duplicates` list in sorted order.\n\n**Time Complexity:** O(n)\n**Auxiliary Space:** O(n)\n\n**Example Use Cases:**\n\n```python\nsolution = Solution()\n\n# Example 1:\narr = [0, 3, 1, 2]\nn = len(arr)\nprint(solution.duplicates(arr, n))  # Output: [-1]\n\n# Example 2:\narr = [2, 3, 1, 2, 3]\nn = len(arr)\nprint(solution.duplicates(arr, n))  # Output: [2, 3]\n```"}, {"generated_text": "To solve this problem, we can use a dictionary to count the occurrences of each element in the array. Then, we can iterate over the dictionary to find the elements that occur more than once and add them to the result list.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def duplicates(self, arr, n):\n        # Create a dictionary to store the count of each element\n        count_dict = {}\n        \n        # Iterate over the array to count the occurrences of each element\n        for num in arr:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n        \n        # Initialize an empty list to store the result\n        result = []\n        \n        # Iterate over the dictionary to find the elements that occur more than once\n        for num, count in count_dict.items():\n            if count > 1:\n                result.append(num)\n        \n        # If no such element is found, return list containing [-1]\n        if not result:\n            return [-1]\n        \n        # Return the result list in ascending order\n        return sorted(result)\n```\n\nThis code has a time complexity of O(n) because it iterates over the array and the dictionary once. The space complexity is also O(n) because in the worst case, all elements in the array could be unique, and we would need to store all of them in the dictionary.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.duplicates([0, 3, 1, 2], 4))  # Output: [-1]\nprint(solution.duplicates([2, 3, 1, 2, 3], 5))  # Output: [2, 3]\n```"}, {"generated_text": "To solve this problem, we can use a dictionary to count the frequency of each element in the array. Then, we can iterate over the dictionary to find the elements that have a count greater than 1.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def duplicates(self, arr, n):\n        # Create a dictionary to store the frequency of each element\n        freq = {}\n        \n        # Count the frequency of each element\n        for i in range(n):\n            if arr[i] in freq:\n                freq[arr[i]] += 1\n            else:\n                freq[arr[i]] = 1\n        \n        # Find the elements that have a count greater than 1\n        duplicates = [key for key, value in freq.items() if value > 1]\n        \n        # If no such element is found, return list containing [-1]\n        if not duplicates:\n            return [-1]\n        \n        # Sort the list of duplicates\n        duplicates.sort()\n        \n        # Return the list of duplicates\n        return duplicates\n\n# Example usage:\nsolution = Solution()\nprint(solution.duplicates([0,3,1,2], 4))  # Output: [-1]\nprint(solution.duplicates([2,3,1,2,3], 5))  # Output: [2, 3]\n```\n\nThis code has a time complexity of O(n) because it iterates over the array once to count the frequency of each element, and then iterates over the dictionary once to find the elements that have a count greater than 1. The space complexity is also O(n) because in the worst case, all elements in the array will be stored in the dictionary."}]}