{"id": 10350, "input": "This week Arkady wanted to cook some pancakes (to follow ancient traditions) and make a problem about that. But then he remembered that one can't make a problem about stacking pancakes without working at a specific IT company, so he decided to bake the Napoleon cake instead.\n\nTo bake a Napoleon cake, one has to bake $n$ dry layers first, and then put them on each other in one stack, adding some cream. Arkady started with an empty plate, and performed the following steps $n$ times:\n\nplace a new cake layer on the top of the stack;\n\nafter the $i$-th layer is placed, pour $a_i$ units of cream on top of the stack.\n\nWhen $x$ units of cream are poured on the top of the stack, top $x$ layers of the cake get drenched in the cream. If there are less than $x$ layers, all layers get drenched and the rest of the cream is wasted. If $x = 0$, no layer gets drenched.\n\nThe picture represents the first test case of the example.\n\nHelp Arkady determine which layers of the cake eventually get drenched when the process is over, and which don't.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 20000$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of layers in the cake.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le n$) \u2014 the amount of cream poured on the cake after adding each layer.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single line with $n$ integers. The $i$-th of the integers should be equal to $1$ if the $i$-th layer from the bottom gets drenched, and $0$ otherwise.\n\n\n-----Examples-----\n\nInput\n3\n6\n0 3 0 0 1 3\n10\n0 0 0 1 0 5 0 0 0 2\n3\n0 0 0\nOutput\n1 1 0 1 1 1 \n0 1 1 1 1 1 0 0 1 1 \n0 0 0\n\n\n-----Note-----\n\nNone\n", "difficulty": "EASY", "generations": [{"generated_text": "Here is a Python program to solve the problem:\n\n```python\nimport sys\n\ndef solve(n, a):\n    # Create a stack to store the indices of the layers\n    stack = []\n    # Create a list to store the result\n    result = [0] * n\n\n    for i in range(n):\n        # While the stack is not empty and the top of the stack is greater than or equal to the current layer\n        while stack and a[stack[-1]] >= i + 1:\n            # Pop the top of the stack\n            stack.pop()\n        # If the stack is not empty, the current layer is drenched\n        if stack:\n            result[i] = 1\n        # Push the current index to the stack\n        stack.append(i)\n\n    # Print the result\n    print(*result)\n\n# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of layers\n    n = int(input())\n    # Read the amount of cream poured on each layer\n    a = list(map(int, input().split()))\n    # Solve the problem\n    solve(n, a)\n```\n\nThis program uses a stack to store the indices of the layers that have been drenched. It iterates over the layers and for each layer, it checks if the top of the stack is greater than or equal to the current layer. If it is, it pops the top of the stack until it finds a layer that is less than the current layer or the stack is empty. If the stack is not empty, it means that the current layer is drenched, so it sets the corresponding element in the result list to 1. Finally, it pushes the current index to the stack and prints the result.\n\nYou can run this program with the provided examples to see the output."}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef napoleon_cake(n, cream):\n    \"\"\"\n    This function determines which layers of the cake eventually get drenched when the process is over.\n\n    Parameters:\n    n (int): The number of layers in the cake.\n    cream (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th integer is equal to 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    stack = [0] * n\n    max_cream = 0\n    for i in range(n):\n        max_cream = max(max_cream, cream[i])\n        if max_cream >= i + 1:\n            stack[n - i - 1] = 1\n        elif max_cream > 0:\n            stack[n - i - 1] = 1\n            stack[n - i - max_cream] = 0\n    return stack\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        cream = list(map(int, input().split()))\n        result = napoleon_cake(n, cream)\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program defines a function `napoleon_cake` that takes the number of layers `n` and a list of cream amounts as input, and returns a list of integers indicating which layers get drenched. The function uses a stack to keep track of the drenched layers.\n\nIn the `main` function, the program reads the number of test cases `t`, and for each test case, it reads the number of layers `n` and the list of cream amounts, and calls the `napoleon_cake` function to get the result. The result is then printed to the console.\n\nThe program"}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\nimport sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = [0] * n\n    top = 0\n    max_cream = 0\n\n    for i in range(n):\n        top += 1\n        max_cream = max(max_cream, a[i])\n        stack[i] = 1 if max_cream >= top else 0\n\n    print(*stack)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a stack to keep track of the layers of the cake. For each layer, it checks if the maximum cream poured so far is greater than or equal to the current layer number. If it is, the current layer gets drenched and is marked as 1 in the stack. Otherwise, it doesn't get drenched and is marked as 0.\n\nThe program then prints out the stack, which represents the layers of the cake that get drenched.\n\nThe time complexity of this program is O(n), where n is the number of layers in the cake. This is because it only needs to iterate over the layers once to determine which ones get drenched. The space complexity is also O(n), as it needs to store the stack of size n."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\ndef napoleon_cake(n, a):\n    # Create a stack to store the drenched layers\n    drenched = [0] * n\n    \n    # Initialize the current cream amount\n    current_cream = 0\n    \n    # Iterate over the layers from bottom to top\n    for i in range(n - 1, -1, -1):\n        # Update the current cream amount\n        current_cream = max(a[i], current_cream)\n        \n        # Mark the layers that get drenched\n        for j in range(i, current_cream - 1, -1):\n            drenched[j] = 1\n    \n    # Print the result\n    print(' '.join(map(str, drenched)))\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of layers and the cream amounts\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Process the test case\n    napoleon_cake(n, a)\n```\n\nThis program uses a stack to store the drenched layers. It iterates over the layers from bottom to top, updating the current cream amount and marking the layers that get drenched. Finally, it prints the result.\n\nYou can use this program to solve the problem. Just copy and paste the input and output into the program, and it will print the correct result."}, {"generated_text": "Here is a Python program that solves the problem:\n```python\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    Returns a list of integers where the i-th integer is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \n    :param n: The number of layers in the cake.\n    :param cream_amounts: A list of integers where the i-th integer is the amount of cream poured on the cake after adding the i-th layer.\n    \"\"\"\n    max_cream = 0\n    drenched_layers = [0] * n\n    stack = []\n    \n    for i in range(n):\n        # Add the current layer to the stack\n        stack.append(i)\n        \n        # Update the maximum cream amount\n        max_cream = max(max_cream, cream_amounts[i])\n        \n        # If the maximum cream amount is greater than the number of layers in the stack, all layers in the stack get drenched\n        if max_cream > len(stack):\n            max_cream = len(stack)\n        \n        # Mark the layers in the stack as drenched\n        for j in range(len(stack) - max_cream, len(stack)):\n            drenched_layers[stack[j]] = 1\n    \n    return drenched_layers\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        cream_amounts = list(map(int, input().split()))\n        drenched_layers = get_drenched_layers(n, cream_amounts)\n        print(*drenched_layers)\n\nif __name__ == \"__main__\":\n    main()\n```\nThis program uses a stack to keep track of the layers in the cake. It iterates over the cream amounts, adding each layer to the stack and updating the maximum cream amount. If the maximum cream amount is greater than the number of layers in the stack, all layers in the stack get drenched. Finally, it prints the drenched layers"}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\nimport sys\n\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    Determine which layers of the cake eventually get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th integer is equal to 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    max_cream = 0\n    drenched_layers = [0] * n\n    stack = []\n\n    for i in range(n):\n        # Add the current layer to the stack\n        stack.append(i)\n\n        # Update the maximum cream amount\n        max_cream = max(max_cream, cream_amounts[i])\n\n        # Remove layers from the stack that are not drenched\n        while stack and cream_amounts[stack[-1]] < max_cream:\n            stack.pop()\n\n        # Mark all layers in the stack as drenched\n        for j in range(len(stack)):\n            drenched_layers[stack[j]] = 1\n\n    return drenched_layers\n\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    for _ in range(t):\n        # Read the number of layers in the cake\n        n = int(input())\n\n        # Read the amount of cream poured on the cake after adding each layer\n        cream_amounts = list(map(int, input().split()))\n\n        # Determine which layers of the cake eventually get drenched\n        drenched_layers = get_drenched_layers(n, cream_amounts)\n\n        # Print the result\n        print(*drenched_layers)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program defines a function `get_drenched_layers` that takes the number"}, {"generated_text": "Here is a Python program to solve the problem. The program uses a stack to keep track of the layers that have been drenched.\n\n```python\nimport sys\n\ndef napoleon_cake(n, cream):\n    # Initialize a stack to keep track of the layers that have been drenched\n    drenched = [0] * n\n    max_cream = 0\n\n    # Process each layer from bottom to top\n    for i in range(n - 1, -1, -1):\n        # Update the maximum cream that has been poured so far\n        max_cream = max(max_cream, cream[i])\n\n        # If the current layer is drenched, update the drenched status of the top layers\n        if max_cream >= i + 1:\n            drenched[i] = 1\n            for j in range(i, max_cream):\n                drenched[j] = 1\n\n    # Print the drenched status of each layer\n    print(' '.join(str(x) for x in drenched))\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of layers and the cream amounts\n    n = int(input())\n    cream = list(map(int, input().split()))\n\n    # Process the test case\n    napoleon_cake(n, cream)\n```\n\nThis program reads the number of test cases, then for each test case, it reads the number of layers and the cream amounts. It then processes the test case by iterating over the layers from bottom to top and keeping track of the maximum cream that has been poured so far. If a layer is drenched, it updates the drenched status of the top layers. Finally, it prints the drenched status of each layer.\n\nYou can run this program on your input to get the output."}, {"generated_text": "Here is a Python solution to the problem:\n\n```python\nimport sys\n\ndef napoleon_cake(n, cream):\n    # Initialize the stack with all layers as dry\n    dry_layers = [1] * n\n    max_cream = 0\n\n    for i in range(n - 1, -1, -1):\n        # Update the maximum cream poured so far\n        max_cream = max(max_cream, cream[i])\n\n        # If the current layer is drenched, update the dry layers below it\n        if max_cream >= i + 1:\n            dry_layers[i] = 0\n\n    return''.join(map(str, dry_layers))\n\n\n# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of layers in the cake\n    n = int(input())\n\n    # Read the amount of cream poured on each layer\n    cream = list(map(int, input().split()))\n\n    # Print the layers that get drenched\n    print(napoleon_cake(n, cream))\n```\n\nThis solution uses a simple iterative approach to solve the problem. It initializes the stack with all layers as dry, then iterates over the layers from bottom to top, updating the maximum cream poured so far and marking the layers that get drenched. The result is a list of integers representing the layers that get drenched, where 1 indicates a drenched layer and 0 indicates a dry layer. The solution prints this list for each test case.\n\nYou can also use a stack data structure to solve this problem, but the iterative approach is simpler and more efficient in this case."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef drenched_layers(n, cream_amounts):\n    \"\"\"\n    This function determines which layers of the cake get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th integer is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the drenched layers\n    drenched = [0] * n\n\n    # Initialize a stack to store the cream amounts\n    cream_stack = []\n\n    # Initialize a variable to store the current cream amount\n    current_cream = 0\n\n    # Iterate over the cream amounts\n    for i, cream in enumerate(cream_amounts):\n        # Add the current cream amount to the stack\n        while cream_stack and cream_stack[-1] <= cream:\n            current_cream -= cream_stack.pop()\n\n        # Add the current cream amount to the stack\n        cream_stack.append(cream)\n\n        # Update the current cream amount\n        current_cream += cream\n\n        # If the current cream amount is greater than 0, mark the current layer as drenched\n        if current_cream > 0:\n            drenched[i] = 1\n\n    return drenched\n\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    # Iterate over the test cases\n    for _ in range(t):\n        # Read the number of layers\n        n = int(input())\n\n        # Read the cream amounts\n        cream_amounts = list(map(int, input().split()))\n\n        # Determine the drenched layers\n        drenched = drenched_layers(n, cream_amounts)\n\n        # Print the drenched layers\n       "}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\nimport sys\n\ndef napoleon_cake(n, cream):\n    # Initialize the stack and the result\n    stack = []\n    result = [0] * n\n\n    # Process each layer\n    for i, cream_amount in enumerate(cream):\n        # Add the current layer to the stack\n        stack.append(i)\n\n        # While the stack is not empty and the current cream amount is greater than or equal to the number of layers in the stack\n        while stack and cream_amount >= len(stack):\n            # Mark all layers in the stack as drenched\n            for j in range(len(stack)):\n                result[stack[j]] = 1\n\n            # Remove the top layer from the stack\n            stack.pop()\n\n    # Print the result\n    print(*result)\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of layers and the cream amounts\n    n = int(input())\n    cream = list(map(int, input().split()))\n\n    # Process the test case\n    napoleon_cake(n, cream)\n```\n\nThis solution uses a stack to keep track of the layers that have been added to the cake. It processes each layer from top to bottom, adding it to the stack and then popping the top layer from the stack if the current cream amount is greater than or equal to the number of layers in the stack. The result is then printed out.\n\nThe time complexity of this solution is O(n), where n is the number of layers in the cake. This is because each layer is processed once, and the stack operations (push and pop) take constant time. The space complexity is also O(n), as we need to store the stack and the result.\n\nYou can save this code to a file (e.g. `napoleon_cake.py`) and run it using `python napoleon_cake.py` to test it"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\ndef napoleon_cake(n, cream):\n    stack = [0] * n\n    max_cream = 0\n    for i in range(n):\n        max_cream = max(max_cream, cream[i])\n        if cream[i] >= i + 1:\n            stack[n - i - 1] = 1\n        elif cream[i] > max_cream:\n            for j in range(n - i, max_cream):\n                stack[j] = 1\n            max_cream = cream[i]\n    return''.join(map(str, stack))\n\ndef main():\n    input_lines = sys.stdin.readlines()\n    t = int(input_lines[0].strip())\n    i = 1\n    for _ in range(t):\n        n = int(input_lines[i].strip())\n        i += 1\n        cream = list(map(int, input_lines[i].strip().split(' ')))\n        i += 1\n        print(napoleon_cake(n, cream))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program reads the input from the standard input, processes each test case, and prints the result to the standard output. The `napoleon_cake` function simulates the process of stacking the cake layers and pouring cream, and returns a string representing the drenched layers. The `main` function reads the input, calls `napoleon_cake` for each test case, and prints the result."}, {"generated_text": "Here's a Python solution for the problem. This program will read the input from the user, process it, and print the result.\n\n```python\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    This function determines which layers of the cake get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th integer is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the result\n    drenched_layers = [0] * n\n\n    # Initialize a stack to store the cream amounts\n    cream_stack = []\n\n    # Process each layer\n    for i in range(n):\n        # Add the current cream amount to the stack\n        cream_stack.append(cream_amounts[i])\n\n        # While the stack is not empty and the top of the stack is less than or equal to the current cream amount\n        while cream_stack and cream_stack[-1] <= cream_amounts[i]:\n            # Pop the top of the stack\n            cream_stack.pop()\n\n        # If the stack is not empty, the top of the stack is the maximum cream amount that has been poured so far\n        if cream_stack:\n            # If the current layer is above the maximum cream amount that has been poured so far, mark it as drenched\n            if i >= cream_stack[-1] - 1:\n                drenched_layers[i] = 1\n\n    return drenched_layers\n\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    # Process each test case\n    for _ in range(t):\n        # Read the number of layers\n        n = int(input())\n\n        # Read the cream amounts\n        cream_amount"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    Determine which layers of the cake get drenched when the process is over.\n\n    Args:\n        n (int): The number of layers in the cake.\n        cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n        list: A list of integers where the i-th integer is equal to 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the maximum cream amount that can be poured on top of the stack at each layer\n    max_creams = [0] * (n + 1)\n    \n    # Initialize a list to store the result\n    result = [0] * n\n    \n    # Initialize the maximum cream amount that can be poured on top of the stack\n    max_cream = 0\n    \n    # Iterate over the layers from bottom to top\n    for i in range(n - 1, -1, -1):\n        # Update the maximum cream amount that can be poured on top of the stack\n        max_cream = max(max_cream, cream_amounts[i])\n        \n        # Update the result for the current layer\n        result[i] = 1 if max_cream > max_creams[i + 1] else 0\n        \n        # Update the maximum cream amount that can be poured on top of the stack at the next layer\n        max_creams[i] = max(max_cream, max_creams[i + 1])\n    \n    return result\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n    \n    # Process each test case\n    for _ in range(t):\n        # Read the number of layers in the cake\n        n = int(input())\n        \n        # Read the amount"}, {"generated_text": "Here's a Python solution for the problem. This script reads the input, processes it, and prints the result.\n\n```python\nimport sys\n\ndef process_input():\n    t = int(sys.stdin.readline().strip())\n    for _ in range(t):\n        n = int(sys.stdin.readline().strip())\n        a = list(map(int, sys.stdin.readline().strip().split()))\n        \n        # Initialize a list to store the drenched status of each layer\n        drenched = [0] * n\n        \n        # Initialize a stack to store the cream amount\n        cream = []\n        \n        for i in range(n):\n            # Add the current cream amount to the stack\n            cream.append(a[i])\n            cream.sort(reverse=True)\n            \n            # Check if the current layer is drenched\n            if cream[0] >= i + 1:\n                drenched[i] = 1\n        \n        # Print the drenched status of each layer\n        print(*drenched)\n\nprocess_input()\n```\n\nThis script works as follows:\n\n1.  It reads the number of test cases (`t`) from the input.\n2.  For each test case, it reads the number of layers (`n`) and the cream amounts (`a`) from the input.\n3.  It initializes a list (`drenched`) to store the drenched status of each layer (0 for not drenched, 1 for drenched) and a stack (`cream`) to store the cream amounts.\n4.  It processes each layer by adding the current cream amount to the stack, sorting the stack in descending order, and checking if the current layer is drenched based on the largest cream amount.\n5.  Finally, it prints the drenched status of each layer.\n\nThis solution has a time complexity of O(n log n) due to the sorting operation, where n is the number of layers. The space complexity is O(n) for storing the cream amounts and the drenched status of each layer."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\ndef napoleon_cake(n, cream):\n    \"\"\"\n    This function determines which layers of the Napoleon cake get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    cream (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th element is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the result\n    result = [0] * n\n\n    # Initialize a stack to store the indices of the layers\n    stack = []\n\n    # Initialize a variable to store the current amount of cream\n    current_cream = 0\n\n    # Iterate over the cream amounts\n    for i, amount in enumerate(cream):\n        # Add the current layer to the stack\n        stack.append(i)\n\n        # Update the current amount of cream\n        current_cream = max(current_cream, amount)\n\n        # Remove layers from the stack that are not affected by the current amount of cream\n        while stack and cream[stack[-1]] <= current_cream:\n            stack.pop()\n\n        # Mark the layers in the stack as drenched\n        for j in range(len(stack)):\n            result[stack[j]] = 1\n\n    # Return the result\n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of layers and the cream amounts\n    n = int(input())\n    cream = list(map(int, input().split()))\n\n    # Determine which layers get drenched\n    result = napoleon_cake(n, cream)\n\n    # Print the result\n    print(*result)\n```\n\nThis program uses a stack to keep track of"}, {"generated_text": "Here's a Python program that solves the problem using a stack data structure.\n\n```python\nimport sys\n\ndef get_drenched_layers(n, cream):\n    \"\"\"\n    Returns a list of integers where each integer is 1 if the corresponding layer gets drenched and 0 otherwise.\n    \n    :param n: The number of layers in the cake.\n    :param cream: A list of integers representing the amount of cream poured on the cake after adding each layer.\n    \"\"\"\n    stack = []\n    drenched = [0] * n\n    \n    for i in range(n):\n        # Add the current layer to the stack\n        stack.append(i)\n        \n        # While the stack is not empty and the top of the stack is greater than the current cream level\n        while stack and cream[stack[-1]] < len(stack):\n            # Pop the top of the stack\n            stack.pop()\n        \n        # If the stack is not empty, mark the top of the stack as drenched\n        if stack:\n            drenched[stack[-1]] = 1\n    \n    return drenched\n\ndef main():\n    t = int(sys.stdin.readline().strip())\n    \n    for _ in range(t):\n        n = int(sys.stdin.readline().strip())\n        cream = list(map(int, sys.stdin.readline().strip().split()))\n        \n        drenched = get_drenched_layers(n, cream)\n        \n        print(*drenched)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a stack to keep track of the layers that are not yet drenched. It iterates over each layer and adds it to the stack. If the top of the stack is greater than the current cream level, it pops the top of the stack. If the stack is not empty after popping, it marks the top of the stack as drenched.\n\nThe `get_drenched_layers` function returns a list of integers where each integer is 1 if the corresponding layer gets drenched and 0 otherwise. The"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    Returns a list where the i-th element is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n\n    :param n: The number of layers in the cake.\n    :param cream_amounts: A list of integers where the i-th element is the amount of cream poured on the cake after adding the i-th layer.\n    :return: A list of integers where the i-th element is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a stack to keep track of the layers that are still dry\n    dry_layers = [0] * n\n    # Initialize a stack to keep track of the amount of cream poured on the top of the stack\n    cream_stack = []\n    # Iterate over the layers\n    for i in range(n):\n        # Add the current layer to the stack of dry layers\n        dry_layers[i] = 1\n        # Add the current cream amount to the stack of cream amounts\n        cream_stack.append(cream_amounts[i])\n        # Sort the stack of cream amounts in descending order\n        cream_stack.sort(reverse=True)\n        # While the top of the stack of cream amounts is greater than or equal to the current layer number\n        while cream_stack and cream_stack[-1] >= i + 1:\n            # Remove the top of the stack of cream amounts\n            cream_stack.pop()\n            # Mark the top of the stack of dry layers as drenched\n            dry_layers[i - cream_stack[-1] + 1] = 0\n    return dry_layers\n\ndef main():\n    # Read the number of test cases\n    t = int(sys.stdin.readline())\n    # Iterate over the test cases\n    for _ in range(t):\n        # Read the number of layers in the"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef napoleon_cake(n, layers):\n    \"\"\"\n    Determine which layers of the cake get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    layers (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th element is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the result\n    result = [0] * n\n\n    # Initialize a stack to store the indices of the layers\n    stack = []\n\n    # Process each layer\n    for i in range(n):\n        # Remove the indices of the layers that get drenched\n        while stack and layers[stack[-1]] <= layers[i]:\n            result[stack.pop()] = 1\n\n        # Add the current layer to the stack\n        stack.append(i)\n\n    # Return the result\n    return result\n\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    # Process each test case\n    for _ in range(t):\n        # Read the number of layers\n        n = int(input())\n\n        # Read the layers\n        layers = list(map(int, input().split()))\n\n        # Determine which layers get drenched\n        result = napoleon_cake(n, layers)\n\n        # Print the result\n        print(*result)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a stack to keep track of the indices of the layers that have not been drenched yet. It processes each layer from top to bottom, removing the indices of the layers that get drenched and adding the current layer to the stack. Finally, it prints the result.\n\nYou can run this program and input the test cases to see the output."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\nimport sys\n\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    Determine which layers of the cake eventually get drenched when the process is over.\n\n    Args:\n    n (int): The number of layers in the cake.\n    cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n    list: A list of integers where the i-th integer is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    stack = []\n    drenched = [0] * n\n\n    for i in range(n):\n        # Add the current layer to the stack\n        stack.append(i)\n\n        # While the stack is not empty and the top of the stack is less than the current cream amount\n        while stack and stack[-1] < cream_amounts[i]:\n            # Remove the top of the stack\n            stack.pop()\n\n            # Mark the removed layer as drenched\n            drenched[stack[-1]] = 1\n\n    return drenched\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n        cream_amounts = list(map(int, input().split()))\n\n        drenched_layers = get_drenched_layers(n, cream_amounts)\n\n        print(*drenched_layers)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis program uses a stack to keep track of the layers that have not been drenched yet. It iterates over the cream amounts and for each amount, it removes the top of the stack if the top of the stack is less than the current cream amount. The layer that was removed from the stack is marked as drenched. The program then prints the drenched layers for each test case.\n\nThe time complexity of this program is O(n), where n is the number of layers in the cake,"}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\ndef get_drenched_layers(n, cream_amounts):\n    \"\"\"\n    This function determines which layers of the cake eventually get drenched when the process is over.\n\n    Args:\n        n (int): The number of layers in the cake.\n        cream_amounts (list): A list of integers representing the amount of cream poured on the cake after adding each layer.\n\n    Returns:\n        list: A list of integers where the i-th integer is 1 if the i-th layer from the bottom gets drenched, and 0 otherwise.\n    \"\"\"\n    # Initialize a list to store the drenched status of each layer\n    drenched_status = [0] * n\n\n    # Initialize a stack to store the cream amounts\n    cream_stack = []\n\n    # Initialize the current cream amount\n    current_cream = 0\n\n    # Process each layer\n    for i in range(n):\n        # Add the current cream amount to the stack\n        cream_stack.append(current_cream)\n\n        # Update the current cream amount\n        current_cream = cream_amounts[i]\n\n        # Process the cream stack\n        while cream_stack and cream_stack[-1] < current_cream:\n            # Remove the top element from the stack\n            cream_stack.pop()\n\n        # Update the drenched status of the current layer\n        if cream_stack:\n            drenched_status[i] = 1\n\n    return drenched_status\n\n\ndef main():\n    # Read the number of test cases\n    num_test_cases = int(input())\n\n    # Process each test case\n    for _ in range(num_test_cases):\n        # Read the number of layers\n        n = int(input())\n\n        # Read the cream amounts\n        cream_amounts = list(map(int, input().split()))\n\n        # Get the drenched status of each layer\n        drenched_status = get_drenched_layers(n, cream_amounts)\n\n        # Print the drenched status\n        print"}]}