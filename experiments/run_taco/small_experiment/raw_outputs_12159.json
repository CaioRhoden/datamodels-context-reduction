{"id": 12159, "input": "Given an unsorted array arr[] of N integers and a sum. The task is to count the number of subarrays which add to a given number.\n \nExample 1:\nInput:\nN=5\nsum=-10\narr[] = { 10, 2, -2, -20, 10 }\nOutput:  3\nExplanation:\nSubarrays with sum -10 are: \n[10, 2, -2, -20], [2, -2, -20, 10]\nand [-20, 10].\n \nExample 2:\nInput:\nN=6\nsum= 33\narr[] = { 1, 4, 20, 3, 10, 5 }\nOutput:  1\nYour Task:\nSince, this is a function problem. You don't need to take any input, as it is already accomplished by the driver code. You just need to complete the function subArraySum() that takes array arr , integer N and integer sum as parameters and returns the count of the subarray which adds to the given sum.\n \nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(N).\n \nConstraints:\n1 \u2264 N \u2264 10^{6}\n#User function Template for python3\n\n\n\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):  \n\n        #code here", "difficulty": "EASY", "generations": [{"generated_text": "To solve this problem, we can use a HashMap to store the cumulative sum and its frequency. The idea is to maintain a running sum of the subarray elements and use the HashMap to store the cumulative sum and its frequency.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a HashMap to store the cumulative sum and its frequency\n        cumulative_sum_freq = {0: 1}  # Initialize with 0 sum and frequency 1\n        current_sum = 0\n        count = 0\n\n        # Traverse the array\n        for num in arr:\n            current_sum += num\n\n            # If the difference between the current sum and the target sum exists in the HashMap\n            if current_sum - Sum in cumulative_sum_freq:\n                # Increment the count by the frequency of the difference\n                count += cumulative_sum_freq[current_sum - Sum]\n\n            # Update the frequency of the current sum in the HashMap\n            cumulative_sum_freq[current_sum] = cumulative_sum_freq.get(current_sum, 0) + 1\n\n        return count\n```\n\n**Explanation:**\n\n1. We initialize a HashMap `cumulative_sum_freq` with a sum of 0 and a frequency of 1.\n2. We maintain a running sum `current_sum` of the subarray elements.\n3. For each element in the array, we add it to `current_sum`.\n4. We check if the difference between `current_sum` and the target sum `Sum` exists in the HashMap. If it does, we increment the count by the frequency of the difference.\n5. We update the frequency of `current_sum` in the HashMap.\n6. Finally, we return the count of subarrays that sum to the target sum.\n\n**Time Complexity:** O(N)\n\n**Auxiliary Space:** O(N)\n\nThis solution meets the expected time complexity and auxiliary space complexity."}, {"generated_text": "To solve this problem, we can use a hashmap to store the cumulative sum and its frequency. The idea is to traverse the array and for each element, we calculate the cumulative sum and check if it exists in the hashmap. If it does, we increment the count by the frequency of the cumulative sum minus 1 (because we are considering the current subarray). If it doesn't, we add it to the hashmap with a frequency of 1.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):\n        hashmap = {0: 1}  # Initialize hashmap with 0 sum and frequency 1\n        current_sum = 0\n        count = 0\n\n        for num in arr:\n            current_sum += num\n            if current_sum - Sum in hashmap:\n                count += hashmap[current_sum - Sum]\n            hashmap[current_sum] = hashmap.get(current_sum, 0) + 1\n\n        return count\n```\n\nExplanation:\n\n1. We initialize a hashmap with a key-value pair (0, 1) to handle the case when the cumulative sum is 0.\n2. We iterate through the array and for each element, we calculate the cumulative sum.\n3. We check if the difference between the current cumulative sum and the given sum exists in the hashmap. If it does, we increment the count by the frequency of the cumulative sum minus 1.\n4. We add the current cumulative sum and its frequency to the hashmap.\n5. Finally, we return the count of subarrays with the given sum.\n\nTime Complexity: O(N)\nAuxiliary Space: O(N)\n\nThis solution works because the hashmap allows us to look up the frequency of the cumulative sum in constant time, making the overall time complexity linear. The space complexity is also linear because in the worst case, we need to store all elements in the hashmap."}, {"generated_text": "To solve this problem, we can use the concept of prefix sum. We will maintain a hash map to store the count of prefix sum for each value. We will iterate through the array and for each element, we will calculate the prefix sum. If the prefix sum minus the given sum exists in the hash map, it means we have found a subarray with sum equal to the given sum. We will increment the count by the value in the hash map.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a hash map to store the count of prefix sum\n        prefix_sum_count = {0: 1}\n        \n        # Initialize the current prefix sum and the count of subarrays with sum equal to the given sum\n        current_prefix_sum = 0\n        count = 0\n        \n        # Iterate through the array\n        for num in arr:\n            # Update the current prefix sum\n            current_prefix_sum += num\n            \n            # If the current prefix sum minus the given sum exists in the hash map, increment the count\n            if current_prefix_sum - Sum in prefix_sum_count:\n                count += prefix_sum_count[current_prefix_sum - Sum]\n            \n            # Update the count of prefix sum in the hash map\n            prefix_sum_count[current_prefix_sum] = prefix_sum_count.get(current_prefix_sum, 0) + 1\n        \n        # Return the count of subarrays with sum equal to the given sum\n        return count\n```\n\nThis solution works in O(N) time complexity because we are iterating through the array only once. The space complexity is also O(N) because in the worst case, we need to store all prefix sums in the hash map.\n\nExample usage:\n\n```python\nsolution = Solution()\narr = [10, 2, -2, -20, 10]\nn = 5\nSum = -10\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 3\n\narr = [1, 4, 20, 3, 10, 5]\nn = 6\nSum = 33\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 1\n```"}, {"generated_text": "To solve this problem, we can use a hash map to store the cumulative sum of elements and their frequencies. We will iterate through the array, calculate the cumulative sum, and check if the difference between the cumulative sum and the target sum exists in the hash map. If it does, it means we have found a subarray with the target sum.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a hash map to store cumulative sum and their frequencies\n        cumulative_sum_freq = {0: 1}\n        current_sum = 0\n        count = 0\n\n        # Iterate through the array\n        for num in arr:\n            # Calculate the cumulative sum\n            current_sum += num\n\n            # Check if the difference between the current sum and the target sum exists in the hash map\n            if current_sum - Sum in cumulative_sum_freq:\n                # If it exists, increment the count by the frequency of the difference\n                count += cumulative_sum_freq[current_sum - Sum]\n\n            # Update the frequency of the current sum in the hash map\n            cumulative_sum_freq[current_sum] = cumulative_sum_freq.get(current_sum, 0) + 1\n\n        return count\n```\n\nThis code has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array. The hash map is used to store the cumulative sum and their frequencies, which allows us to find the frequency of the difference between the current sum and the target sum in constant time."}, {"generated_text": "To solve this problem, we can use the concept of a prefix sum array and a hashmap. The prefix sum array will store the cumulative sum of the array elements up to each index, and the hashmap will store the frequency of each prefix sum.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Create a hashmap to store the frequency of each prefix sum\n        hashmap = {0: 1}\n        current_sum = 0\n        count = 0\n        \n        # Iterate over the array\n        for i in range(n):\n            # Add the current element to the current sum\n            current_sum += arr[i]\n            \n            # Check if the hashmap contains a prefix sum that is equal to the current sum minus the target sum\n            if current_sum - Sum in hashmap:\n                # If it does, increment the count by the frequency of that prefix sum\n                count += hashmap[current_sum - Sum]\n            \n            # Update the frequency of the current sum in the hashmap\n            hashmap[current_sum] = hashmap.get(current_sum, 0) + 1\n        \n        return count\n```\n\nThis code works as follows:\n\n1.  It creates a hashmap to store the frequency of each prefix sum. The hashmap is initialized with a frequency of 1 for a prefix sum of 0.\n2.  It iterates over the array, adding each element to the current sum.\n3.  For each current sum, it checks if the hashmap contains a prefix sum that is equal to the current sum minus the target sum. If it does, it increments the count by the frequency of that prefix sum.\n4.  It updates the frequency of the current sum in the hashmap.\n5.  Finally, it returns the count of subarrays that add up to the target sum.\n\nThe time complexity of this code is O(N), where N is the length of the array, and the auxiliary space complexity is also O(N) for storing the hashmap."}, {"generated_text": "To solve this problem, we can use the prefix sum technique along with a HashMap. The idea is to calculate the prefix sum of the array and store the count of each prefix sum in a HashMap. Then, for each prefix sum, we can calculate the sum of the subarray ending at the current index by subtracting the prefix sum from the given sum. If the resulting sum is already present in the HashMap, it means we have found a subarray with the given sum.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):\n        prefix_sum = 0\n        count = 0\n        hashmap = {0: 1}  # Initialize hashmap with 0 sum having count 1\n\n        for i in range(n):\n            prefix_sum += arr[i]\n\n            # Check if hashmap contains (Sum - prefix_sum)\n            if (Sum - prefix_sum) in hashmap:\n                count += hashmap[Sum - prefix_sum]\n\n            # Update hashmap with prefix_sum\n            hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1\n\n        return count\n```\n\n**Explanation:**\n\n1. Initialize the `prefix_sum` variable to 0 and the `count` variable to 0.\n2. Initialize a HashMap `hashmap` with 0 sum having count 1.\n3. Iterate through the array from index 0 to n-1.\n4. For each index, add the current element to the `prefix_sum`.\n5. Check if the HashMap contains the sum `(Sum - prefix_sum)`. If it does, increment the `count` by the count of `(Sum - prefix_sum)` in the HashMap.\n6. Update the HashMap with the current `prefix_sum` by incrementing its count by 1.\n7. Return the `count` of subarrays with the given sum.\n\n**Time Complexity:** O(N)\n**Auxiliary Space:** O(N)\n\nThis solution meets the expected time complexity and auxiliary space complexity requirements."}, {"generated_text": "To solve this problem, we can use the concept of prefix sum and hashmap. The idea is to store the cumulative sum of the array elements and the count of each cumulative sum. Then, we can find the count of subarrays that sum up to the given target sum.\n\nHere is the Python code to solve the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Create a hashmap to store the cumulative sum and its count\n        hashmap = {0: 1}  # Base case: sum 0 has 1 subarray (empty subarray)\n        current_sum = 0\n        count = 0\n\n        # Traverse the array and update the hashmap\n        for num in arr:\n            current_sum += num\n            count += hashmap.get(current_sum - Sum, 0)\n            hashmap[current_sum] = hashmap.get(current_sum, 0) + 1\n\n        return count\n```\n\nExplanation:\n\n1.  We create a hashmap `hashmap` to store the cumulative sum and its count. We initialize it with a base case: sum 0 has 1 subarray (empty subarray).\n2.  We maintain a variable `current_sum` to store the cumulative sum of the array elements.\n3.  We iterate through the array, and for each element, we update `current_sum` by adding the current element.\n4.  We check if the hashmap contains the cumulative sum minus the target sum. If it does, it means we have found a subarray that sums up to the target sum. We increment the count by the count of this cumulative sum in the hashmap.\n5.  We update the hashmap with the new cumulative sum and its count.\n6.  Finally, we return the count of subarrays that sum up to the target sum.\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array."}, {"generated_text": "To solve this problem, we can use a HashMap to store the cumulative sum and its frequency. The idea is to maintain a cumulative sum and store it in the HashMap. If the cumulative sum minus the given sum already exists in the HashMap, it means we have found a subarray with the given sum.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):  \n\n        # Initialize the cumulative sum and the HashMap\n        cumulative_sum = 0\n        freq_map = {0: 1}  # Initialize the HashMap with 0: 1\n\n        # Initialize the count of subarrays with the given sum\n        count = 0\n\n        # Iterate through the array\n        for i in range(n):\n            # Update the cumulative sum\n            cumulative_sum += arr[i]\n\n            # If the cumulative sum minus the given sum exists in the HashMap, increment the count\n            if cumulative_sum - Sum in freq_map:\n                count += freq_map[cumulative_sum - Sum]\n\n            # Update the frequency of the cumulative sum in the HashMap\n            freq_map[cumulative_sum] = freq_map.get(cumulative_sum, 0) + 1\n\n        return count\n```\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array.\n\nHere's an explanation of the code:\n\n1. We initialize the cumulative sum and the HashMap `freq_map` with 0: 1. This is because the cumulative sum is initially 0, and we want to count the subarray with sum 0.\n2. We iterate through the array, updating the cumulative sum and the HashMap `freq_map` at each step.\n3. If the cumulative sum minus the given sum exists in the HashMap, we increment the count. This is because we have found a subarray with the given sum.\n4. We update the frequency of the cumulative sum in the HashMap.\n5. Finally, we return the count of subarrays with the given sum.\n\nThis solution is efficient because it uses a HashMap to store the cumulative sum and its frequency, allowing us to look up the frequency of the cumulative sum in constant time."}, {"generated_text": "To solve this problem, we can use a HashMap to store the cumulative sum and its frequency. The idea is to traverse the array and for each element, we check if the cumulative sum minus the given sum already exists in the HashMap. If it does, it means we have found a subarray that sums up to the given sum. We then update the frequency of the cumulative sum in the HashMap.\n\nHere is the Python code to solve the problem:\n\n```python\nclass Solution:\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a HashMap to store cumulative sum and its frequency\n        cumulative_sum_freq = {0: 1}\n        cumulative_sum = 0\n        count = 0\n        \n        # Traverse the array\n        for num in arr:\n            # Update the cumulative sum\n            cumulative_sum += num\n            \n            # Check if the cumulative sum minus the given sum already exists in the HashMap\n            if cumulative_sum - Sum in cumulative_sum_freq:\n                # If it does, increment the count\n                count += cumulative_sum_freq[cumulative_sum - Sum]\n            \n            # Update the frequency of the cumulative sum in the HashMap\n            cumulative_sum_freq[cumulative_sum] = cumulative_sum_freq.get(cumulative_sum, 0) + 1\n        \n        # Return the count of subarrays that sum up to the given sum\n        return count\n```\n\nThis solution works in O(N) time complexity and O(N) auxiliary space complexity, where N is the number of elements in the array.\n\nExample usage:\n\n```python\nsolution = Solution()\narr = [10, 2, -2, -20, 10]\nn = 5\nSum = -10\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 3\n\narr = [1, 4, 20, 3, 10, 5]\nn = 6\nSum = 33\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 1\n```"}, {"generated_text": "To solve this problem, we can use the prefix sum approach. The idea is to calculate the prefix sum of the array and store it in a dictionary. The key in the dictionary will be the prefix sum and the value will be the count of that prefix sum.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize the count of subarrays with given sum\n        count = 0\n        \n        # Initialize the prefix sum and its count\n        prefix_sum = 0\n        prefix_count = {0: 1}  # Initialize with 0 sum and count 1\n        \n        # Traverse the array\n        for i in range(n):\n            # Update the prefix sum\n            prefix_sum += arr[i]\n            \n            # Check if the difference between the prefix sum and the given sum exists in the dictionary\n            if prefix_sum - Sum in prefix_count:\n                # If it exists, increment the count by the count of that prefix sum\n                count += prefix_count[prefix_sum - Sum]\n            \n            # Update the count of the current prefix sum\n            if prefix_sum not in prefix_count:\n                prefix_count[prefix_sum] = 0\n            prefix_count[prefix_sum] += 1\n        \n        # Return the count of subarrays with given sum\n        return count\n```\n\nThis code works by maintaining a running sum of the array elements. For each element, it checks if the difference between the running sum and the target sum exists in the dictionary. If it does, it increments the count of subarrays by the count of that difference. Finally, it returns the count of subarrays with the given sum.\n\nThe time complexity of this code is O(n), where n is the number of elements in the array. This is because it traverses the array once. The space complexity is also O(n), as in the worst case, it needs to store all the prefix sums in the dictionary."}, {"generated_text": "Here is a Python solution for the problem. We will use a hashmap to store the cumulative sum of elements and their frequencies. \n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):\n        # Create a hashmap to store cumulative sum and their frequencies\n        hashmap = {0: 1}\n        curr_sum = 0\n        count = 0\n\n        # Traverse the array\n        for num in arr:\n            # Update the current sum\n            curr_sum += num\n\n            # If the hashmap contains a key equal to the current sum minus the target sum\n            if curr_sum - Sum in hashmap:\n                # Increment the count by the frequency of the key\n                count += hashmap[curr_sum - Sum]\n\n            # Update the frequency of the current sum in the hashmap\n            hashmap[curr_sum] = hashmap.get(curr_sum, 0) + 1\n\n        return count\n```\n\n**Explanation**\n\n1.  We create a hashmap to store the cumulative sum of elements and their frequencies.\n2.  We initialize the `curr_sum` variable to 0, which will store the cumulative sum of elements.\n3.  We initialize the `count` variable to 0, which will store the count of subarrays with a sum equal to the target sum.\n4.  We traverse the array and update the `curr_sum` by adding each element.\n5.  For each element, we check if the hashmap contains a key equal to the `curr_sum` minus the target sum. If it does, we increment the `count` by the frequency of the key.\n6.  We update the frequency of the `curr_sum` in the hashmap.\n7.  Finally, we return the `count` which represents the number of subarrays with a sum equal to the target sum.\n\n**Time Complexity:** O(N)\n\n**Auxiliary Space:** O(N)\n\n**Constraints:** \n\n1 \u2264 N \u2264 10^6\n\nThis solution meets the expected time complexity and auxiliary space complexity."}, {"generated_text": "To solve this problem, we can use the concept of prefix sum and a HashMap to store the prefix sums and their frequencies. Here's the Python code to achieve this:\n\n```python\nclass Solution:\n    def findSubarraySum(self, arr, n, Sum):\n        prefix_sum = 0\n        freq = {0: 1}  # Initialize the frequency of 0 as 1\n        count = 0\n\n        for num in arr:\n            prefix_sum += num\n            if prefix_sum - Sum in freq:\n                count += freq[prefix_sum - Sum]\n            freq[prefix_sum] = freq.get(prefix_sum, 0) + 1\n\n        return count\n```\n\nExplanation:\n\n*   We initialize a `prefix_sum` variable to keep track of the cumulative sum of the array elements.\n*   We create a `freq` dictionary to store the prefix sums and their frequencies.\n*   We initialize the frequency of 0 as 1, as there's always a subarray with a sum of 0 (the empty subarray).\n*   We iterate through the array, updating the `prefix_sum` at each step.\n*   For each prefix sum, we check if the difference between the current prefix sum and the target sum (`Sum`) is present in the `freq` dictionary. If it is, we increment the count by the frequency of that prefix sum.\n*   We update the frequency of the current prefix sum in the `freq` dictionary.\n*   Finally, we return the count of subarrays with a sum equal to the target sum.\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(N), as required."}, {"generated_text": "To solve this problem, we can use a hash map to store the cumulative sum of the subarrays and their frequencies. We will iterate over the array, calculate the cumulative sum, and check if the cumulative sum minus the given sum already exists in the hash map. If it does, it means we have found a subarray that sums up to the given sum.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a hash map to store cumulative sum and their frequencies\n        freq = {0: 1}\n        curr_sum = 0\n        count = 0\n\n        # Iterate over the array\n        for num in arr:\n            # Update the cumulative sum\n            curr_sum += num\n\n            # Check if the cumulative sum minus the given sum exists in the hash map\n            if curr_sum - Sum in freq:\n                # If it exists, increment the count by the frequency of the cumulative sum minus the given sum\n                count += freq[curr_sum - Sum]\n\n            # Update the frequency of the cumulative sum\n            freq[curr_sum] = freq.get(curr_sum, 0) + 1\n\n        return count\n```\n\nThis solution works in O(N) time complexity and O(N) auxiliary space complexity, where N is the size of the array.\n\nExample usage:\n\n```python\nsolution = Solution()\n\n# Example 1\narr = [10, 2, -2, -20, 10]\nn = 5\nSum = -10\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 3\n\n# Example 2\narr = [1, 4, 20, 3, 10, 5]\nn = 6\nSum = 33\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 1\n```"}, {"generated_text": "To solve this problem, we can use the concept of prefix sum and a hashmap to store the cumulative sum and its frequency. The idea is to iterate through the array and for each element, we calculate the cumulative sum and check if the hashmap already contains this sum. If it does, it means we have found a subarray with the given sum, so we increment the count. If not, we add the cumulative sum to the hashmap.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):\n        prefix_sum = 0\n        hashmap = {0: 1}  # Initialize hashmap with 0 sum and its frequency as 1\n        count = 0\n\n        for i in range(n):\n            prefix_sum += arr[i]\n            if prefix_sum - Sum in hashmap:\n                count += hashmap[prefix_sum - Sum]\n            hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1  # Update hashmap with the new cumulative sum\n\n        return count\n```\n\nThis code has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array. The hashmap is used to store the cumulative sum and its frequency, and it is updated in each iteration of the loop.\n\nExample usage:\n\n```python\nsolution = Solution()\narr = [10, 2, -2, -20, 10]\nn = len(arr)\nSum = -10\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 3\n\narr = [1, 4, 20, 3, 10, 5]\nn = len(arr)\nSum = 33\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 1\n```"}, {"generated_text": "To solve this problem, we can use the concept of prefix sum and a hashmap to store the prefix sums. The idea is to traverse the array, calculate the prefix sum at each step, and store it in the hashmap. If the hashmap contains a key that is equal to the current prefix sum minus the given sum, it means we have found a subarray that adds up to the given sum, so we increment the count.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):  \n        prefix_sum = 0\n        hashmap = {0: 1}  # Initialize hashmap with 0:1\n        count = 0\n        \n        for num in arr:\n            prefix_sum += num\n            count += hashmap.get(prefix_sum - Sum, 0)\n            hashmap[prefix_sum] = hashmap.get(prefix_sum, 0) + 1\n        \n        return count\n```\n\n**Explanation:**\n\n1. We initialize a hashmap with 0:1 to handle the case when the sum of the subarray is equal to the given sum.\n2. We iterate through the array, calculate the prefix sum at each step, and store it in the hashmap.\n3. For each prefix sum, we check if the hashmap contains a key that is equal to the current prefix sum minus the given sum. If it does, we increment the count by the value of that key.\n4. Finally, we return the count of subarrays that add up to the given sum.\n\n**Time Complexity:** O(N)\n**Auxiliary Space:** O(N)\n\nThis solution meets the expected time complexity and auxiliary space complexity. It uses a single pass through the array and a hashmap to store the prefix sums, making it efficient for large inputs."}, {"generated_text": "To solve this problem, we can use the concept of prefix sum and a hashmap to store the prefix sums we have seen so far and their frequencies. \n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self,arr, n, Sum):\n        # Initialize a hashmap to store the prefix sums and their frequencies\n        prefix_sum_freq = {0: 1}\n        \n        # Initialize the current prefix sum and the count of subarrays with the given sum\n        curr_sum = 0\n        count = 0\n        \n        # Iterate over the array\n        for num in arr:\n            # Update the current prefix sum\n            curr_sum += num\n            \n            # Check if the difference between the current prefix sum and the given sum is in the hashmap\n            if curr_sum - Sum in prefix_sum_freq:\n                # If it is, increment the count by the frequency of the difference\n                count += prefix_sum_freq[curr_sum - Sum]\n            \n            # Update the frequency of the current prefix sum in the hashmap\n            prefix_sum_freq[curr_sum] = prefix_sum_freq.get(curr_sum, 0) + 1\n        \n        # Return the count of subarrays with the given sum\n        return count\n```\n\nThis code works as follows:\n\n1.  We initialize a hashmap `prefix_sum_freq` to store the prefix sums we have seen so far and their frequencies. We also initialize the current prefix sum `curr_sum` to 0 and the count of subarrays with the given sum to 0.\n2.  We iterate over the array. For each element, we update the current prefix sum by adding the element to it.\n3.  We check if the difference between the current prefix sum and the given sum is in the hashmap. If it is, we increment the count by the frequency of the difference. This is because if the difference is in the hashmap, it means we have seen a prefix sum that is equal to the given sum plus the difference, and this prefix sum is a subarray that adds up to the given sum.\n4.  We update the frequency of the current prefix sum in the hashmap.\n5.  Finally, we return the count of subarrays with the given sum.\n\nThis code has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the length of the array."}, {"generated_text": "To solve this problem, we can use a hashmap to store the cumulative sum of the array elements and their frequencies. We will iterate over the array and for each element, we will check if the cumulative sum minus the current sum exists in the hashmap. If it does, it means we have found a subarray with the given sum, so we will increment the count.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a hashmap to store cumulative sum and their frequencies\n        hashmap = {0: 1}\n        cumulative_sum = 0\n        count = 0\n        \n        # Iterate over the array\n        for num in arr:\n            cumulative_sum += num\n            \n            # Check if the cumulative sum minus the current sum exists in the hashmap\n            if cumulative_sum - Sum in hashmap:\n                count += hashmap[cumulative_sum - Sum]\n            \n            # Update the frequency of the cumulative sum in the hashmap\n            hashmap[cumulative_sum] = hashmap.get(cumulative_sum, 0) + 1\n        \n        return count\n```\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array.\n\nHere's an explanation of how the code works:\n\n1. We initialize a hashmap with a default value of 1 for the key 0, which represents the cumulative sum of an empty subarray.\n2. We iterate over the array and for each element, we update the cumulative sum.\n3. We check if the cumulative sum minus the current sum (i.e., the given sum) exists in the hashmap. If it does, it means we have found a subarray with the given sum, so we increment the count by the frequency of the cumulative sum minus the given sum in the hashmap.\n4. We update the frequency of the cumulative sum in the hashmap.\n5. Finally, we return the count of subarrays with the given sum.\n\nThis solution is efficient because it uses a hashmap to store the cumulative sum and their frequencies, which allows us to check if a cumulative sum minus the given sum exists in O(1) time."}, {"generated_text": "To solve this problem, we can use a HashMap to store the cumulative sum of the array elements and their frequencies. We'll iterate through the array, updating the cumulative sum and checking if the difference between the cumulative sum and the given sum exists in the HashMap. If it does, it means we've found a subarray with the given sum.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Create a HashMap to store cumulative sum and their frequencies\n        hashmap = {0: 1}\n        current_sum = 0\n        count = 0\n\n        # Iterate through the array\n        for i in range(n):\n            # Update the cumulative sum\n            current_sum += arr[i]\n\n            # Check if the difference between the cumulative sum and the given sum exists in the HashMap\n            if current_sum - Sum in hashmap:\n                # If it exists, increment the count by the frequency of the difference\n                count += hashmap[current_sum - Sum]\n\n            # Update the frequency of the current cumulative sum in the HashMap\n            hashmap[current_sum] = hashmap.get(current_sum, 0) + 1\n\n        return count\n```\n\nThis code works as follows:\n\n1.  It creates a HashMap to store the cumulative sum and their frequencies.\n2.  It initializes the cumulative sum to 0 and the count of subarrays to 0.\n3.  It iterates through the array, updating the cumulative sum and checking if the difference between the cumulative sum and the given sum exists in the HashMap.\n4.  If the difference exists, it increments the count by the frequency of the difference.\n5.  It updates the frequency of the current cumulative sum in the HashMap.\n6.  Finally, it returns the count of subarrays with the given sum.\n\nThis code has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array."}, {"generated_text": "Here is a Python program that uses a HashMap to store the cumulative sum of the array elements and their frequencies. The idea is to use a HashMap to store the cumulative sum and its frequency. For each element in the array, we calculate the cumulative sum by adding the current element to the previous cumulative sum. We then check if the cumulative sum minus the given sum is already present in the HashMap. If it is, it means we have found a subarray with the given sum, so we increment the count. If not, we add the cumulative sum and its frequency to the HashMap.\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Create a HashMap to store cumulative sum and its frequency\n        cumulative_sum_freq = {0: 1}\n        cumulative_sum = 0\n        count = 0\n        \n        # Iterate over the array\n        for num in arr:\n            # Calculate the cumulative sum\n            cumulative_sum += num\n            \n            # Check if the cumulative sum minus the given sum is already present in the HashMap\n            if cumulative_sum - Sum in cumulative_sum_freq:\n                # If it is, increment the count by the frequency of the cumulative sum minus the given sum\n                count += cumulative_sum_freq[cumulative_sum - Sum]\n            \n            # Add the cumulative sum and its frequency to the HashMap\n            cumulative_sum_freq[cumulative_sum] = cumulative_sum_freq.get(cumulative_sum, 0) + 1\n        \n        return count\n```\n\n**Time Complexity:** O(N)\n**Auxiliary Space:** O(N)\n\nThis solution works by iterating over the array once, and for each element, it performs a constant amount of work. The HashMap operations (insertion and lookup) take O(1) time on average. Therefore, the overall time complexity is O(N).\n\nThe auxiliary space complexity is O(N) because in the worst case, we might need to store all elements of the array in the HashMap."}, {"generated_text": "To solve this problem, we can use a hashmap to store the cumulative sum and its frequency. The idea is to traverse the array and for each element, we calculate the cumulative sum. If the cumulative sum minus the given sum exists in the hashmap, it means we have found a subarray that adds up to the given sum. We then increment the count by the frequency of the cumulative sum minus the given sum.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def findSubarraySum(self, arr, n, Sum):\n        # Initialize a hashmap to store the cumulative sum and its frequency\n        hashmap = {0: 1}\n        cumulative_sum = 0\n        count = 0\n        \n        # Traverse the array\n        for num in arr:\n            # Calculate the cumulative sum\n            cumulative_sum += num\n            \n            # If the cumulative sum minus the given sum exists in the hashmap, increment the count\n            if cumulative_sum - Sum in hashmap:\n                count += hashmap[cumulative_sum - Sum]\n            \n            # Update the frequency of the cumulative sum in the hashmap\n            hashmap[cumulative_sum] = hashmap.get(cumulative_sum, 0) + 1\n        \n        return count\n```\n\nThis solution has a time complexity of O(N) and an auxiliary space complexity of O(N), where N is the number of elements in the array.\n\nExample usage:\n\n```python\nsolution = Solution()\narr = [10, 2, -2, -20, 10]\nn = 5\nSum = -10\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 3\n\narr = [1, 4, 20, 3, 10, 5]\nn = 6\nSum = 33\nprint(solution.findSubarraySum(arr, n, Sum))  # Output: 1\n```"}]}