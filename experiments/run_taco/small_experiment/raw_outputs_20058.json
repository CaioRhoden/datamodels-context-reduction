{"id": 20058, "input": "You are given a binary string of length $n$. You have exactly $k$ moves. In one move, you must select a single bit. The state of all bits except that bit will get flipped ($0$ becomes $1$, $1$ becomes $0$). You need to output the lexicographically largest string that you can get after using all $k$ moves. Also, output the number of times you will select each bit. If there are multiple ways to do this, you may output any of them.\n\nA binary string $a$ is lexicographically larger than a binary string $b$ of the same length, if and only if the following holds:\n\nin the first position where $a$ and $b$ differ, the string $a$ contains a $1$, and the string $b$ contains a $0$.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)  \u2014 the number of test cases.\n\nEach test case has two lines. The first line has two integers $n$ and $k$ ($1 \\leq n \\leq 2 \\cdot 10^5$; $0 \\leq k \\leq 10^9$).\n\nThe second line has a binary string of length $n$, each character is either $0$ or $1$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two lines.\n\nThe first line should contain the lexicographically largest string you can obtain.\n\nThe second line should contain $n$ integers $f_1, f_2, \\ldots, f_n$, where $f_i$ is the number of times the $i$-th bit is selected. The sum of all the integers must be equal to $k$.\n\n\n-----Examples-----\n\nInput\n6\n6 3\n100001\n6 4\n100011\n6 0\n000000\n6 1\n111001\n6 11\n101100\n6 12\n001110\nOutput\n111110\n1 0 0 2 0 0 \n111110\n0 1 1 1 0 1 \n000000\n0 0 0 0 0 0 \n100110\n1 0 0 0 0 0 \n111111\n1 2 1 3 0 4 \n111110\n1 1 4 2 0 4\n\n\n-----Note-----\n\nHere is the explanation for the first testcase. Each step shows how the binary string changes in a move.\n\nChoose bit $1$: ${\\underline{1}00001} \\rightarrow {\\underline{1}}\\color{blue}{11110}$.\n\nChoose bit $4$: ${111\\underline{1}10} \\rightarrow \\color{blue}{000}{\\underline{1}}\\color{blue}{01}$.\n\nChoose bit $4$: ${000\\underline{1}01} \\rightarrow \\color{blue}{111}{\\underline{1}}\\color{blue}{10}$.\n\nThe final string is $111110$ and this is the lexicographically largest string we can get.\n", "difficulty": "EASY", "generations": [{"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the result string and the count array\n    result = ['0'] * n\n    count = [0] * n\n\n    # If k is even, the result string will be the same as the input string\n    if k % 2 == 0:\n        return ''.join(result), count\n\n    # If k is odd, flip the bits in the input string\n    result = ['1' if c == '0' else '0' for c in s]\n\n    # Initialize the count of the first bit to be flipped\n    count[0] = 1\n\n    # Initialize the number of bits to be flipped\n    bits_to_flip = k - 1\n\n    # Iterate over the input string\n    for i in range(1, n):\n        # If the current bit is different from the previous bit\n        if s[i]!= s[i - 1]:\n            # If there are bits to be flipped, flip the current bit\n            if bits_to_flip > 0:\n                result[i] = '1' if result[i] == '0' else '0'\n                count[i] += 1\n                bits_to_flip -= 1\n            # If there are no bits to"}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    if k >= n:\n        print('1' * n)\n        print(*[1] * n)\n        return\n\n    # flip all bits to the right of the first 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == '1':\n            for j in range(i, n):\n                s = s[:j] + '1' if s[j] == '0' else '0' + s[j+1:]\n            break\n\n    # flip k bits to the right of the first 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == '0':\n            s = s[:i] + '1' if k > 0 else s\n            k -= 1\n\n    # flip the rest of the bits\n    for i in range(n - 1, -1, -1):\n        if s[i] == '0' and k > 0:\n            s = s[:i] + '1' if s[i] == '0' else '0' + s[i+1:]\n            k -= 1\n\n"}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    # Initialize count array with zeros\n    count = [0] * n\n\n    # If k is even, flip all bits\n    if k % 2 == 0:\n        s = ''.join('1' if c == '0' else '0' for c in s)\n    else:\n        # If k is odd, flip all bits except the first one\n        s = '1' + ''.join('1' if c == '0' else '0' for c in s[1:])\n\n    # Count the number of times each bit is selected\n    for i in range(n):\n        if s[i] == '1':\n            if k > 0:\n                count[i] = k\n                k = 0\n            else:\n                count[i] = 0\n        else:\n            count[i] = 1\n\n    # Subtract 1 from the count of bits that were flipped\n    for i in range(n):\n        if s[i] == '0':\n            count[i] -= 1\n\n    # Print the lexicographically largest string\n    print(''.join('1' if c == '0' else '0"}, {"generated_text": "Here is the Python program that solves the problem:\n\n```python\ndef solve(n, k, s):\n    ans = ['0'] * n\n    count = [0] * n\n    for i in range(n):\n        if k >= n - i:\n            ans[i] = '1'\n            count[i] = n - i\n            k -= n - i\n        else:\n            ans[i] = '1' if s[i] == '0' else '0'\n            count[i] = k\n            k = 0\n    return ''.join(ans), count\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    s = input()\n    result, count = solve(n, k, s)\n    print(result)\n    print(*count)\n```\n\nThis program works by iterating over the bits in the binary string from left to right. If there are enough moves left to flip all the remaining bits, it sets the current bit to 1 and counts the number of moves used to flip this bit. Otherwise, it flips the current bit if it is 0 (to get the lexicographically largest string) and counts the number of moves used to flip this bit. The result is the lexicographically largest string that can be obtained and the number of times each bit"}, {"generated_text": "Here is the Python program to solve the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the result string and the count array\n    result = ['0'] * n\n    count = [0] * n\n\n    # If k is greater than or equal to n, flip all bits\n    if k >= n:\n        for i in range(n):\n            result[i] = '1' if i % 2 == 0 else '0'\n        for i in range(n):\n            count[i] = 1 if i % 2 == 0 else 0\n        return ''.join(result), count\n\n    # If k is 0, return the original string\n    if k == 0:\n        return s, count\n\n    # Find the first 1 from the right\n    first_one = n - 1\n    while first_one >= 0 and s[first_one] == '0':\n        first_one -= 1\n\n    # If there is no 1, return the original string\n    if first_one == -1:\n        return s, count\n\n    # Flip the bits to the right of the first 1\n    for i in range(first_one + 1, n):\n        result[i] = '1' if s[i] == '0' else '0'\n\n"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the count array with zeros\n    count = [0] * n\n\n    # Initialize the result string with zeros\n    result = ['0'] * n\n\n    # If k is even, we can simply flip all bits\n    if k % 2 == 0:\n        result = ['1' if bit == '0' else '0' for bit in s]\n    else:\n        # If k is odd, we need to flip the bits in the middle\n        mid = n // 2\n        for i in range(mid):\n            if k >= 2 and (s[i] == '0' or s[i] == s[mid + i]):\n                result[i] = '1' if s[i] == '0' else '0'\n                count[i] = 1\n                k -= 1\n                if k == 0:\n                    break\n            if k > 0 and s[i] == '1':\n                result[i] = '0'\n                count[i] = 1\n                k -= 1\n\n        # Flip the rest of the bits\n        for i in range(mid, n):\n            if s[i] == '1':\n                result[i] = '0'\n"}, {"generated_text": "Here is the Python code to solve the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the result string and count array\n    result = ['0'] * n\n    count = [0] * n\n\n    # If k is greater than or equal to n, flip all bits\n    if k >= n:\n        result = ['1' if i % 2 == 0 else '0' for i in range(n)]\n        count = [n // 2] * n\n        return ''.join(result), count\n\n    # Calculate the number of times each bit will be flipped\n    for i in range(n):\n        if (n - i - 1) % 2 == 0:\n            count[i] = min(k, (n - i - 1) // 2 + 1)\n        else:\n            count[i] = min(k, (n - i - 1) // 2)\n\n    # Update k\n    k -= sum(count)\n\n    # Flip the bits that will be flipped\n    for i in range(n):\n        if count[i] > 0:\n            result[i] = '1' if s[i] == '0' else '0'\n            count[i] -= 1\n            if k > 0:\n                # Flip the remaining bits\n"}, {"generated_text": "Here's a Python program that will solve the given problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the count of each bit\n    count = [0] * n\n\n    # If k is greater than or equal to n, the lexicographically largest string is the string with all 1s\n    if k >= n:\n        print('1' * n)\n        print('1'* (n - 1) + str(k))\n        return\n\n    # If k is 0, the lexicographically largest string is the original string\n    if k == 0:\n        print(s)\n        print(*count)\n        return\n\n    # Find the first bit that can be flipped to get the lexicographically largest string\n    for i in range(n):\n        if s[i] == '0':\n            count[i] += k\n            print('1', end='')\n            break\n\n    # Flip the bits to the right of the first bit\n    for i in range(i + 1, n):\n        if s[i] == '1':\n            count[i] += k\n            print('0', end='')\n        else:\n            print('1', end='')\n\n    # Print the remaining bits\n    for i in range(i + 1, n):\n        print(s[i], end='')\n\n"}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    res = ['0'] * n\n    count = [0] * n\n    for i in range(n):\n        if k >= n - i:\n            res[i] = '1'\n            count[i] = n - i\n            k -= n - i\n        else:\n            res[i] = '1' if s[i] == '0' else '0'\n            count[i] = k\n            k = 0\n    print(''.join(res))\n    print(*count)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by first checking if we have enough moves to flip all the bits to the right of the current bit. If we do, we flip all those bits and decrement the count of moves. If we don't, we simply flip the current bit and decrement the count of moves. This way, we ensure that the resulting string is lexicographically largest. The count of moves for each bit is also correctly calculated."}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    # Count the number of 1s in the string\n    ones = s.count('1')\n\n    # If k is greater than or equal to the number of 1s, flip all 1s and 0s\n    if k >= ones:\n        s = ''.join('1' if c == '0' else '0' for c in s)\n        k -= ones\n    else:\n        # Flip the bits to get the lexicographically largest string\n        s = ''.join('1' if c == '0' else '0' for c in s)\n\n        # Flip the bits at the positions of the ones\n        for i in range(n):\n            if s[i] == '1':\n                s = s[:i] + '0' + s[i+1:]\n                k -= 1\n\n    # Print the lexicographically largest string\n    print(s)\n\n    # Print the number of times each bit is selected\n    count = [0] * n\n    for i in range(n):\n        if s[i] == '1':\n            count[i] = 1\n        else:\n            count[i] = k\n            k ="}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    ans = [''] * n\n    count = [0] * n\n    for i in range(n):\n        if k % 2 == 1:\n            ans[i] = '1'\n            count[i] += 1\n            k -= 1\n        elif s[i] == '0' and k > 0:\n            ans[i] = '1'\n            count[i] += 1\n            k -= 1\n        elif s[i] == '1' and k > 1:\n            ans[i] = '0'\n            count[i] += 2\n            k -= 2\n    for i in range(n):\n        if k > 0 and s[i] == '0':\n            ans[i] = '1'\n            count[i] += 1\n            k -= 1\n    for i in range(n):\n        if k > 0 and s[i] == '1':\n            ans[i] = '0'\n            count[i] += 1\n            k -= 1\n    print(''.join(ans))\n    print(*count)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\n"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize a list to store the count of each bit\n    counts = [0] * n\n\n    # Initialize a variable to store the number of 1s in the string\n    ones = s.count('1')\n\n    # If k is greater than or equal to n/2, the lexicographically largest string is all 1s\n    if k >= n // 2:\n        return '1' * n, [n // 2] * (n % 2) + [n // 2 + 1] * (n % 2)\n\n    # If k is less than or equal to n/2, the lexicographically largest string is all 1s except for k 0s\n    if k <= n // 2:\n        for i in range(n):\n            if s[i] == '0' and k > 0:\n                counts[i] = 1\n                k -= 1\n        return '1' * n, counts\n\n    # If k is greater than n/2, the lexicographically largest string is all 1s except for k-n/2 1s\n    for i in range(n):\n        if s[i] == '1' and"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    # Count the number of 1s and 0s\n    ones = s.count('1')\n    zeros = n - ones\n\n    # If k is greater than or equal to n//2, \n    # we can simply flip all bits and then flip the remaining bits\n    if k >= n // 2:\n        result = ['1'] * n\n        for i in range(n):\n            if k % 2 == 1:\n                result[i] = '0'\n            k = (k + 1) // 2\n        print(''.join(result))\n        print(*[1] * n)\n    else:\n        # If k is less than n//2, \n        # we need to find the optimal way to flip the bits\n        if k % 2 == 0:\n            result = ['1'] * n\n            for i in range(n):\n                if s[i] == '0':\n                    result[i] = '1'\n        else:\n            result = ['1'] * n\n            for i in range(n):\n                if s[i] == '0':\n                    result[i] = '1'\n                if s[i]"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef get_result(n, k, s):\n    # Initialize the count array\n    count = [0] * n\n\n    # If k is even, the final string will be the same as the original string\n    if k % 2 == 0:\n        return s, count\n\n    # If k is odd, the final string will be the lexicographically largest string\n    result = ['1'] * n\n    for i in range(n):\n        if k % 2 == 1:\n            result[i] = '1' if s[i] == '0' else '0'\n            count[i] += 1\n            k -= 1\n        if k == 0:\n            break\n\n    # Flip the bits that are not selected\n    for i in range(n):\n        if result[i] == '0' and k > 0:\n            result[i] = '1'\n            count[i] += 1\n            k -= 1\n\n    return ''.join(result), count\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        result, count = get_result(n, k, s)\n        print(result)\n        print(*"}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize the count array with zeros\n    count = [0] * n\n\n    # Initialize the result string\n    result = ['0'] * n\n\n    # If k is even, we can flip all bits\n    if k % 2 == 0:\n        result = ['1'] * n\n    else:\n        # If k is odd, we need to flip the bits with even indices\n        for i in range(0, n, 2):\n            result[i] = '1'\n\n    # Calculate the number of times each bit is selected\n    for i in range(n):\n        if result[i] == '1':\n            count[i] = k\n            if i + 1 < n:\n                count[i + 1] += k\n            break\n        else:\n            if i + 1 < n:\n                count[i + 1] += k\n\n    # Adjust the counts for the bits that are flipped\n    for i in range(n):\n        if result[i] == '0':\n            count[i] = k - count[i]\n\n    return ''.join(result),''.join(map(str, count))\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n"}, {"generated_text": "```python\ndef lexicographically_largest_string(n, k, s):\n    \"\"\"\n    This function generates the lexicographically largest binary string \n    that can be obtained after using k moves. It also counts the number of \n    times each bit is selected.\n\n    Parameters:\n    n (int): The length of the binary string.\n    k (int): The number of moves.\n    s (str): The binary string.\n\n    Returns:\n    tuple: A tuple containing the lexicographically largest string and a list \n    of counts for each bit.\n    \"\"\"\n    # Initialize the counts for each bit\n    counts = [0] * n\n\n    # If k is even, the final string will be the same as the initial string\n    if k % 2 == 0:\n        return s, counts\n\n    # If k is odd, the final string will be the bitwise NOT of the initial string\n    else:\n        final_string = ''.join('1' if c == '0' else '0' for c in s)\n        return final_string, counts\n\n    # If k is greater than n, we need to make all bits equal to 1\n    if k > n:\n        # Calculate the number of bits that need to be flipped to make all bits 1\n        k -= n\n        # Flip the"}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef solve(n, k, s):\n    # Initialize count array\n    count = [0] * n\n\n    # If k is greater than or equal to n/2, flip all bits\n    if k >= n // 2:\n        s = ''.join('1' if c == '0' else '0' for c in s)\n    else:\n        # Find the first 1 from the left\n        i = s.find('1')\n        \n        # Flip all bits to the left of the first 1\n        s = '0' * i + '1' + '0' * (n - i - 1)\n\n        # Update count\n        count[i] = k\n\n        # Update k\n        k -= count[i]\n\n        # Flip bits to the right of the first 1\n        s = s[:i] + ''.join('1' if c == '0' else '0' for c in s[i+1:])\n\n        # Update count\n        count[i+1:] = [1] * k\n\n    # Print the lexicographically largest string\n    print(s)\n\n    # Print the count array\n    print(' '.join(map(str, count)))\n\nt = int(input())\nfor _ in range(t):\n   "}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    ans = ['0'] * n\n    cnt = [0] * n\n\n    for i in range(n):\n        if k >= n // 2 and s[i] == '0':\n            ans[i] = '1'\n            k -= 1\n        elif k >= n // 2 and s[i] == '1':\n            ans[i] = '0'\n            k -= 1\n        elif k >= (n - i - 1) // 2 and s[i] == '0':\n            ans[i] = '1'\n            cnt[i] += 1\n            k -= (n - i - 1) // 2\n        elif k >= (n - i - 1) // 2 and s[i] == '1':\n            ans[i] = '0'\n            cnt[i] += 1\n            k -= (n - i - 1) // 2\n\n    if k > 0:\n        for i in range(n):\n            if s[i] == '1':\n                cnt[i] += k\n                break\n\n    print(''.join(ans))\n    print(*cnt)\n\nt = int(input())\nfor"}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef solve(n, k, s):\n    res = ['0'] * n\n    count = [0] * n\n    if k % 2 == 0:\n        for i in range(n):\n            if s[i] == '0':\n                res[i] = '1'\n            else:\n                res[i] = '0'\n    else:\n        for i in range(n):\n            if s[i] == '0':\n                res[i] = '0'\n                count[i] += 1\n            else:\n                res[i] = '1'\n                count[i] += 1\n        k -= 1\n        for i in range(n):\n            if res[i] == '0' and k >= 1:\n                count[i] += 1\n                k -= 2\n                for j in range(n):\n                    if i!= j:\n                        res[j] = '1' if res[j] == '0' else '0'\n                break\n        for i in range(n):\n            if k >= 1:\n                count[i] += 1\n                k -= 2\n                for j in range(n):\n                    if i!= j:\n                        res[j] = '1' if res[j] == '0' else '0'\n"}, {"generated_text": "Here is a Python solution for the problem:\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    if k == 0:\n        print(''.join(s))\n        print(*[0]*n)\n        return\n    ans = [0]*n\n    cnt = 0\n    for i in range(n):\n        if k >= n - i and s[i] == '0':\n            ans[i] = n - i\n            k -= n - i\n            cnt += 1\n        elif k >= n - i and s[i] == '1':\n            ans[i] = n - i\n            k -= n - i\n            cnt += 1\n        else:\n            if s[i] == '0':\n                ans[i] = k\n                k = 0\n            else:\n                ans[i] = k\n                k = 0\n    if k > 0:\n        ans[s.rfind('0')] += k\n    print(''.join('1' if x > 0 else '0' for x in ans))\n    print(*ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis solution first checks if `k` is 0. If it is, it simply prints the"}]}