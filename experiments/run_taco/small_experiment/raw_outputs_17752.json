{"id": 17752, "input": "You are given a bracket sequence consisting of $n$ characters '(' and/or )'. You perform several operations with it.\n\nDuring one operation, you choose the shortest prefix of this string (some amount of first characters of the string) that is good and remove it from the string.\n\nThe prefix is considered good if one of the following two conditions is satisfied:\n\nthis prefix is a regular bracket sequence;\n\nthis prefix is a palindrome of length at least two.\n\nA bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not.\n\nThe bracket sequence is called palindrome if it reads the same back and forth. For example, the bracket sequences )), (( and )(() are palindromes, while bracket sequences (), )( and ))( are not palindromes.\n\nYou stop performing the operations when it's not possible to find a good prefix. Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The next $2t$ lines describe test cases.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$) \u2014 the length of the bracket sequence.\n\nThe second line of the test case contains $n$ characters '(' and/or ')' \u2014 the bracket sequence itself.\n\nIt is guaranteed that the sum of $n$ over all test cases do not exceed $5 \\cdot 10^5$ ($\\sum n \\le 5 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each test case, print two integers $c$ and $r$ \u2014 the number of operations you will perform on the given bracket sequence and the number of characters that remain in the string after performing all operations.\n\n\n-----Examples-----\n\nInput\n5\n2\n()\n3\n())\n4\n((((\n5\n)((()\n6\n)((()(\nOutput\n1 0\n1 1\n2 0\n1 0\n1 1\n\n\n-----Note-----\n\nNone\n", "difficulty": "EASY", "generations": [{"generated_text": "Here is a Python program to solve the given problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ans = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            ans += 1\n        else:\n            j = i\n            while j < n - 1 and s[j]!= s[j + 1]:\n                j += 1\n            if j < n - 1 and s[j] == s[j + 1]:\n                i = j + 2\n                ans += 1\n            else:\n                break\n    print(ans, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by maintaining a pointer `i` to the current position in the string. It checks if the current character and the next one form a `()`, if so, it moves the pointer two positions forward and increments the answer. If not, it tries to find a palindrome starting from the current position. If it finds one, it moves the pointer to the end of the palindrome and increments the answer. If it cannot find a palindrome, it breaks the loop and prints the answer and the remaining characters in the string.\n\nThe time complexity of this program is O(n), where n is the length of the string. The space complexity is O(1), as it only uses a constant amount of space."}, {"generated_text": "Here is a Python program that solves the problem:\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ans = 0\n    while i < n:\n        if s[i] == '(':\n            i += 2\n            ans += 1\n        else:\n            j = i + 1\n            while j < n and s[j] == '(':\n                j += 1\n            if j == n:\n                break\n            if s[j] == ')':\n                i = j + 2\n                ans += 1\n            else:\n                k = j + 1\n                while k < n and s[k]!= s[j]:\n                    k += 1\n                if k == n:\n                    break\n                i = k + 1\n                ans += 1\n    print(ans, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\nThis program uses a simple iterative approach to solve the problem. It maintains a pointer `i` to the current position in the string, and it increments `i` by 1 or 2 depending on whether it encounters a `(` or a `)` followed by a `(`. If it encounters a `)` followed by a `(`, it tries to find the next matching `)` by iterating over the string. If it finds a matching `)`, it increments `i` by 2 and increments the answer count. If it doesn't find a matching `)`, it increments `i` by 1 and continues. If it reaches the end of the string without finding a matching `)`, it breaks out of the loop.\n\nThe program then prints the answer count and the remaining characters in the string.\n\nYou can run this program with the provided test cases to see the output."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ans = 0\n    while i < n - 1:\n        if s[i] == '(' and i + 1 < n and s[i + 1] == ')':\n            i += 2\n            ans += 1\n        else:\n            j = i + 1\n            while j < n and s[j]!= s[i]:\n                j += 1\n            if j == n:\n                break\n            else:\n                i = j\n                ans += 1\n    print(ans, n - i - 1)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and checking for two types of good prefixes:\n\n1.  A regular bracket sequence: If the current character is an open bracket and the next character is a close bracket, we can remove these two characters and increment our answer.\n2.  A palindrome: If the current character is not an open bracket and close bracket pair, we try to find the longest palindrome starting from the current position. We do this by moving the right end of the palindrome to the right as long as it is still a palindrome. If we reach the end of the string without finding a palindrome, we break the loop. Otherwise, we update our answer and the position of the left end of the palindrome.\n\nFinally, we print the number of operations and the number of remaining characters in the string."}, {"generated_text": "Here's a Python program that solves the given problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    i = 0\n    operations = 0\n    while i < n:\n        if i + 1 < n and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n        else:\n            j = i + 1\n            while j < n and s[j]!= s[i]:\n                j += 1\n            if j == n:\n                break\n            i = j + 1\n        operations += 1\n\n    print(operations, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing the following operations:\n\n- If the current character and the next one are both opening or closing brackets, it moves two positions forward.\n- Otherwise, it finds the matching closing bracket for the current opening bracket (or vice versa) and moves the index to the position after the matching bracket. If no matching bracket is found, it breaks the loop.\n\nThe number of operations performed is the number of times the loop runs, and the number of remaining characters is the difference between the length of the string and the final index.\n\nThe program then prints the number of operations and the number of remaining characters for each test case."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef find_next_prefix(s, i):\n    stack = []\n    for j in range(i, len(s)):\n        if s[j] == '(':\n            stack.append(s[j])\n        else:\n            if stack:\n                stack.pop()\n            else:\n                return j\n    return len(s)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    i = 0\n    operations = 0\n    while i < n:\n        next_i = find_next_prefix(s, i)\n        if next_i == i + 1:\n            i += 1\n        else:\n            operations += 1\n            i = next_i + 1\n    remaining = n - i\n    print(operations, remaining)\n```\n\nThis program works by iterating over the string and finding the next prefix that is either a regular bracket sequence or a palindrome. If it finds such a prefix, it increments the operations counter and moves the index to the end of the prefix. If it doesn't find a prefix, it moves the index forward by one character. Finally, it prints the number of operations and the number of remaining characters."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\nimport sys\n\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ops = 0\n    while i < n:\n        if s[i] == '(':\n            i += 2\n            ops += 1\n        else:\n            j = i + 1\n            while j < n and s[j]!= ')':\n                j += 1\n            if j == n:\n                break\n            else:\n                i = j + 1\n                ops += 1\n    print(ops, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing operations whenever it finds a good prefix. If it finds a '(' followed by another ')', it increments the index by 2 and the number of operations. If it finds a ')' followed by a '(' or another ')', it keeps incrementing the index until it finds a matching ')'. It then increments the number of operations and the index. If it reaches the end of the string without finding a matching ')', it breaks out of the loop. Finally, it prints the number of operations and the remaining characters in the string.\n\nThis program has a time complexity of O(n) where n is the length of the string, because it makes one pass over the string. The space complexity is O(1) because it uses a constant amount of space to store the index and the number of operations."}, {"generated_text": "Here is a Python program to solve the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ans = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            ans += 1\n        else:\n            j = i + 1\n            while j < n and s[i] == s[j]:\n                j += 1\n            if j == n or (j - i >= 2 and s[i] == s[j - 1]):\n                i = j\n                ans += 1\n            else:\n                break\n    print(ans, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing operations whenever a good prefix is found. If no good prefix is found, it stops and prints the number of operations and the remaining characters. The time complexity of this program is O(n), where n is the length of the string."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    i = 0\n    ans = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n        else:\n            j = i + 1\n            while j < n and s[i] == s[j]:\n                j += 1\n            if j == n or (j - i > 1 and s[i] == s[j - 1]):\n                i = j\n                ans += 1\n            else:\n                break\n    print(ans, n - i)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and checking if the current character and the next one form a closing parenthesis after an opening one. If they do, it moves two positions forward. Otherwise, it tries to find the next matching character (either an opening or closing parenthesis) and removes the prefix up to that point if it's a palindrome of length at least two or a single opening parenthesis. If it can't find a matching character, it breaks the loop and prints the number of operations and the remaining characters."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    ans = 0\n    while i < n - 1:\n        if s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            ans += 1\n        elif s[i] == '(':\n            i += 1\n            ans += 1\n            while i < n and s[i] == '(':\n                i += 1\n        else:\n            left = i\n            while i < n and s[i]!= ')':\n                i += 1\n            if i == n:\n                break\n            right = i\n            while left < right:\n                if s[left]!= s[right]:\n                    break\n                left -= 1\n                right += 1\n            if left >= right:\n                i += 1\n                ans += 1\n    print(ans, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing the following operations:\n\n- If the current character and the next one are both '(', we increment `i` by 2 and `ans` by 1.\n- If the current character is '(', we increment `i` by 1 and `ans` by 1, and then we keep incrementing `i` as long as we encounter more '(' characters.\n- If the current character is ')', we try to find a matching '(' character on the left side of the string. If we find one, we increment `i` by 1 and `ans` by 1. If we don't find one, we break the loop.\n\nAfter the loop, we print the number of operations (`ans`) and the number of remaining characters (`n - i`)."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef is_palindrome(s, i, j):\n    while i < j:\n        if s[i]!= s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    operations = 0\n    while i < n:\n        if s[i] == '(':\n            i += 2\n            operations += 1\n        else:\n            j = i + 1\n            found = False\n            while j < n:\n                if s[j] == '(':\n                    j += 1\n                elif is_palindrome(s, i, j):\n                    found = True\n                    break\n                else:\n                    j += 1\n            if found:\n                i = j + 1\n                operations += 1\n            else:\n                break\n    print(operations, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program defines a helper function `is_palindrome` to check if a substring of `s` from index `i` to `j` is a palindrome. It then defines the `solve` function to solve the problem. The `solve` function reads the input, initializes variables, and enters a loop to perform operations until it's not possible to find a good prefix. Finally, it prints the number of operations and the remaining characters. The program uses a loop to read `t` test cases and solve each one."}, {"generated_text": "Here's a Python program that solves the given problem:\n\n```python\ndef solve(s):\n    stack = []\n    n = len(s)\n    operations = 0\n    remaining = n\n\n    for i in range(n):\n        if s[i] == '(':\n            stack.append('(')\n        else:\n            if stack:\n                stack.pop()\n            else:\n                while i + 1 < n and s[i + 1] == '(':\n                    i += 1\n                    operations += 1\n                    remaining -= 2\n                if i + 1 < n and s[i + 1] == ')':\n                    i += 1\n                    operations += 1\n                    remaining -= 2\n\n    return operations, remaining\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    operations, remaining = solve(s)\n    print(operations, remaining)\n```\n\nThis program works as follows:\n\n- It uses a stack to keep track of the opening brackets.\n- It iterates over the string, and for each closing bracket, it checks if the stack is empty. If it is, it means there's no matching opening bracket, so it tries to find the next opening bracket in the string.\n- If it finds the next opening bracket, it increments the operations counter and decrements the remaining counter by 2.\n- If it can't find the next opening bracket, it simply increments the operations counter and decrements the remaining counter by 2.\n- Finally, it prints the number of operations and the remaining characters."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\ndef is_palindrome(s, i, j):\n    while i < j:\n        if s[i]!= s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    operations = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            operations += 1\n        elif i < n - 1 and s[i] == s[i + 1]:\n            i += 2\n            operations += 1\n        elif i < n - 1 and s[i]!= s[i + 1] and is_palindrome(s, i, n - 1):\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 2:\n                i = j\n                operations += 1\n            else:\n                break\n        else:\n            break\n    print(operations, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and checking for valid prefixes. If the prefix is a regular bracket sequence or a palindrome of length at least two, it removes the prefix and increments the operations counter. If no valid prefix is found, it stops and prints the number of operations and the remaining characters."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    operations = 0\n    remaining = n\n\n    i = 0\n    while i < n - 1:\n        if s[i] == '(' and i + 1 < n and s[i + 1] == ')':\n            i += 2\n            operations += 1\n            remaining -= 2\n        elif s[i] == s[i + 1]:\n            i += 2\n            operations += 1\n            remaining -= 2\n        elif i < n - 1 and s[i] == s[i + 1] == '(':\n            j = i + 2\n            while j < n and s[j] == '(':\n                j += 1\n            if j < n and s[j] == ')':\n                i = j + 1\n                operations += 1\n                remaining -= (j - i + 1)\n            else:\n                break\n        else:\n            break\n\n    print(operations, remaining)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing operations whenever a good prefix is found. It uses a while loop to check for regular bracket sequences and palindromes. If a good prefix is found, it removes the prefix and updates the remaining characters count. The loop continues until it's not possible to find a good prefix. The number of operations and remaining characters are then printed."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef is_regular(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return True\n\ndef solve():\n    n = int(input())\n    s = input()\n    i = 0\n    operations = 0\n    while i < n:\n        if i < n - 1 and s[i] == s[i + 1] == '(':\n            i += 2\n        elif i < n - 1 and s[i] == s[i + 1]:\n            i += 2\n        else:\n            j = i + 1\n            while j < n and s[j]!= s[i]:\n                j += 1\n            if j == n or (j < n and s[j]!= s[i]):\n                break\n            if is_regular(s[i:j + 1]):\n                i = j + 1\n            else:\n                i = j\n        operations += 1\n    print(operations, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program defines two helper functions: `is_regular` checks if a given string is a regular bracket sequence, and `solve` is the main function that reads the input, performs the operations, and prints the result.\n\nIn the `solve` function, we iterate over the string and perform the operations as described in the problem statement. We use two pointers, `i` and `j`, to find the shortest good prefix. If the prefix is a regular bracket sequence, we increment `i` by 2. If the prefix is a palindrome, we increment `i` by 2 if the characters at `i` and `i + 1` are both '(' or both ')'. Otherwise, we find the first pair of matching parentheses starting from `i + 1` and check if the substring between `i` and `j` is a regular bracket sequence. If it is, we increment `i` by 1; otherwise, we break the loop.\n\nFinally, we print the number of operations and the number of remaining characters."}, {"generated_text": "Here is a Python program that solves the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    op = 0\n    i = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n        else:\n            j = i + 1\n            while j < n and s[i] == s[j]:\n                j += 1\n            if j == n or (j - i >= 2 and s[i] == s[j - 1]):\n                op += 1\n                i = j\n            else:\n                break\n    print(op, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works as follows:\n\n1.  It first reads the length of the bracket sequence `n` and the sequence itself `s`.\n2.  It then enters a loop where it tries to find a good prefix of the sequence.\n3.  If it finds a good prefix (either a regular bracket sequence or a palindrome of length at least two), it removes the prefix from the sequence by incrementing the index `i` to the end of the prefix.\n4.  It then increments the number of operations `op` by 1.\n5.  If it cannot find a good prefix, it breaks out of the loop.\n6.  Finally, it prints the number of operations `op` and the remaining characters in the sequence `n - i`.\n\nThis program has a time complexity of O(n), where n is the length of the bracket sequence, because it potentially checks each character in the sequence once. The space complexity is O(1), because it uses a constant amount of space to store the index `i`, the number of operations `op`, and the sequence `s`."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    i = 0\n    ops = 0\n    while i < n - 1:\n        if s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            ops += 1\n        else:\n            j = i + 1\n            while j < n and (s[j]!= ')' or j < i or s[j]!= s[i]):\n                j += 1\n            if j == n:\n                break\n            i = j + 1\n            ops += 1\n    print(ops, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing operations whenever possible. It checks for a matching closing parenthesis, and if not, it tries to find a palindrome of length at least two. If it cannot find a palindrome, it breaks out of the loop and prints the number of operations and the remaining characters."}, {"generated_text": "Here's a Python solution for the given problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n    stack = []\n    ops = 0\n    i = 0\n    while i < n:\n        if s[i] == '(':\n            stack.append('(')\n            i += 1\n        else:\n            if stack:\n                stack.pop()\n                i += 1\n                if not stack:\n                    ops += 1\n            else:\n                j = i + 1\n                while j < n and (j == n or s[j] == '(' or (s[j] == ')' and s[j-1] == '(')):\n                    j += 1\n                if j == n:\n                    break\n                ops += 1\n                i = j\n    print(ops, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis solution works by maintaining a stack of opening brackets. When it encounters a closing bracket, it pops the stack. If the stack is empty after popping, it increments the operations counter. If the stack is not empty, it continues to the next character. If it encounters a closing bracket without a matching opening bracket, it tries to find a good prefix by scanning ahead. If it finds a good prefix, it increments the operations counter and moves the index to the end of the prefix. If it cannot find a good prefix, it breaks out of the loop and prints the operations counter and the remaining characters."}, {"generated_text": "Here's a Python program that solves the problem:\n\n```python\ndef count_operations(s):\n    n = len(s)\n    i = 0\n    operations = 0\n    while i < n - 1:\n        if s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            operations += 1\n        else:\n            j = i + 1\n            while j < n and (s[j] == '(' or s[j] == s[i]):\n                j += 1\n            if j == n or (s[j] == ')' and s[i] == '('):\n                break\n            i = j\n            operations += 1\n    return operations, n - i - 1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    operations, remaining = count_operations(s)\n    print(operations, remaining)\n```\n\nThis program works by iterating over the string and checking for regular bracket sequences and palindromes. When a good prefix is found, it removes it from the string and increments the operation count. The program stops when it cannot find a good prefix. The number of operations and the remaining characters are then printed."}, {"generated_text": "Here's a Python program that will solve the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    i = 0\n    ans = 0\n    while i < n:\n        if i < n - 1 and s[i] == '(' and s[i + 1] == ')':\n            i += 2\n            ans += 1\n        else:\n            j = i + 1\n            while j < n and s[i] == s[j]:\n                j += 1\n            if j - i >= 2:\n                i = j\n                ans += 1\n            else:\n                break\n\n    print(ans, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and checking for the two possible conditions for a good prefix:\n\n1. If the current character and the next character are both '(' and ')', then the prefix is a regular bracket sequence. In this case, we increment the index by 2 and the answer by 1.\n2. Otherwise, we try to find a palindrome of length at least 2 starting from the current character. We do this by iterating over the string and checking if the characters at the current index and the current index plus `k` are equal, where `k` is the length of the palindrome. If we find a palindrome, we increment the index by the length of the palindrome and the answer by 1. If we don't find a palindrome, we break out of the loop.\n\nFinally, we print the number of operations and the number of remaining characters in the string."}, {"generated_text": "Here's a Python program to solve the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    i = 0\n    operations = 0\n    while i < n - 1:\n        if s[i] == '(':\n            if i + 1 < n and s[i + 1] == ')':\n                i += 2\n            else:\n                i += 1\n        else:\n            j = i + 1\n            while j < n and s[j]!= s[i]:\n                j += 1\n            if j == n:\n                break\n            else:\n                i = j + 1\n        operations += 1\n\n    print(operations, n - i)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```\n\nThis program works by iterating over the string and performing operations whenever a good prefix is found. The `solve` function takes the length of the string and the string itself as input, and prints the number of operations and the remaining characters. The main loop reads the number of test cases and calls the `solve` function for each test case."}]}