{"id": 23532, "input": "Given a String S , print the reverse of the string as output.\nExample 1:\nInput: S = \"GeeksforGeeks\"\nOutput: \"skeeGrofskeeG\" \nExplanation: Element at first is at last and\nlast is at first, second is at second last and \nsecond last is at second position and so on .\nExample 2:\nInput: S = \"ReversE\"\nOutput: \"EsreveR\"\nExplanation: \"E\" at first and \"R\" at last and\n\"e\" at second last and \"s\" at second and\nso on .\nYour Task:  \nYou dont need to read input or print anything. Complete the function revStr() which takes S as input parameter and returns the reversed string .\nExpected Time Complexity: O(|S|)\nExpected Auxiliary Space: O(|S|)\nConstraints:\n1<= |S| <=1000\n#User function Template for python3\n\nclass Solution:\n\n    def revStr (ob, S):\n\n        # code here ", "difficulty": "EASY", "generations": [{"generated_text": "Here's a simple Python function that uses slicing to reverse the string. This function takes a string `S` as input and returns the reversed string.\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Return the reversed string using slicing\n        return S[::-1]\n```\n\nHowever, if you want to implement the reverse string function manually without using slicing, you can use a two-pointer approach or a stack data structure. Here's an example of a two-pointer approach:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Initialize two pointers, one at the start and one at the end of the string\n        left = 0\n        right = len(S) - 1\n        \n        # Initialize an empty string to store the reversed string\n        reversed_str = \"\"\n        \n        # Loop until the two pointers meet\n        while left <= right:\n            # Append the character at the right pointer to the reversed string\n            reversed_str += S[right]\n            # Move the right pointer to the left\n            right -= 1\n            # If the left pointer is not equal to the right pointer, append the character at the left pointer to the reversed string\n            if left!= right:\n                reversed_str += S[left]\n            # Move the left pointer to the right\n            left += 1\n        \n        # Return the reversed string\n        return reversed_str\n```\n\nThis function has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string."}, {"generated_text": "Here is the Python function to reverse a string:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nExplanation:\n- The `[::-1]` slicing is used to get the characters of the string in reverse order.\n- This function has a time complexity of O(|S|) because it needs to access each character in the string once.\n- The auxiliary space complexity is also O(|S|) because we are creating a new string that is the reversed version of the input string.\n\nHowever, if you want to implement it manually without using slicing, you can use a two-pointer approach:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Initialize two pointers, one at the start and one at the end of the string\n        left = 0\n        right = len(S) - 1\n\n        # Swap characters from the start and end and move the pointers towards the center\n        while left < right:\n            S = list(S)  # Convert the string to a list so we can modify it\n            S[left], S[right] = S[right], S[left]\n            left += 1\n            right -= 1\n\n        # Return the reversed string\n        return ''.join(S)\n```\n\nThis function also has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|) because we are creating a new list that is the reversed version of the input string."}, {"generated_text": "To solve this problem, we can use Python's slicing feature to reverse the string. Here's a function that accomplishes this:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nThis function takes a string `S` as input and returns the reversed string. The `[::-1]` slicing syntax tells Python to start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n\nHowever, if you want to implement it manually without using slicing, you can use a for loop to iterate over the string and build the reversed string:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Initialize an empty string to store the reversed string\n        reversed_str = \"\"\n        \n        # Iterate over the input string in reverse order\n        for char in S[::-1]:\n            # Append each character to the reversed string\n            reversed_str += char\n        \n        # Return the reversed string\n        return reversed_str\n```\n\nOr you can use Python's built-in `reversed` function and `join` function to reverse the string:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Reverse the string using the reversed function and join function\n        return \"\".join(reversed(S))\n```\n\nAll of these functions have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string."}, {"generated_text": "Here's a Python function that uses slicing to reverse the input string. This solution has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string.\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Return the reversed string\n        return S[::-1]\n```\n\nExplanation:\n- The `[::-1]` slicing syntax tells Python to start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n- This effectively reverses the string.\n\nExample usage:\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nAlternatively, you could also use the `reversed` function in combination with the `join` method to reverse the string:\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Return the reversed string\n        return \"\".join(reversed(S))\n```\n\nThis solution also has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|)."}, {"generated_text": "Here is the Python program that uses a function to reverse a given string.\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        \"\"\"\n        This function takes a string S as input and returns the reversed string.\n\n        Parameters:\n        S (str): The input string to be reversed.\n\n        Returns:\n        str: The reversed string.\n        \"\"\"\n        # Using slicing to reverse the string\n        # S[::-1] means start at the end of the string and end at position 0, move with the step -1\n        return S[::-1]\n```\n\nHowever, if you want to implement it manually without using slicing, you can use a two-pointer approach. Here's how you can do it:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        \"\"\"\n        This function takes a string S as input and returns the reversed string.\n\n        Parameters:\n        S (str): The input string to be reversed.\n\n        Returns:\n        str: The reversed string.\n        \"\"\"\n        # Initialize two pointers, one at the start and one at the end of the string\n        left = 0\n        right = len(S) - 1\n\n        # Initialize an empty string to store the reversed string\n        reversed_S = \"\"\n\n        # Loop through the string until the two pointers meet\n        while left <= right:\n            # Swap the characters at the two pointers and add them to the reversed string\n            reversed_S = S[right] + reversed_S\n            left += 1\n            right -= 1\n\n        # Return the reversed string\n        return reversed_S\n```\n\nBoth of these functions have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the string S."}, {"generated_text": "Here's a Python function that uses slicing to reverse a string. This function takes a string `S` as input and returns the reversed string.\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Return the reversed string using slicing\n        return S[::-1]\n```\n\nHowever, if you want to implement it manually without using slicing, you can use a two-pointer approach or a stack. Here's an example using a two-pointer approach:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Initialize two pointers, one at the start and one at the end of the string\n        start = 0\n        end = len(S) - 1\n\n        # Swap characters at the start and end pointers\n        while start < end:\n            S = list(S)  # Convert string to list for swapping\n            S[start], S[end] = S[end], S[start]\n            start += 1\n            end -= 1\n\n        # Return the reversed string\n        return ''.join(S)\n```\n\nIn this implementation, we first convert the string to a list because strings in Python are immutable, meaning they cannot be changed in-place. We then use a while loop to swap characters at the start and end pointers until the start pointer is greater than or equal to the end pointer. Finally, we join the list back into a string and return it.\n\nBoth of these functions have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|) because we are creating a new string or list in the process of reversing the input string."}, {"generated_text": "Here is a Python program that uses slicing to reverse a string.\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        \"\"\"\n        This function takes a string S as input and returns the reversed string.\n\n        Parameters:\n        S (str): The input string to be reversed.\n\n        Returns:\n        str: The reversed string.\n\n        Time Complexity: O(|S|)\n        Auxiliary Space: O(|S|)\n        \"\"\"\n        return S[::-1]\n```\n\nIn this solution, `S[::-1]` is using Python's slice notation to create a reversed copy of the string `S`. The `[::-1]` slice means \"start at the end of the string and end at position 0, move with the step -1\" which effectively reverses the string.\n\nHere's an example use case:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nThis solution meets the expected time complexity and auxiliary space complexity of O(|S|) because it creates a new string that is the same length as the input string."}, {"generated_text": "Here's a Python function that uses slicing to reverse a string in O(|S|) time complexity and O(|S|) auxiliary space complexity.\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nHowever, if you want to implement it manually without using slicing, you can use a two-pointer approach or a stack. Here's an example using a two-pointer approach:\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Initialize two pointers, one at the start and one at the end of the string\n        left, right = 0, len(S) - 1\n        \n        # Swap characters from the start and end and move the pointers towards the center\n        while left < right:\n            S = S[:left] + S[right] + S[left+1:right] + S[left] + S[right+1:]\n            left += 1\n            right -= 1\n        \n        # Return the reversed string\n        return S\n```\n\nOr using a stack:\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Initialize an empty stack\n        stack = []\n        \n        # Push all characters onto the stack\n        for char in S:\n            stack.append(char)\n        \n        # Pop characters from the stack and build the reversed string\n        reversed_S = \"\"\n        while stack:\n            reversed_S += stack.pop()\n        \n        # Return the reversed string\n        return reversed_S\n```\n\nAll of these solutions have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|)."}, {"generated_text": "To solve this problem, we can use a simple two-pointer technique. We will initialize two pointers, one at the start and one at the end of the string, and then swap the characters at these positions. We will keep moving the pointers towards the center of the string until they meet.\n\nHere is the Python code for the problem:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Convert the string to a list because strings in Python are immutable\n        S = list(S)\n        \n        # Initialize two pointers, one at the start and one at the end of the string\n        left = 0\n        right = len(S) - 1\n        \n        # Swap the characters at the left and right pointers and move the pointers towards the center\n        while left < right:\n            S[left], S[right] = S[right], S[left]\n            left += 1\n            right -= 1\n        \n        # Convert the list back to a string and return it\n        return ''.join(S)\n```\n\nThis code works by initializing two pointers, `left` and `right`, to the start and end of the string respectively. It then enters a loop where it swaps the characters at the `left` and `right` positions, increments `left` and decrements `right`. This process continues until `left` meets `right`, at which point the string has been reversed. The reversed string is then returned.\n\nThis solution has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), as required by the problem constraints."}, {"generated_text": "Here's the Python code for the problem:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nExplanation:\nThis function uses Python's slicing feature to reverse the string. The `[::-1]` slicing means start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n\nHowever, if you want to implement it manually without using slicing, you can do it like this:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Initialize an empty string to store the reversed string\n        reversed_S = \"\"\n        \n        # Iterate over the input string from the end to the start\n        for char in S[::-1]:\n            # Append each character to the reversed string\n            reversed_S += char\n        \n        # Return the reversed string\n        return reversed_S\n```\n\nBut the most efficient way to reverse a string in Python is by using the `reversed` function in combination with the `join` function:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Use the reversed function to reverse the string and join it back into a string\n        return \"\".join(reversed(S))\n```\n\nAll of these methods have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string."}, {"generated_text": "To solve this problem, we can use Python's built-in string slicing feature to reverse the string. However, since the problem asks for a custom solution, we can use a two-pointer approach to achieve this in O(n) time complexity and O(n) auxiliary space complexity.\n\nHere's the Python code for the problem:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Reverse the string using two-pointer approach\n        S = list(S)\n        left, right = 0, len(S) - 1\n        while left < right:\n            # Swap characters at left and right pointers\n            S[left], S[right] = S[right], S[left]\n            left += 1\n            right -= 1\n        return ''.join(S)\n```\n\nHowever, the above code modifies the original string. If you want to keep the original string intact, you can create a new list or string to store the reversed characters.\n\nHere's an alternative solution:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Reverse the string using two-pointer approach\n        S = list(S)\n        left, right = 0, len(S) - 1\n        reversed_S = []\n        while left <= right:\n            # Append characters at left and right pointers to reversed_S\n            reversed_S.append(S[left])\n            reversed_S.append(S[right])\n            left += 1\n            right -= 1\n        return ''.join(reversed_S)\n```\n\nAlternatively, you can use Python's slicing feature to reverse the string in a more concise way:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nThis solution has a time complexity of O(n) and auxiliary space complexity of O(n), where n is the length of the string."}, {"generated_text": "Here's a simple Python function that uses slicing to reverse a string. It meets the expected time complexity and auxiliary space complexity.\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Using slicing to reverse the string\n        return S[::-1]\n```\n\nHowever, if you want to implement it manually without using slicing, you can use a two-pointer approach. Here's an example:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Initialize two pointers, one at the start and one at the end of the string\n        left = 0\n        right = len(S) - 1\n\n        # Swap characters from the start and end, moving towards the center\n        while left < right:\n            S = list(S)\n            S[left], S[right] = S[right], S[left]\n            left += 1\n            right -= 1\n        return ''.join(S)\n```\n\nIn this code, we first convert the string to a list because strings in Python are immutable and cannot be changed in-place. We then swap the characters at the left and right pointers and move them towards the center. Finally, we join the list back into a string and return it."}, {"generated_text": "Here's the Python program that solves the problem using a function `revStr`:\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nExplanation:\n- The `[::-1]` is a Python slice that steps through the string backwards, starting from the end and moving backwards to the beginning.\n- This approach has a time complexity of O(|S|) because it needs to access every character in the string once.\n- The auxiliary space complexity is also O(|S|) because it creates a new string that is the reversed version of the input string.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nAlternatively, you can use the `reversed` function in combination with the `join` method to achieve the same result:\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Reverse the string using the reversed function and join method\n        return \"\".join(reversed(S))\n```\n\nThis approach also has a time complexity of O(|S|) and auxiliary space complexity of O(|S|)."}, {"generated_text": "Here's the Python program that solves the problem using a function `revStr` in a class `Solution`.\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        \"\"\"\n        This function takes a string S as input and returns the reversed string.\n        \n        Parameters:\n        S (str): The input string to be reversed.\n        \n        Returns:\n        str: The reversed string.\n        \"\"\"\n        \n        # Initialize an empty string to store the reversed string\n        reversed_str = \"\"\n        \n        # Iterate over the input string from the end to the start\n        for char in S[::-1]:\n            # Append each character to the reversed string\n            reversed_str += char\n        \n        # Return the reversed string\n        return reversed_str\n\n# Example usage:\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nHowever, Python has a built-in function `reversed()` that can be used to reverse a string. Here's a more concise version of the function:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        \"\"\"\n        This function takes a string S as input and returns the reversed string.\n        \n        Parameters:\n        S (str): The input string to be reversed.\n        \n        Returns:\n        str: The reversed string.\n        \"\"\"\n        \n        # Return the reversed string using the built-in function reversed()\n        return \"\".join(reversed(S))\n\n# Example usage:\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nBoth of these functions have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string."}, {"generated_text": "Here's the Python solution using slicing to reverse the string.\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        return S[::-1]\n```\n\nExplanation:\n- The `S[::-1]` expression is using Python's slice notation to get the characters of the string in reverse order.\n- The `::-1` means start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n- This solution has a time complexity of O(|S|) because it needs to access each character in the string once.\n- The space complexity is also O(|S|) because it creates a new string that is the reverse of the input string.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nAlternatively, you can use the `reversed` function in combination with the `join` method to achieve the same result.\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        return \"\".join(reversed(S))\n```\n\nThis solution also has a time complexity of O(|S|) and a space complexity of O(|S|)."}, {"generated_text": "Here's the Python function that uses slicing to reverse the string:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Using slicing to reverse the string\n        return S[::-1]\n```\n\nExplanation:\n\n- The `[::-1]` slicing syntax tells Python to start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n- This will effectively reverse the string.\n- The time complexity is O(|S|) because slicing a string in Python is a constant time operation.\n- The auxiliary space complexity is also O(|S|) because we're creating a new string that's the same length as the original string.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nAlternatively, you can use the `reversed` function and the `join` method to reverse the string:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Using reversed and join to reverse the string\n        return \"\".join(reversed(S))\n```\n\nThis approach has the same time and space complexity as the slicing approach."}, {"generated_text": "Here's the Python solution for the problem:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nExplanation:\n\n*   The slicing operation `S[::-1]` starts from the end of the string and moves backwards to the beginning, stepping backwards by 1 character each time.\n*   This operation has a time complexity of O(|S|) because it needs to traverse the entire string once.\n*   The auxiliary space complexity is also O(|S|) because we're creating a new string with the reversed characters.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nAlternatively, you can use a loop to reverse the string:\n\n```python\nclass Solution:\n\n    def revStr(self, S):\n        # Initialize an empty string to store the reversed string\n        reversed_S = \"\"\n\n        # Traverse the string from the end to the beginning\n        for char in reversed(S):\n            reversed_S += char\n\n        return reversed_S\n```\n\nThis solution also has a time complexity of O(|S|) and an auxiliary space complexity of O(|S|). However, the slicing operation is generally more efficient and Pythonic."}, {"generated_text": "Here's a Python function that uses slicing to reverse a string in O(|S|) time complexity and O(|S|) auxiliary space complexity.\n\n```python\nclass Solution:\n\n    def revStr (self, S):\n        # Reverse the string using slicing\n        return S[::-1]\n```\n\nExplanation:\n\n- `S[::-1]` is a slice that steps backwards through the entire string.\n- The `::-1` means \"start at the end of the string and end at position 0, move with the step -1\" which effectively reverses the string.\n\nThis function does not require any additional variables or loops, making it efficient in terms of space and time complexity.\n\nExample usage:\n\n```python\nsolution = Solution()\nprint(solution.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(solution.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```\n\nThis solution meets the expected time complexity of O(|S|) and auxiliary space complexity of O(|S|) as required by the problem constraints."}, {"generated_text": "Here is a Python function to reverse a string using slicing:\n\n```python\nclass Solution:\n    def revStr(self, S):\n        # Using slicing to reverse the string\n        return S[::-1]\n```\n\nThis function uses Python's slice notation to reverse the string. The `[::-1]` slice means \"start at the end of the string and end at position 0, move with the step -1\" which effectively reverses the string.\n\nHere's an explanation of how it works:\n\n- `S[start:stop:step]` is the general slice notation in Python.\n- `start` is the starting index of the slice (inclusive).\n- `stop` is the ending index of the slice (exclusive).\n- `step` is the difference between indices.\n\nBy setting `start` and `stop` to empty, we're effectively starting at the beginning and ending at the end of the string. The `step` of `-1` means we're moving backwards through the string, effectively reversing it.\n\nThis function has a time complexity of O(|S|) because it needs to access each character in the string once, and an auxiliary space complexity of O(|S|) because it needs to store the reversed string.\n\nExample use cases:\n\n```python\nob = Solution()\nprint(ob.revStr(\"GeeksforGeeks\"))  # Output: \"skeeGrofskeeG\"\nprint(ob.revStr(\"ReversE\"))  # Output: \"EsreveR\"\n```"}, {"generated_text": "To solve this problem, we can use Python's built-in string slicing feature to reverse the string. Here's the code:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Return the reversed string\n        return S[::-1]\n```\n\nExplanation:\n\n- `S[::-1]` is a slice that steps through the string in reverse order, starting from the end and moving backwards to the beginning.\n- The `::-1` part tells Python to start at the end of the string and end at position 0, move with the step -1 which means one step backwards.\n- This will return the reversed string.\n\nHowever, if you want to implement it manually without using slicing, you can use a loop to achieve this:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Initialize an empty string to store the reversed string\n        reversed_S = \"\"\n        \n        # Loop through the input string from the end to the beginning\n        for char in S[::-1]:\n            # Append each character to the reversed string\n            reversed_S += char\n        \n        # Return the reversed string\n        return reversed_S\n```\n\nOr you can use the `reversed` function in combination with the `join` method:\n\n```python\nclass Solution:\n\n    def revStr (ob, S):\n        # Use the reversed function to reverse the string and join it back into a string\n        return \"\".join(reversed(S))\n```\n\nAll of these methods will have a time complexity of O(|S|) and an auxiliary space complexity of O(|S|), where |S| is the length of the input string."}]}