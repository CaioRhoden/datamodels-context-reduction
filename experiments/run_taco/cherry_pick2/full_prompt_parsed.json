[{"task_id": 2545, "output": ["import math\nimport sys\nimport math\n\ndef calculate_expected_value():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        p, t = map(float, input().split())\n        if p == 0:\n            print('0.0000')\n        else:\n            t /= 1440\n            probability = 1 - p\n            result = (1 - (1 - p) * math.exp(-t)) / p\n            print('{:.4f}'.format(result))\n\ncalculate_expected_value()", "def expected_rainfall_probability(rainfall_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n\n    Args:\n    rainfall_probability (float): The probability of rain today.\n    travel_time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    # Since the probability of no rain is (1 - rainfall_probability), we use the formula for the sum of a geometric series\n    # The formula is: 1 - (probability of no rain)^travel_time\n    # We can calculate this as: 1 - (1 - rainfall_probability)^travel_time\n    # This is equivalent to: 1 - (1 - rainfall_probability)^travel_time = (rainfall_probability^travel_time)\n    return round(rainfall_probability ** travel_time, 4)\n\n\ndef main():\n    # Read the number of test cases\n    num_test_cases = int(input())\n\n    # Process each test case\n    for _ in range(num_test_cases):\n        # Read the probability of rain and travel time\n        rainfall_probability, travel_time = map(float, input().split())\n\n        # Calculate and print the probability of rain during travel time\n        print(expected_rainfall_probability(rainfall_probability, travel_time))\n\n\nif __name__ == \"__main__\":\n    main()", "def calculate_probability(rainfall_probability, time):\n    \"\"\"Calculate the probability that it rains during the time it takes to reach the office.\"\"\"\n    \n    # Convert rainfall probability to a fraction\n    rainfall_fraction = 1 / (1 - rainfall_probability)\n    \n    # Calculate the probability that it rains during the given time\n    probability = (rainfall_fraction ** time) * (1 - rainfall_fraction)\n    \n    # Round the result to 4 decimal places\n    probability = round(probability, 4)\n    \n    return probability\n\n# Read the number of test cases\nnum_test_cases = int(input())\n\n# Process each test case\nfor _ in range(num_test_cases):\n    # Read the rainfall probability and time\n    rainfall_probability, time = map(float, input().split())\n    \n    # Calculate and print the probability\n    print(calculate_probability(rainfall_probability, time))", "from math import gcd\ndef calculate_time(T, P, time):\n    time_minutes = time // gcd(time, 1440)\n    total_probability = 0\n    for i in range(1, time_minutes + 1):\n        if i % 2 == 0:\n            total_probability += (P * (P ** (i - 1))) / 2\n        else:\n            total_probability += (P * (P ** (i - 1))) / 2\n    return round(total_probability * 1440 / time, 4)\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print(calculate_time(T, P, time))", "from math import gcd\nfrom math import sqrt\nfrom math import floor\nfrom math import ceil\n\ndef extended_euclidean(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd_val, x, y = extended_euclidean(b % a, a)\n        return gcd_val, y - (b // a) * x, x\n\ndef mod_inverse(a, m):\n    gcd_val, x, y = extended_euclidean(a, m)\n    if gcd_val!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_pow(a, n, m):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % m\n        a = (a * a) % m\n        n //= 2\n    return res\n\ndef main():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        prob = p\n        ans = 0\n        for i in range(1, int(sqrt(time)) + 1):\n            if time % i == 0:\n                a, b = i, time // i\n                if a % 2 == 0 and b % 2 == 0:\n                    ans += mod_pow(2, i, MOD) * mod_pow(2, b, MOD)\n                elif a % 2 == 0 and b % 2!= 0:\n                    ans += mod_pow(2, i, MOD) * (mod_pow(2, b, MOD) - 1)\n                elif a % 2!= 0 and b % 2 == 0:\n                    ans += (mod_pow(2, i, MOD) - 1) * mod_pow(2, b, MOD)\n                else:\n                    ans += (mod_pow(2, i, MOD) - 1) * (mod_pow(2, b, MOD) - 1)\n                ans %= MOD\n        ans = (ans * mod_inverse(2, MOD)) % MOD\n        print(\"%.4f\" % ans)\n\nmain()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_rain_probability():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        minutes_in_day = 1440\n        minutes_in_time = time\n        total_minutes_in_time = minutes_in_day * minutes_in_time // math.gcd(minutes_in_day, minutes_in_time)\n        R = 1\n        D = (1 - P + P * (1 - P)) * (1 - P) % MOD\n        for i in range(total_minutes_in_time // 2):\n            R = (R * D) % MOD\n            D = (D * D) % MOD\n        print(format(R, '.4f'))\n\ncalculate_expected_rain_probability()", "def calculate_probability(t, p):\n    \"\"\"\n    Calculate the probability of rain during the time it takes for Raj to reach his office.\n\n    Args:\n    t (int): The time it takes for Raj to reach his office in minutes.\n    p (float): The probability of rain today.\n\n    Returns:\n    float: The probability of rain during the time it takes for Raj to reach his office.\n    \"\"\"\n    # Calculate the probability of no rain\n    no_rain_prob = 1 - p\n    \n    # If it's not raining, the probability of no rain is 1\n    if not no_rain_prob:\n        return 1\n    \n    # Calculate the probability of rain during the time it takes for Raj to reach his office\n    # This is done using the formula for the sum of an infinite geometric series\n    rain_prob = p * (1 - (no_rain_prob ** t))\n    \n    return rain_prob\n\ndef main():\n    \"\"\"\n    Main function to read input and calculate the probabilities.\n    \"\"\"\n    # Read the number of test cases\n    num_test_cases = int(input())\n    \n    # Process each test case\n    for _ in range(num_test_cases):\n        # Read the probability of rain and the time\n        p, t = map(float, input().split())\n        \n        # Calculate the probability of rain during the time it takes for Raj to reach his office\n        rain_prob = calculate_probability(t, p)\n        \n        # Round the result to 4 decimal places\n        rain_prob = round(rain_prob, 4)\n        \n        # Print the result\n        print(rain_prob)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = 1\n        D = 1\n        for i in range(int(t)):\n            R = R * D % MOD\n            D = D * (1 - P + P * D) % MOD\n        print(format(R, \".4f\"))\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time(P, time):\n    probability = 1\n    result = 0\n    while time > 0:\n        if time % 2:\n            result += P * time\n            probability *= P\n        time //= 2\n        P *= P\n    return result\n\nfor _ in range(int(input())):\n    P, t = map(float, input().split())\n    print('{:.4f}'.format(calculate_expected_time(P, t)))", "import math\n\ndef expected_minutes(sorted_time, total_time):\n    # Calculate the expected number of minutes Logan will spend waiting for ${P}$ to be sorted\n    prob = sorted_time / total_time\n    expected_time = prob / (1 - prob)\n    return round(expected_time, 6)\n\ndef calculate_rain_probability(rain_probability, time):\n    # Calculate the probability that it rains during the time Raj is on the way\n    expected_rain = rain_probability * time\n    return round(expected_rain, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\nfor _ in range(test_cases):\n    # Read the input values\n    rain_probability = float(input().split()[0])\n    time = int(input().split()[1])\n\n    # Calculate the expected number of minutes Logan will spend waiting for ${P}$ to be sorted\n    expected_time = expected_minutes(time, 1440)\n\n    # Calculate the probability that it rains during the time Raj is on the way\n    rain_expected_time = calculate_rain_probability(rain_probability, time)\n\n    # Print the results\n    print(f\"Expected time: {expected_time}\")\n    print(f\"Rain expected time: {rain_expected_time}\")", "import math\n\nMOD = 10 ** 9 + 7\nPI = 0.5\n\ndef calculate_expected_time(N, P, time):\n    R = 1\n    D = (1 + P) // 2\n    for _ in range(time):\n        if _ % 2 == 1:\n            R = R * D % MOD\n        D = D * D % MOD\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N, t = map(float, input().split())\n        P = 1 - N\n        print('{:.4f}'.format(PI * calculate_expected_time(N, P, t)))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        ans = 0\n        for i in range(1, int(time) + 1):\n            if i % 2 == 1:\n                ans = (ans + P * (1 - P) * (1 - P) ** (i - 1) * (i - 1) / 2) % MOD\n            else:\n                ans = (ans + P * (1 - P) * (1 - P) ** (i - 1) * i / 2) % MOD\n        ans = round(ans * 1440 / time, 4)\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()", "import math\nfrom math import factorial\n\ndef calculate_probability(t, p):\n    MOD = 10**9 + 7\n    R = 1\n    D = (p + 1) // 2\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        p, t = map(float, input().split())\n        probability = calculate_probability(t, p)\n        print('{:.4f}'.format(probability))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef expected_minutes():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        a = list(map(float, input().split()))\n\n        # calculate the probability of being sorted after t minutes\n        prob = 0\n        for i in range(1, N + 1):\n            prob += (1 / (2 ** i)) * (1 / 2) ** (N - i)\n        prob *= 2  # multiply by 2 because there are two possible permutations\n\n        # calculate the expected number of minutes\n        expected = prob * N\n\n        # calculate the expected number of minutes modulo 10^6\n        expected = round(expected * 10 ** 6) / 10 ** 6\n        print(f\"{expected:.4f}\")\n\nexpected_minutes()\nimport math\n\ndef virus_cells():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    a, b, time = map(int, input().split())\n\n    # calculate the expected number of virus cells after t milliseconds\n    prob_a = a / 2\n    prob_b = b / 2\n    expected = (prob_a * (1 + (prob_b * time))) % MOD\n    print(expected)\n\nvirus_cells()\nimport math\n\ndef rainfalls():\n    t = int(input())\n    for _ in range(t):\n        p = float(input())\n        time = int(input())\n\n        # calculate the probability of rainfalls during the time Raj is on the way\n        prob = 1\n        for i in range(1, time + 1):\n            prob *= (1 - p) ** (time // i) * p\n            if (time % i!= 0):\n                prob *= (time // i + 1) / (time // i + 1)\n        print(f\"{prob:.4f}\")\n\nrainfalls()", "MOD = 10 ** 9 + 7\n\ndef solve(P, time):\n    \"\"\"Calculate the expected probability of rain during the given time\"\"\"\n    R = 1\n    D = 1\n    for _ in range(time):\n        R = (R + (1 - P) * D) % MOD\n        D = (D + P * D) % MOD\n    return R\n\nT = int(input())\n\nfor _ in range(T):\n    P = float(input().split()[0])\n    time = int(input())\n    print(format(solve(P, time), \".4f\"))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    if p == 0:\n        return 0\n    elif p == 1:\n        return time\n    else:\n        return (p * time) + (1 - p) * (time - 1)\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        p, t = map(float, input().split())\n        result = calculate_probability(p, t)\n        result = round(result, 4)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def calculate_probability(rainfall_probability, travel_time):\n    # Calculate the expected number of rainy days\n    expected_rainy_days = rainfall_probability * travel_time\n    \n    # Since the probability of rain is given, we can use this to calculate the expected number of rainy days\n    # We can use the formula for the sum of an infinite geometric series\n    expected_rainy_days = (rainfall_probability / (1 - rainfall_probability)) * travel_time\n    \n    # Return the expected number of rainy days as a decimal\n    return round(expected_rainy_days, 4)\n\ndef main():\n    # Read the number of test cases\n    num_test_cases = int(input())\n    \n    # Perform the calculation for each test case\n    for _ in range(num_test_cases):\n        # Read the input values\n        rainfall_probability = float(input().split()[0])\n        travel_time = int(input().split()[1])\n        \n        # Calculate and print the expected number of rainy days\n        print(calculate_probability(rainfall_probability, travel_time))\n\nif __name__ == \"__main__\":\n    main()", "def expected_time_to_rain(probability, time):\n    \"\"\"\n    Calculate the expected time to rain during a given time period.\n\n    Args:\n    probability (float): The probability of rain today.\n    time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The expected time to rain during the given time period, rounded to 4 decimal places.\n    \"\"\"\n    if probability == 0:\n        return 0\n    else:\n        return probability * time\n\ndef main():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        print(\"{:.4f}\".format(expected_time_to_rain(P, t)))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef calculate_probability(rainfall_probability, travel_time):\n    # Calculate the probability of no rain during travel\n    no_rain_probability = (1 - rainfall_probability) ** (travel_time // 1440)\n    \n    # Calculate the expected number of rainy days during travel\n    rainy_days_probability = 1 - no_rain_probability\n    \n    # Calculate the expected number of rainy days during travel\n    expected_rainy_days = travel_time // 1440 * rainy_days_probability\n    \n    # Calculate the expected number of rainy days during travel\n    expected_rainy_days *= 1440\n    \n    return round(expected_rainy_days, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability of rainfall and travel time\n    rainfall_probability, travel_time = map(float, input().split())\n    \n    # Calculate the expected number of rainy days during travel\n    expected_rainy_days = calculate_probability(rainfall_probability, travel_time)\n    \n    # Print the result\n    print(expected_rainy_days)", "def calculate_probability(T, time, P):\n    MOD = 10 ** 9 + 7\n    # Calculate the number of multiples of time that are less than or equal to 1440\n    num_multiples = time\n    # Calculate the expected number of times it will rain during the time\n    expected_rain_times = (num_multiples * P * (1 - P)) + (num_multiples * (1 - P) * P)\n    # Calculate the expected number of times it will rain during the time\n    expected_rain = expected_rain_times * time\n    # Calculate the probability of it raining at least once during the time\n    probability_rain = 1 - (1 - P) ** num_multiples\n    # Calculate the final answer\n    final_answer = (expected_rain * probability_rain) % MOD\n    return final_answer\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print(\"{:.4f}\".format(calculate_probability(1440, time, P)))", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_probability(rain_probability, time):\n    # Calculate the probability that it will rain\n    rain_probability *= 2\n    \n    # Calculate the probability of not raining\n    not_rain_probability = 1 - rain_probability\n    \n    # Calculate the expected number of minutes it will rain\n    expected_rain_minutes = (rain_probability / not_rain_probability) * time\n    \n    # Calculate the probability that it will rain in less than or equal to time minutes\n    probability = 1\n    remaining_time = time\n    while remaining_time > 0:\n        # Calculate the probability of raining in the remaining time\n        probability *= (rain_probability / not_rain_probability) * (remaining_time / time)\n        \n        # Calculate the probability of not raining in the remaining time\n        probability *= not_rain_probability / (not_rain_probability + rain_probability)\n        \n        # Update the remaining time\n        remaining_time //= 2\n        \n        # Update the rain probability\n        rain_probability *= 0.5\n    \n    # Return the expected number of minutes it will rain, rounded to 4 decimal places\n    return round(expected_rain_minutes, 4)\n\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    result = calculate_probability(P, t)\n    print(result)", "def expected_time(P, time):\n    MOD = 10 ** 9 + 7\n    D = (1 + P + (1 - P) * time) % MOD\n    R = 1\n    while time > 0:\n        if time % 2:\n            R = (R * D) % MOD\n        D = (D * D) % MOD\n        time //= 2\n    return R\n\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print('{0:6.4f}'.format(expected_time(P, time)))", "from math import gcd\n\nMOD = 10 ** 9 + 7\n\ndef extended_gcd(a, b):\n    \"\"\"Compute the extended gcd of a and b\"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = extended_gcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m=MOD):\n    \"\"\"Compute the modular inverse of a\"\"\"\n    g, x, y = extended_gcd(a, m)\n    if g!= 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef expected_number_of_minutes(T, P):\n    \"\"\"Expected number of minutes\"\"\"\n    N = 1440 // T  # number of minutes in the day\n    # Calculate the probability of it not raining\n    prob_not_raining = 1 - P\n    # Calculate the expected number of minutes it rains\n    exp_minutes = 0\n    for i in range(1, N + 1):\n        # Calculate the probability of it not raining in i minutes\n        prob_not_raining_i = (prob_not_raining * (i / T)) ** i\n        # Calculate the number of times it rains in i minutes\n        num_rains = T - i\n        # Calculate the probability of it raining in i minutes\n        prob_rains_i = (1 - prob_not_raining_i) * prob_not_raining_i\n        # Update the expected number of minutes\n        exp_minutes += num_rains * prob_rains_i\n\n    # Return the expected number of minutes\n    return round(exp_minutes, 4)\n\n# Read the number of test cases\nT = int(input())\n# Process each test case\nfor _ in range(T):\n    # Read the probability of rain and the time\n    P, t = map(float, input().split())\n    # Calculate and print the expected number of minutes\n    print(expected_number_of_minutes(t, P))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value(T, P):\n    R = 1\n    D = 1\n    for _ in range(int(math.log2(T))):\n        R = R * D % MOD\n        D = D * D % MOD\n    return R * P % MOD\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        expected_value = calculate_expected_value(int(t), P)\n        print(f\"{expected_value:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        R = 1\n        D = 2 * P\n        R = R * D % MOD\n        while time > 0:\n            if time % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            time //= 2\n        print(f\"{R:.4f}\")\n\ncalculate_expected_time()", "def calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n\n    Args:\n    rain_probability (float): The probability that it will rain today.\n    travel_time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    # Calculate the number of minutes in a day\n    minutes_in_a_day = 1440\n\n    # Calculate the number of times the travel time is a factor of a day\n    times_factor = minutes_in_a_day // travel_time\n\n    # Calculate the probability of it not raining during the travel time\n    no_rain_probability = (1 - rain_probability) ** times_factor\n\n    # Calculate the probability of it raining during the travel time\n    rain_probability_during_travel = 1 - no_rain_probability\n\n    return rain_probability_during_travel\n\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n\n    # Calculate the probability that it rains during the travel time and round to 4 decimal places\n    probability = round(calculate_probability(P, t), 4)\n\n    print(probability)", "import math\n\ndef calculate_probability(rain_probability, time):\n    # Calculate the probability that it rains during the time\n    probability = 2 * (rain_probability ** time) - (rain_probability ** (time + 1))\n    return probability\n\ndef main():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P = float(input().split()[0])\n        t = int(input().split()[1])\n        probability = calculate_probability(P, t)\n        result = round(probability, 4)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def calculate_probability_of_rain(T, P, time):\n    # Calculate the probability of rain during the time\n    probability_of_rain = P * time\n    return probability_of_rain\n\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        probability_of_rain = calculate_probability_of_rain(T, P, time)\n        print('{:.4f}'.format(probability_of_rain))\n\n\nif __name__ == \"__main__\":\n    main()", "def calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        R = 1\n        D = (1 + P) / 2\n        for i in range(time // 2):\n            R = R * D % MOD\n            D = D * D % MOD\n        print(f\"{R * (1 - P) * 60:.4f}\")\n\n\ncalculate_expected_time()", "import math\n\ndef calculate_expected_time():\n    # Read the number of test cases\n    T = int(input())\n\n    # Loop through each test case\n    for _ in range(T):\n        # Read the probability of rain and time\n        P, time = map(float, input().split())\n\n        # Calculate the expected time\n        expected_time = P * time\n\n        # Round the result to 4 decimal places\n        expected_time = round(expected_time, 4)\n\n        # Print the result\n        print(f\"{expected_time:.4f}\")\n\ncalculate_expected_time()", "import math\n\ndef calculate_time(N, a):\n    total_time = 0\n    for i in range(1, N+1):\n        total_time += i * (2**(-i))\n    return total_time\n\ndef solve():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        t = int(t)\n        num = 1\n        for i in range(1, t+1):\n            if i % 2!= 0:\n                num = num * (1 + P) % MOD\n            else:\n                num = num * (1 - P) % MOD\n        print(f'{num:.4f}')\n\nsolve()", "import math\nimport sys\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(float, input().split()))\n        a.sort()\n        num = 1\n        den = 1\n        for i in range(N-1):\n            num *= (N-i)\n            den *= (i+1)\n        expected_time = 0\n        for i in range(1, N+1):\n            expected_time += (i / (2 ** i)) * den\n            den *= num\n        print('{0:.6f}'.format(expected_time))\n\ncalculate_expected_time()\nimport math\nimport sys\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(float, input().split()))\n        a.sort()\n        expected_time = 0\n        for i in range(1, N+1):\n            numerator = math.comb(N, i) * (i ** N)\n            denominator = (2 ** N)\n            expected_time += numerator / denominator\n        print('{0:.6f}'.format(expected_time))\n\ncalculate_expected_time()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve(p, time):\n    # calculate the probability that it doesn't rain during the time\n    prob_not_rain = (1 - p) * (1 - p) ** time\n    # calculate the probability that it rains during the time\n    prob_rain = 1 - prob_not_rain\n    # calculate the expected value\n    expected_value = prob_rain * time\n    return expected_value\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        p, time = map(float, input().split())\n        result = solve(p, time)\n        print('{:.4f}'.format(result))\n\nif __name__ == \"__main__\":\n    main()", "def calculate_probability(p, t):\n    MOD = 10 ** 9 + 7\n    p = p * t % MOD\n    p = (1 + p) % MOD\n    return p\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(\"{:.4f}\".format(1 - calculate_probability(1-p, t)))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(time, probability):\n    R = 1\n    D = (1 + probability) // 2\n    while time > 0:\n        if time % 2:\n            R = (R * D) % MOD\n        D = (D * D) % MOD\n        time //= 2\n    return R\n\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    probability = P\n    result = calculate_probability(t, probability)\n    print('{0:.4f}'.format(result))", "def calculate_probability(rain_probability, time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way.\n\n    Args:\n    rain_probability (float): The probability that it rains today.\n    time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way.\n    \"\"\"\n    # Calculate the probability that it rains during the time Raj is on the way\n    # This is equal to the probability that it rains today times the ratio of the time\n    # that it rains during the time Raj is on the way to the total time\n    return rain_probability * (time / 1440)\n\n\ndef main():\n    \"\"\"\n    Main function to read input and calculate the expected number of minutes\n    that Logan will spend waiting for his favorite sequence to be sorted.\n    \"\"\"\n    # Read the number of test cases\n    num_test_cases = int(input())\n\n    # Read the input for each test case\n    for _ in range(num_test_cases):\n        # Read the size of the permutation\n        N = int(input())\n\n        # Read the current order of the permutation\n        a = list(map(float, input().split()))\n\n        # Calculate the probability that the permutation is sorted\n        m = {}\n        for i in a:\n            if i in m:\n                m[i] += 1\n            else:\n                m[i] = 1\n\n        num = 1\n        for i in m:\n            num *= factorial(m[i])\n\n        den = factorial(N)\n\n        # Print the expected number of minutes that Logan will spend waiting\n        print('%0.6f' % (den / num))\n\n\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of a number.\n\n    Args:\n    n (int): The number to calculate the factorial of.\n\n    Returns:\n    int: The factorial of the number.\n    \"\"\"\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef expected_rain_probability(rain_probability, time):\n    # calculate the expected number of rainfalls\n    expected_rainfalls = 0\n    current_time = time\n    while current_time > 0:\n        # calculate the probability of no rain\n        no_rain_probability = (1 - rain_probability) ** (time // current_time)\n        \n        # calculate the probability of rain\n        rain_probability_value = rain_probability * (1 - no_rain_probability)\n        \n        # add the expected number of rainfalls to the total\n        expected_rainfalls += rain_probability_value * current_time\n        \n        # move to the next time interval\n        current_time //= 2\n    \n    return round(expected_rainfalls, 4)\n\ndef main():\n    MOD = 10 ** 9 + 7\n    \n    T = int(input())\n    for _ in range(T):\n        # read the input values\n        rain_probability = float(input().split()[0])\n        time = int(input().split()[1])\n        \n        # calculate the expected number of rainfalls\n        expected_rainfalls = expected_rain_probability(rain_probability, time)\n        \n        # calculate the expected number of rainfalls modulo 10^9 + 7\n        expected_rainfalls_mod = (expected_rainfalls * 1440) % MOD\n        \n        # print the result\n        print(f\"{expected_rainfalls_mod:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef expected_rainfall_probability(p, time):\n    \"\"\"Calculate the expected probability of rainfall during the given time.\"\"\"\n    total_minutes = 1440  # Total minutes in a day\n    min_time = time\n    max_time = total_minutes - time\n    total_minutes = total_minutes * (total_minutes + 1) // 2\n\n    # Calculate the expected probability of rainfall using the formula\n    # P = (p * min_time + (1 - p) * max_time) / total_minutes\n    expected_prob = (p * min_time + (1 - p) * max_time) / total_minutes\n\n    # Convert the expected probability to a decimal and round to 4 decimal places\n    return round(expected_prob, 4)\n\ndef calculate_answer():\n    \"\"\"Calculate the answer to each test case.\"\"\"\n    T = int(input())\n    for _ in range(T):\n        p, time = map(float, input().split())\n        answer = expected_rainfall_probability(p, time)\n        print(answer)\n\nif __name__ == \"__main__\":\n    calculate_answer()", "def calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n    \n    Args:\n    rain_probability (float): The probability that it rains today.\n    travel_time (int): The time it takes for Raj to reach his office in minutes.\n    \n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    # Calculate the probability that it does not rain during the travel time\n    no_rain_probability = 1 - rain_probability\n    \n    # Calculate the probability that it rains during the travel time\n    rain_probability = no_rain_probability ** (travel_time // 1440)\n    \n    # Calculate the final probability\n    final_probability = rain_probability * 2\n    \n    # Round the final probability to 4 decimal places\n    final_probability = round(final_probability, 4)\n    \n    return final_probability\n\nT = int(input())\nfor _ in range(T):\n    rain_probability, travel_time = map(float, input().split())\n    print(calculate_probability(rain_probability, travel_time))", "import math\n\ndef calculate_probability(p, time):\n    # Calculate the probability that it rains during the time\n    # This is 1 - (probability that it does not rain during the time)\n    # Since the probability of rain or not rain is equal, \n    # the probability of not raining for the first 'time' minutes is \n    # p^time\n    return 1 - (p**time)\n\n# Number of test cases\nt = int(input())\n\n# Loop through each test case\nfor _ in range(t):\n    # Read the probability and time\n    p, time = map(float, input().split())\n\n    # Calculate and print the probability\n    print(f\"{calculate_probability(p, time):.4f}\")", "import math\n\ndef calculate_probability(rain_probability, travel_time):\n    # Calculate the number of times the travel time will be divided by 2\n    n = math.floor(math.log2(travel_time))\n    \n    # Calculate the probability that it will rain during the travel time\n    probability = rain_probability * (1 - rain_probability) ** (n - 1)\n    \n    return probability\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        rain_probability = float(input().split()[0])\n        travel_time = int(input().split()[1])\n        probability = calculate_probability(rain_probability, travel_time)\n        print(\"{0:.4f}\".format(probability))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes to reach the office.\n\n    Args:\n    p (float): The probability of rain.\n    time (int): The time it takes to reach the office in minutes.\n\n    Returns:\n    float: The probability that it rains during the time it takes to reach the office.\n    \"\"\"\n    # Calculate the number of times the probability can be multiplied by p\n    n = 0\n    while 2 ** n * p <= 1:\n        n += 1\n\n    # Calculate the sum of probabilities\n    sum_prob = 0\n    for i in range(n):\n        # Calculate the probability of not raining for i times\n        prob_not_raining = (1 - p) ** i\n        # Multiply the probability by p for the remaining times\n        prob_raining = p * (2 ** i)\n        # Add the probability to the sum\n        sum_prob += prob_raining / prob_not_raining\n\n    # Calculate the sum modulo MOD\n    sum_prob = sum_prob % MOD\n\n    # Calculate the final probability\n    final_prob = (sum_prob - (1 - p) * (2 ** n)) % MOD\n\n    return final_prob\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the probability and time\n    p, time = map(float, input().split())\n\n    # Calculate the probability\n    final_prob = calculate_probability(p, time)\n\n    # Print the result with 4 decimal places\n    print(\"{:.4f}\".format(final_prob))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value():\n    # Read the number of test cases\n    t = int(input())\n\n    # Process each test case\n    for _ in range(t):\n        # Read the probability of rain and time\n        p = float(input().split()[0])\n        time = int(input().split()[1])\n\n        # Calculate the expected value\n        expected_value = 0\n        for i in range(time // 1440, time // 60 + 1):\n            expected_value += (p ** i) * (1 - p ** (time // 60 - i))\n\n        # Print the result rounded to 4 decimal places\n        print('{:.4f}'.format(expected_value))\n\n# Call the function to start the program\ncalculate_expected_value()", "import math\n\ndef calculate_expected_value(P, time):\n    # Calculate the expected value using the formula 1/p\n    expected_value = 1 / P\n    \n    # Since the expected value is the number of minutes it will take for it to rain\n    # and it's a perfect divisor of 1440, we can calculate the actual time\n    actual_time = (expected_value * time) % 1440\n    \n    # Return the actual time\n    return actual_time\n\n# Read the number of test cases\nT = int(input())\n\n# Process each test case\nfor _ in range(T):\n    # Read the probability of rain and the time\n    P = float(input())\n    time = int(input())\n\n    # Calculate the expected value\n    expected_value = calculate_expected_value(P, time)\n\n    # Calculate the probability of rain during the time it takes to reach the office\n    probability = (1 - P) * (1 - P) ** (time // 1440) * P\n\n    # Calculate the expected value of the number of minutes it will take for it to rain\n    expected_minutes = 1 / probability\n\n    # Print the result\n    print('{:.4f}'.format(expected_minutes))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_rain_probability(probability, time):\n    # Calculate the probability of rain during the time\n    probability *= (1 - probability) ** (time - 1)\n    return probability\n\ndef calculate_expected_rain_probability(t):\n    # Calculate the expected probability of rain during the time\n    result = 0\n    for i in range(t // 1440 + 1):\n        result += (1 - (i + 1) / (t // 1440 + 1)) * (\n            (i + 1) / (t // 1440 + 1)\n        ) * expected_rain_probability(\n            1 / (t // 1440 + 1), i\n        )\n    return result\n\ndef main():\n    # Read the number of test cases\n    test_cases = int(input())\n\n    # Process each test case\n    for _ in range(test_cases):\n        # Read the probability and time\n        probability, time = map(float, input().split())\n\n        # Calculate the expected probability of rain during the time\n        result = calculate_expected_rain_probability(time)\n\n        # Print the result\n        print(\"{0:.4f}\".format(result))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        probability = float(input().split()[0])\n        time = int(input().split()[1])\n        rain_time = time * probability\n        no_rain_time = time * (1 - probability)\n        result = (rain_time * probability + no_rain_time * (1 - probability))\n        print(\"{:.4f}\".format(result))\n\ncalculate_expected_time()", "import math\n\ndef calculate_probability(p, time):\n    # Calculate the number of times it can rain in the given time\n    num_rainy_days = time // 1440\n    \n    # Calculate the probability of it raining at least once\n    prob_rain_at_least_once = 1 - (1 - p) ** num_rainy_days\n    \n    return round(prob_rain_at_least_once, 4)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        print(calculate_probability(p, time))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef calculate_expected_time(num_cases):\n    MOD = 10 ** 9 + 7\n    results = []\n\n    for _ in range(num_cases):\n        P, time = map(float, input().split())\n        P = 1 - P  # Convert probability to the complement\n\n        if time == 1440:\n            result = 0\n        else:\n            result = (P * time) % MOD\n\n        for i in range(2, int(math.sqrt(time)) + 1):\n            if time % i == 0:\n                j = time // i\n                if i!= j:  # Check for perfect squares\n                    result += (P * (i * j)) % MOD\n                    result %= MOD\n                if i!= 1:  # Check for perfect squares\n                    result += (P * (i * i)) % MOD\n                    result %= MOD\n                break\n\n        results.append(format(result, '.4f'))\n\n    return results\n\nnum_cases = int(input())\nresults = calculate_expected_time(num_cases)\n\nfor result in results:\n    print(result)", "MOD = 10 ** 9 + 7\n\ndef solve():\n    p, t = map(float, input().split())\n    p = p / 2\n    t = 1440 // t\n    ans = (2 * p * (1 - (p ** t)) + (1 - 2 * p) * (1 - (1 - p) ** t)) * 1440\n    print(f'{ans / 1440:.4f}')\n\nT = int(input())\nfor _ in range(T):\n    solve()", "MOD = 10 ** 9 + 7\n\ndef calculate_probability(rain_probability, travel_time):\n    result = 0\n    for time in range(1, travel_time + 1):\n        if time % 2 == 1:\n            result += (rain_probability * (travel_time // 2) * pow(1 - rain_probability, time // 2, MOD)) % MOD\n        else:\n            result += (rain_probability * (travel_time // 2) * pow(1 - rain_probability, (time - 1) // 2, MOD)) % MOD\n    return result % MOD\n\nT = int(input())\nfor _ in range(T):\n    rain_probability, travel_time = map(float, input().split())\n    result = calculate_probability(rain_probability, travel_time)\n    print(\"{:.4f}\".format(result))", "def calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    for _ in range(int(input())):\n        P, time = map(float, input().split())\n        D = (P + (1 - P)) // 2\n        R = 1\n        while time > 0:\n            if time % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            time //= 2\n        print(round(R, 4))\n\ncalculate_expected_time()", "def calculate_probability(probability, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes for Raj to reach his office.\n\n    Args:\n    probability (float): The probability that it will rain today.\n    time (int): The time it takes for Raj to reach his office in minutes.\n\n    Returns:\n    float: The probability that it rains during the time it takes for Raj to reach his office.\n    \"\"\"\n    # Calculate the probability that it rains during the time it takes for Raj to reach his office\n    probability_rains = probability * (1 - probability * (time // 1440))\n\n    return probability_rains\n\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    # Process each test case\n    for _ in range(t):\n        # Read the probability of rain and time\n        probability, time = map(float, input().split())\n\n        # Calculate and print the probability that it rains during the time it takes for Raj to reach his office\n        probability_rains = calculate_probability(probability, time)\n        print(f\"{probability_rains:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    if P == 0:\n        print(\"{0:.4f}\".format(0))\n    elif P == 0.5:\n        print(\"{0:.4f}\".format(time / 720))\n    else:\n        R = 1\n        D = 1\n        T //= 2\n        while T > 0:\n            if P * D < 0.5:\n                R = R * D % MOD\n                D = D * D % MOD\n                T //= 2\n            else:\n                break\n        print(\"{0:.4f}\".format(R))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P = float(input().split()[0])\n        t = int(input().split()[1])\n        rain = 1 - P\n        ans = P * t + (rain * ((1 - (rain ** t)) / (1 - rain)))\n        print(round(ans, 4))\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        # Since P is the probability of rain, it can be considered as 1 - P for calculation\n        # Also, since time is a perfect divisor of 1440, we can calculate the expected time for a day and then divide it by 1440\n        # We use binomial coefficient to calculate the number of ways to choose k elements from n elements\n        # The formula for binomial coefficient is nCk = n! / (k!(n-k)!)\n        def binomial_coefficient(n, k):\n            return math.factorial(n) // (math.factorial(k) * math.factorial(n-k))\n\n        # Calculate the expected time for a day\n        expected_time_per_day = 0\n        for i in range(int(t / 1440) + 1):\n            expected_time_per_day += (binomial_coefficient(1440, i) * (1 - P) ** i * (1 - (1 - P)) ** (1440 - i) * i)\n\n        # Calculate the expected time for the given time\n        expected_time = expected_time_per_day * (t // 1440)\n\n        # Calculate the expected time for the remaining time\n        remaining_time = t % 1440\n        remaining_probability = (1 - P) ** (remaining_time // 1440)\n        remaining_time *= 1440\n        expected_time += remaining_time * remaining_probability\n\n        # Since we are interested in the time it rains, we multiply by the probability of rain\n        expected_time *= P\n\n        # Print the result modulo 10^9 + 7\n        print(round(expected_time, 4) % MOD)\n\ncalculate_expected_time()", "import math\n\ndef calculate_probability(p, time):\n    # Calculate the expected time it takes for it to rain\n    expected_time = -time / math.log(1 - p)\n    \n    # Calculate the probability that it will rain during the time it takes to reach the office\n    probability = p * (1 - (1 - p) ** expected_time)\n    \n    # Return the probability rounded to 4 decimal places\n    return round(probability, 4)\n\n# Read the number of test cases\nnum_test_cases = int(input())\n\n# Process each test case\nfor _ in range(num_test_cases):\n    # Read the probability and time\n    p, time = map(float, input().split())\n    \n    # Calculate and print the probability\n    print(calculate_probability(p, time))", "import math\n\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    P, t = map(float, input().split())\n    R = 1\n    D = (1 + P) / 2\n    for i in range(t):\n        R = (R * D) % MOD\n        D = (D * D) % MOD\n    print(f\"{R:.4f}\")", "import math\n\nMOD = 10 ** 9 + 7\n\ndef rain_probability(p, time):\n    total_minutes = 1440\n    probability = 0\n    for i in range(time + 1):\n        if i % 2 == 0:\n            probability += (math.comb(total_minutes, i) * (p ** i) * ((1 - p) ** (total_minutes - i)))\n    return probability % MOD\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        p, time = map(float, input().split())\n        probability = rain_probability(p, time)\n        print('{0:0.4f}'.format(probability))\n\nsolve()\nmath.comb(n, k) = math.factorial(n) // (math.factorial(k) * math.factorial(n - k))", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n    D = t / 1440\n    R = 1\n    for i in range(int(1440 * D) + 1):\n        if i % 2 == 0:\n            R = (R * (1 - P)) % MOD\n        else:\n            R = (R * P) % MOD\n    print(\"{0:.4f}\".format(R))", "import math\nMOD = 10 ** 9 + 7\n\ndef expected_rain(t, p):\n    R = 1\n    D = (1 + p) // 2\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(format(expected_rain(t, p), '.4f'))", "import math\n\ndef expected_rain_time(T, P, time):\n    # Calculate the time it takes to reach the office with no rain\n    no_rain_time = (1440 * time) / 12\n    \n    # Calculate the probability of rain at each time interval\n    probability = P / time\n    for i in range(1, int(time / 12) + 1):\n        probability *= (1 - P)\n    \n    # Calculate the expected time\n    expected_time = (no_rain_time * probability) + ((time * (1 - probability)) * (1 + P))\n    \n    return round(expected_time, 4)\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print(expected_rain_time(T, P, time))", "import math\n\ndef calculate_expected_time():\n    MOD = 10**9 + 7\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a == sorted(a):\n        print(0)\n        return\n\n    m = {}\n    for i in a:\n        if i in m:\n            m[i] += 1\n        else:\n            m[i] = 1\n    num = 1\n    for i in m:\n        num *= math.factorial(m[i])\n    den = math.factorial(n)\n\n    expected_time = (den / num) * 60\n    print(f'{expected_time:.6f}')\n\nt = int(input())\nfor _ in range(t):\n    calculate_expected_time()\nMOD = 10 ** 9 + 7\nt = int(input())\na, b, time = map(int, input().split())\n\nD = (a + b) // 2\nR = 1\nwhile time > 0:\n    if time % 2:\n        R = R * D % MOD\n    D = D * D % MOD\n    time //= 2\n\nprint(R)", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    P = float(input().split()[0])\n    time = int(input().split()[1])\n    R = P * (1 + (1 - P) * time)\n    print(f\"{R:.4f}\")", "MOD = 10 ** 9 + 7\ndef calculate_probability(rain_probability, time):\n    total_minutes = 1440  # Total minutes in a day\n    denominator = total_minutes // time  # Denominator for the probability calculation\n    expected_minutes = (total_minutes - time) * rain_probability + time * (1 - rain_probability)\n    return round((denominator / time) * expected_minutes, 4)\n\nt = int(input())\nfor _ in range(t):\n    p, time = map(float, input().split())\n    print(calculate_probability(p, time))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    # Calculate the probability that it rains during the time\n    probability = p * (1 - pow(1 - p, time, MOD))\n    return probability\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        probability = calculate_probability(p, time)\n        probability = round(probability, 4)\n        print(f\"{probability:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\n\ndef calculate_expected_time():\n    T = int(input())\n    for _ in range(T):\n        P = float(input())\n        time = int(input())\n        expected_time = 0\n        for i in range(1, time + 1):\n            if i % 2:\n                expected_time = (expected_time + P * i) % MOD\n            else:\n                expected_time = (expected_time + (1 - P) * i) % MOD\n        print(f\"{expected_time:.4f}\")\n\ncalculate_expected_time()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n\n        # Calculate the probability of rain on each time interval\n        prob_rain = P\n        prob_no_rain = 1 - P\n\n        # Calculate the expected number of minutes it will rain\n        expected_rain_minutes = 0\n        for i in range(t + 1):\n            if i % 1440 // t == 0:  # Check if it's the end of a 1440 minute interval\n                prob_rain *= (i / t)\n                prob_no_rain *= (1 / t)\n            else:\n                expected_rain_minutes += (prob_rain * i / t + prob_no_rain * (1440 / t))\n\n        print(f\"{expected_rain_minutes:.4f}\")\n\ncalculate_expected_value()", "import math\nimport sys\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        print('{0:.4f}'.format(p * time))\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_probability(p, t):\n    probability = 0\n    for i in range(t + 1):\n        if i % 2 == 0:\n            probability += (p**i) * (1 - p)**(t - i)\n        else:\n            probability += (p**i) * (1 - p)**(t - i) * p\n    return probability\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    probability = calculate_probability(p, t)\n    print('{:.4f}'.format(probability))", "def calculate_probability(t, p):\n    time_factors = [1440 / factor for factor in get_divisors(t)]\n    probabilities = [p ** factor for factor in time_factors]\n    expected_value = sum(factor * probability for factor, probability in zip(time_factors, probabilities))\n    return round(expected_value, 4)\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i * i!= n:\n                divisors.append(n // i)\n    return divisors\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(calculate_probability(t, p))", "import math\n\nMOD = 10**9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        p, t = map(float, input().split())\n        p = p / 2\n        t = t / 1440\n        result = 0\n        for i in range(int(t) + 1):\n            result += math.comb(int(t), i) * (p ** i) * ((1 - p) ** (int(t) - i))\n        result = result * 1440\n        print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\ndef expected_rainfall_probability(p, time):\n    # Calculate the probability of no rainfall during the time\n    prob_no_rain = (1 - p) ** time\n\n    # Calculate the probability of rainfall during the time\n    prob_rain = p * prob_no_rain\n\n    # Return the probability of rainfall, rounded to 4 decimal places\n    return round(prob_rain, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability and time\n    p, time = map(float, input().split())\n\n    # Calculate and print the expected rainfall probability\n    print(expected_rainfall_probability(p, time))", "def expected_minutes(N, P, time):\n    MOD = 10 ** 9 + 7\n    # Calculate the expected number of minutes to be spent waiting\n    expected_minutes = 0\n    for i in range(time + 1):\n        # Calculate the probability of the sequence being sorted after i minutes\n        probability = (P ** i) * ((1 - P) ** (time - i))\n        # Add the product of the probability and the number of minutes to the expected minutes\n        expected_minutes += probability * i\n    return expected_minutes % MOD\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = float(input())\n    time = int(input())\n    print(format(expected_minutes(N, P, time), \".4f\"))", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_value():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = 1\n        D = (1 + P) / 2\n        for i in range(t):\n            if i % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n        print(\"{0:.4f}\".format(R))\n\ncalculate_expected_value()", "def calculate_expected_virus_cells(a, b, t):\n    MOD = 10**9 + 7\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = (R * D) % MOD\n        D = (D * D) % MOD\n        t //= 2\n    return R\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        a, b, t = map(int, input().split())\n        R = calculate_expected_virus_cells(a, b, t)\n        print(f\"{R:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\nfrom math import factorial\n\ndef calculate_expected_minutes(N, permutation):\n    if permutation == sorted(permutation):\n        return 0\n    m = {}\n    for num in permutation:\n        if num in m:\n            m[num] += 1\n        else:\n            m[num] = 1\n    num = 1\n    for key in m:\n        num *= factorial(m[key])\n    den = factorial(N)\n    return format(den / num, \".6f\")\n\ndef main():\n    N = int(input())\n    permutation = list(map(int, input().split()))\n    expected_minutes = calculate_expected_minutes(N, permutation)\n    print(expected_minutes)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef solve(p, t):\n    return (p * (t + 1) - 1) % MOD\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(f\"{solve(p, t):.4f}\")", "def calculate_probability(rain_probability, travel_time):\n    # Calculate the sum of probabilities of no rain and rain during the travel\n    total_probability = rain_probability * (1 - rain_probability) * (travel_time * (travel_time + 1) // 2)\n    return total_probability\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        rain_probability, travel_time = map(float, input().split())\n        probability = calculate_probability(rain_probability, travel_time)\n        print(f\"{probability:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10**9 + 7\ndef rain_probability(p, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes to reach the office.\n    \n    Args:\n    p (float): The probability of rain.\n    time (int): The time it takes to reach the office in minutes.\n    \n    Returns:\n    float: The probability that it rains during the time it takes to reach the office.\n    \"\"\"\n    # Calculate the time it takes to reach the office if it rains\n    if time % 2 == 0:\n        return (1 - p) * (1 + p) * ((1 + p) ** (time // 2 - 1)) * (1 - p) * (1 + p) ** (time // 2 - 1)\n    else:\n        return (1 - p) * (1 + p) * ((1 + p) ** ((time - 1) // 2 - 1)) * (1 - p) * (1 + p) ** ((time - 1) // 2)\n\nt = int(input())\nfor _ in range(t):\n    p, time = map(float, input().split())\n    result = rain_probability(p, time)\n    print('{:.4f}'.format(result))", "import math\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        D = t // 1440\n        R = 1\n        while D > 0:\n            if D % 2:\n                R = (R * (1 + P)) % MOD\n            D //= 2\n            P *= 2\n        print('{:.4f}'.format(R))\n\ncalculate_expected_time()\nR = P / (1 - 2P)\nR = P + (P^2)/2 + (P^3)/3 +...", "MOD = 10 ** 9 + 7\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        p, time = map(float, input().split())\n        print('{:.4f}'.format(p * time))\nsolve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(time, probability):\n    \"\"\"Calculates the probability that it rains during the time it takes to reach the office.\"\"\"\n    if probability == 0:\n        return 0\n    if probability == 0.5:\n        return 0.5\n    if probability == 1:\n        return 1\n\n    # Calculate the expected number of rainy hours\n    expected_rainy_hours = (time / (1440 / probability))\n    # Calculate the probability of rain during the expected number of rainy hours\n    probability_of_rain = probability * (1 - probability) ** expected_rainy_hours\n    # Calculate the expected number of rainy hours modulo 10^9 + 7\n    expected_rainy_hours_modulo = int(expected_rainy_hours % (1440 / probability) + 0.5)\n    # Calculate the probability of rain during the expected number of rainy hours modulo 10^9 + 7\n    probability_of_rain_modulo = int(probability * (1 - probability) ** expected_rainy_hours_modulo + 0.5)\n    return probability_of_rain_modulo\n\ndef main():\n    \"\"\"Main function to solve the problem.\"\"\"\n    # Read the number of test cases\n    num_test_cases = int(input())\n    # Read the input values\n    for _ in range(num_test_cases):\n        probability, time = map(float, input().split())\n        # Calculate the probability of rain during the given time\n        probability_of_rain = calculate_probability(time, probability)\n        # Print the probability of rain during the given time\n        print(\"{:.4f}\".format(probability_of_rain))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef expected_time(t, p):\n    total_minutes = 1440\n    time_factor = total_minutes // t\n    return (time_factor * (1 - p**time_factor)) % MOD\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(f\"{expected_time(t, p):.4f}\")", "import math\n\nMOD = 10 ** 9 + 7\n\ndef logan_sorting_time(N, P):\n    time = 0\n    p = 1.0\n    while p < P:\n        time += 1\n        p *= 2\n    return time\n\ndef calculate_expected_time(N, P, time):\n    p = 1.0\n    total = 0\n    for i in range(time + 1):\n        total += i * (p)\n        p *= 2\n    return total\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        P = float(input())\n        P = P / 2.0\n        time = logan_sorting_time(N, P)\n        expected_time = calculate_expected_time(N, P, time)\n        print('{0:6.4f}'.format(expected_time))\n\nif __name__ == \"__main__\":\n    main()", "import math\nimport sys\n\nMOD = 10**9 + 7\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        t //= 1440  # convert minutes to hours\n        ans = 0\n        for i in range(int(t)+1):\n            ans += (math.comb(t, i) * (P**i) * ((1-P)**(t-i)))\n        ans %= MOD\n        print('{0:5.4f}'.format(ans))\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\ndef calculate_probability(a, b, t):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n    \n    Parameters:\n    a (float): The probability that it will rain today.\n    b (float): The time (in minutes) it will take for Raj to reach his office.\n    t (int): The time for which Raj is on the way to his office (in minutes).\n    \n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    # Calculate the probability of not raining during the time Raj is on the way\n    prob_not_raining = (1 - a) ** (t // b)\n    \n    # Calculate the probability that it rains during the time Raj is on the way\n    prob_raining = 1 - prob_not_raining\n    \n    return prob_raining\n\ndef main():\n    # Read the number of test cases\n    num_test_cases = int(input())\n    \n    # Run the test cases\n    for _ in range(num_test_cases):\n        # Read the probability of rain and the time\n        a, t = map(float, input().split())\n        \n        # Calculate the probability that it rains during the time Raj is on the way\n        prob_raining = calculate_probability(a, 1440 // t, t)\n        \n        # Print the result rounded to 4 decimal places\n        print(\"{0:.4f}\".format(prob_raining))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\nfor _ in range(int(input())):\n    P, t = map(float, input().split())\n    print(format((1 - P) * (1 - P ** t), '.4f'))", "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        ans = 0\n        for i in range(1, int(time / 1440) + 1):\n            ans += (p * (1 - p) * ((lcm(1440, i) // 1440) ** 2))\n        print(f\"{ans:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        R = 1\n        D = (1 - P + P / 2) / (1 - P)\n        for i in range(time):\n            R = (R * D) % MOD\n            D = (D * D) % MOD\n        print(f\"{R:.4f}\")\n\ncalculate_probability()", "from math import factorial\n\ndef expected_minutes(N, a):\n    \"\"\"\n    Calculate the expected number of minutes Logan will spend waiting for his sequence to be sorted.\n\n    Args:\n    N (int): The size of the permutation.\n    a (list): The current order of the permutation.\n\n    Returns:\n    float: The expected number of minutes.\n    \"\"\"\n    if a == sorted(a):\n        return 0\n    else:\n        m = {}\n        for i in a:\n            if i in m:\n                m[i] += 1\n            else:\n                m[i] = 1\n        num = 1\n        for i in m:\n            num *= factorial(m[i])\n        den = factorial(N)\n        return '%0.6f' % (den / num)\n\ndef main():\n    \"\"\"\n    Read the number of test cases and calculate the expected number of minutes for each test case.\n    \"\"\"\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(int, input().split()))\n        print(expected_minutes(N, a))\n\nif __name__ == \"__main__\":\n    main()\nMOD = 10 ** 9 + 7\n\ndef expected_virus_cells(A, B, T):\n    \"\"\"\n    Calculate the expected number of virus cells after a given period of time.\n\n    Args:\n    A (int): The first growth factor.\n    B (int): The second growth factor.\n    T (int): The time period.\n\n    Returns:\n    int: The expected number of virus cells modulo (10^9 + 7).\n    \"\"\"\n    D = (A + B) // 2\n    R = 1\n    while T > 0:\n        if T % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        T //= 2\n    return R\n\ndef main():\n    \"\"\"\n    Read the values of A, B, and T and calculate the expected number of virus cells.\n    \"\"\"\n    A, B, T = map(int, input().split())\n    print(expected_virus_cells(A, B, T))\n\nif __name__ == \"__main__\":\n    main()\nfrom math import log\n\ndef expected_rain_probability(P, time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n\n    Args:\n    P (float): The probability that it will rain today.\n    time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    return 1 - (1 - P) ** time\n\ndef main():\n    \"\"\"\n    Read the number of test cases and calculate the probability that it rains during the time Raj is on the way to his office for each test case.\n    \"\"\"\n    T = int(input())\n    for _ in range(T):\n        P = float(input())\n        time = int(input())\n        print('%0.4f' % expected_rain_probability(P, time))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    R = 1\n    D = (1 + p) * (1 - p) * (1 - p)\n    while time > 0:\n        if time % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        time //= 2\n    return R\n\nT = int(input())\n\nfor _ in range(T):\n    p, time = map(float, input().split())\n    probability = calculate_probability(p, time)\n    print(\"{0:.4f}\".format(probability))", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_time():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        t = t / 1440\n        R = 1\n        D = (1 + P)\n        while t > 0:\n            if t % 1 > 0:\n                R = R * D % MOD\n            D = D * D % MOD\n            t = t / 2\n        print(f\"{R:.4f}\")\n\ncalculate_expected_time()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(rainfall_probability, travel_time):\n    # Calculate the probability of rain during travel\n    probability = rainfall_probability * (1 - (rainfall_probability ** travel_time))\n\n    # Calculate the expected number of minutes with rain\n    expected_minutes = 1440 * rainfall_probability * (1 - (rainfall_probability ** travel_time)) / (1 - (rainfall_probability ** travel_time))\n\n    # Return the result modulo MOD\n    return round(expected_minutes, 4)\n\nT = int(input())\n\nfor _ in range(T):\n    P, time = map(float, input().split())\n\n    print(calculate_probability(P, time))", "def expected_cells(a, b, t):\n    MOD = 10 ** 9 + 7\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = (1 - P) * t + P\n        R = (R % 1) * (10 ** 4) + (R % 10) * 10 ** 3 + (int(R % 100) // 10) * 10 ** 2 + (int(R % 100) % 10) * 10 + int(R * 10 ** 4)\n        R %= (10 ** 9 + 7)\n        print(format(R, '.4f'))\n\nmain()", "import math\n\nMOD = 10 ** 9 + 7\npi = 0.5\n\ndef calculate_probability(time, probability):\n    R = 1\n    D = (1 + probability) // 2\n    while time > 0:\n        if time % 2:\n            R = (R * D) % MOD\n        D = (D * D) % MOD\n        time //= 2\n    return R\n\nT = int(input())\nfor _ in range(T):\n    probability, time = map(float, input().split())\n    result = calculate_probability(time, probability)\n    print(f\"{result:.4f}\")", "def calculate_probability(time, probability):\n    return probability * (time / 1440)\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        probability = calculate_probability(time, p)\n        print('{:.4f}'.format(probability))\n\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef calculate_probability(rain_probability, travel_time):\n    # Calculate the expected number of minutes it rains during the travel time\n    expected_rain_minutes = travel_time * rain_probability\n    \n    # Calculate the probability that it rains during the travel time\n    probability = 1 - (1 - rain_probability) ** travel_time\n    \n    # Calculate the expected number of rain minutes rounded to 4 decimal places\n    expected_rain_minutes = round(expected_rain_minutes, 4)\n    \n    return probability\n\nT = int(input())\n\nfor _ in range(T):\n    rain_probability = float(input().split()[0])\n    travel_time = int(input().split()[1])\n    \n    probability = calculate_probability(rain_probability, travel_time)\n    print(f\"{probability:.4f}\")", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n    t /= 1440\n    P *= 1440\n    ans = P * sum((1 - P)**(i) * i for i in range(int(t)))\n    ans %= MOD\n    print(f\"{ans:.4f}\")", "import math\n\nMOD = 10**9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = 1\n        D = 1\n        while t > 0:\n            if t % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            t //= 2\n        R = R * (1 - P) % MOD\n        R = (R + MOD) % MOD\n        print(f\"{R:.4f}\")\n\nif __name__ == \"__main__\":\n    solve()", "import math\nimport sys\n\ndef expected_minutes(N, a):\n    total_probability = 1.0\n    expected_minutes = 0.0\n    for i in range(1, N + 1):\n        total_probability *= 0.5\n        if total_probability == 0.0:\n            break\n        total_probability *= i\n        expected_minutes += i * total_probability\n    return round(expected_minutes, 6)\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(float, input().split()))\n        if a == sorted(a):\n            print(0)\n        else:\n            m = {}\n            for i in a:\n                if i in m:\n                    m[i] += 1\n                else:\n                    m[i] = 1\n            num = 1\n            for i in m:\n                num *= math.factorial(m[i])\n            den = math.factorial(N)\n            print('%0.6f' % (den / num))\n\nif __name__ == \"__main__\":\n    main()\nMOD = 10 ** 9 + 7\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        A, B, T = map(int, input().split())\n        D = (A + B) // 2\n        R = 1\n        while T > 0:\n            if T % 2:\n                R = (R * D) % MOD\n            D = (D * D) % MOD\n            T //= 2\n        print(R)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, t):\n    # Calculate the probability that it rains during the time\n    prob = p * (1 - p * (t / 1440))\n    return round(prob, 4)\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(calculate_probability(p, t))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        p = 1 - p  # Probability that it does not rain\n        time = int(time)  # Convert to minutes\n        d = 1440 // time  # Calculate number of days\n        r = (1 - p ** (1 << d))  # Calculate probability that it does not rain in d days\n        print(f\"{(1 - r) * 1440 * time:.4f}\")\n\nif __name__ == \"__main__\":\n    solve()", "from math import gcd\nfrom functools import reduce\n\ndef get_probability(p, t, mod):\n    # Calculate the denominator\n    denominator = 1\n    for i in range(t):\n        denominator = (denominator * (1 - p)) % mod\n    denominator = int(denominator)\n    \n    # Calculate the numerator\n    numerator = 1\n    for i in range(t):\n        numerator = (numerator * (1 + p)) % mod\n    \n    # Calculate the expected probability\n    expected_probability = (numerator * pow(denominator, -1, mod)) % mod\n    return expected_probability\n\ndef main():\n    MOD = 10**9 + 7\n    num_test_cases = int(input())\n    for _ in range(num_test_cases):\n        p, t = map(float, input().split())\n        # Convert p to a fraction\n        p_numerator = int(p * 1440)\n        p_denominator = 1440\n        # Calculate the expected probability\n        expected_probability = get_probability(p_numerator, t, MOD)\n        print(f\"{expected_probability:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef logan_wait_time(N, P):\n    \"\"\"\n    Calculate the expected number of minutes Logan will spend waiting for his sequence to be sorted.\n    \n    Parameters:\n    N (int): The size of the permutation.\n    P (float): The probability of the sequence being sorted after a minute.\n    \n    Returns:\n    float: The expected number of minutes.\n    \"\"\"\n    return 1 / (1 - P)\n\ndef virus_cell_count(A, B, T):\n    \"\"\"\n    Calculate the expected number of virus cells after a given period of time.\n    \n    Parameters:\n    A (int): The first growth factor.\n    B (int): The second growth factor.\n    T (int): The time period.\n    \n    Returns:\n    int: The expected number of virus cells modulo (10^9 + 7).\n    \"\"\"\n    MOD = 10 ** 9 + 7\n    D = (A + B) // 2\n    R = 1\n    while T > 0:\n        if T % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        T //= 2\n    return R\n\ndef rain_probability(P, T):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n    \n    Parameters:\n    P (float): The probability of rain.\n    T (int): The time period.\n    \n    Returns:\n    float: The probability that it rains during the time Raj is on the way.\n    \"\"\"\n    return 1 - (1 - P) ** (T // 1440)\n\nT = int(input())\nfor _ in range(T):\n    N, P = map(float, input().split())\n    time = float(input())\n    \n    logan_time = logan_wait_time(N, P)\n    rain_prob = rain_probability(P, time)\n    virus_cells = virus_cell_count(2, 4, time)\n    \n    print(\"{:.4f}\".format(logan_time * 60 + rain_prob * 1000 + virus_cells))", "import math\n\nMOD = 10**9 + 7\n\ndef solve_p():\n    P, t = map(float, input().split())\n    D = P\n    R = 1\n    for _ in range(t):\n        if P >= 0.5:\n            R = (R * D) % MOD\n        else:\n            R = (R * (1 - D)) % MOD\n        D = D * D % MOD\n    print(\"{0:.4f}\".format(R))\n\ndef main():\n    for _ in range(int(input())):\n        solve_p()\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_time(T, P, time):\n    expected_value = 0\n    for i in range(1, int(time/1440) + 1):\n        # calculate the probability of i occurrences of rain\n        prob_i_occurrences = math.comb(int(time/1440), i) * (P**i) * ((1-P)**(int(time/1440)-i))\n        \n        # calculate the expected value for i occurrences of rain\n        expected_value += prob_i_occurrences * i * 1440\n    return round(expected_value % MOD, 4)\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print(calculate_expected_time(T, P, time))", "MOD = 10**9 + 7\n\ndef calculate_probability():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        p = 1.0\n        for i in range(t):\n            p = (1.0 - P**2) * p + 2.0 * P * P * p\n        print(f\"{p:.4f}\")\n\ncalculate_probability()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    P, time = map(float, input().split())\n    D = P / (1 - P)\n    R = 1\n    while time > 0:\n        if time % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        time //= 2\n    print(f'{R * (1 - P) * 1440:.6f}')\n\nfor _ in range(int(input())):\n    solve()", "", "import math\n\ndef logan_time(N, P):\n    P = float(P)\n    probability = 1.0\n    total_time = 0\n    while True:\n        total_time += 1\n        probability *= 2 * (1 - P) + P\n        if abs(probability - 1.0) < 1e-9:\n            break\n    return total_time\n\ndef virus_cells(A, B, T):\n    MOD = 10 ** 9 + 7\n    D = (A + B) // 2\n    R = 1\n    while T > 0:\n        if T % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        T //= 2\n    return R\n\ndef rain_probability(P, time):\n    return 1.0 - (1.0 - P) ** (time / 1440.0)\n\nT = int(input())\nfor _ in range(T):\n    N = int(input().split()[0])\n    a = list(map(float, input().split()))\n    if a[0] == 0:\n        print(format(rain_probability(a[0], N), \".4f\"))\n    else:\n        print(format(logan_time(N, a[0]), \".6f\"))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        probability = 1\n        for i in range(time):\n            probability = (probability + P) * (1 - P) / 2\n        print(format(probability, '.4f'))\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\ndef calculate_expected_value(p, time):\n    \"\"\"\n    Calculate the expected number of minutes Logan will spend waiting for P to be sorted.\n    \n    Args:\n        p (float): The probability of the sequence being sorted in one minute.\n        time (int): The number of minutes to wait.\n    \n    Returns:\n        float: The expected number of minutes.\n    \"\"\"\n    return sum(i * p ** i for i in range(1, time + 1))\n\ndef calculate_expected_cells(a, b, t):\n    \"\"\"\n    Calculate the expected number of virus cells after t milliseconds.\n    \n    Args:\n        a (int): The probability of the number of virus cells growing by a factor of a.\n        b (int): The probability of the number of virus cells growing by a factor of b.\n        t (int): The time in milliseconds.\n    \n    Returns:\n        int: The expected number of virus cells modulo (10^9+7).\n    \"\"\"\n    MOD = 10 ** 9 + 7\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef calculate_rain_probability(p, time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way.\n    \n    Args:\n        p (float): The probability of rain.\n        time (int): The time in minutes.\n    \n    Returns:\n        float: The probability of rain.\n    \"\"\"\n    return 1 - (1 - p) ** time\n\ndef main():\n    for _ in range(int(input())):\n        p, time = map(float, input().split())\n        print(\"{:.4f}\".format(calculate_rain_probability(p, time)))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        if P == 0:\n            print(f\"{0:0.4f}\")\n            continue\n        R = 1\n        for i in range(t, 0, -2):\n            R = R * (1 + P) % MOD\n            R = R * (1 - P) % MOD\n        print(f\"{R:0.4f}\")\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n\n    # Calculate the probability that it will rain during the time\n    prob = P * (1 - P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P) * (1 + P)\n\n    # Print the result rounded to 4 decimal places\n    print('{:.4f}'.format(prob))", "import math\n\ndef calculate_probability(probability, time):\n    # Calculate the probability that it does not rain during the time\n    no_rain_probability = 1 - probability\n    # Calculate the expected number of rainy days in the given time\n    expected_rainy_days = (probability / (1 - no_rain_probability)) * time\n    # Return the probability that it rains during the time\n    return probability * time - expected_rainy_days\n\n# Read the number of test cases\nnum_test_cases = int(input())\n\n# Process each test case\nfor _ in range(num_test_cases):\n    # Read the probability and time\n    probability = float(input().split()[0])\n    time = int(input().split()[1])\n    # Calculate the expected number of rainy days and print the result\n    result = calculate_probability(probability, time)\n    print('{:.4f}'.format(result))", "import math\n\ndef expected_time(rain_probability, travel_time):\n    \"\"\"\n    Calculate the expected time it takes for it to rain during travel.\n\n    Args:\n        rain_probability (float): The probability of rain.\n        travel_time (int): The time it takes to travel.\n\n    Returns:\n        float: The expected time it takes for it to rain during travel.\n    \"\"\"\n    # Calculate the probability of no rain\n    no_rain_probability = 1 - rain_probability\n\n    # Initialize the expected time to 0\n    expected_time = 0\n\n    # Loop through each minute of travel time\n    for i in range(travel_time):\n        # Calculate the probability of rain at this minute\n        probability_of_rain = rain_probability * (no_rain_probability ** (travel_time - i - 1))\n\n        # Add the probability of rain to the expected time\n        expected_time += probability_of_rain\n\n        # Update the probability of no rain\n        no_rain_probability *= (1 - rain_probability)\n\n    return expected_time\n\ndef main():\n    # Get the number of test cases\n    num_test_cases = int(input())\n\n    # Loop through each test case\n    for _ in range(num_test_cases):\n        # Get the probability of rain and travel time\n        rain_probability, travel_time = map(float, input().split())\n\n        # Calculate the expected time\n        expected_time_value = expected_time(rain_probability, travel_time)\n\n        # Print the expected time, rounded to 4 decimal places\n        print(\"{:.4f}\".format(expected_time_value))\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\n\ndef calculate_expected_value(p, t):\n    \"\"\"Calculates the expected value of a geometric distribution.\"\"\"\n    result = (p * (1 - (1 - p) ** t)) % MOD\n    return result\n\ndef main():\n    T = int(input())\n\n    for _ in range(T):\n        p, t = map(float, input().split())\n        t = int(t)  # Convert time to integer\n        result = calculate_expected_value(p, t)\n        print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\nimport sys\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        t = math.log(t, 2)\n        p = math.log(1 - P, 2)\n        ans = (1 + 2**p) / 2 * (1 + 2**t) / 2\n        print(f\"{ans:.4f}\")\n\nif __name__ == \"__main__\":\n    solve()", "def calculate_probability(T):\n    # Calculate the probability that it rains during the time\n    P = float(input())\n    time = int(input())\n    \n    # Calculate the probability of rain during the time\n    probability = (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P) * (1 - P)\n    \n    return round(probability, 4)\n\n\n# Main function\ndef main():\n    # Read the number of test cases\n    T = int(input())\n    \n    # Loop through each test case\n    for _ in range(T):\n        print(calculate_probability(_))\n\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_time(N, permutation):\n    if permutation == sorted(permutation):\n        return 0\n\n    num = 1\n    for i in set(permutation):\n        num *= math.factorial(permutation.count(i))\n    den = math.factorial(N)\n\n    return den / num\n\ndef solve_test_case():\n    N = int(input())\n    permutation = list(map(int, input().split()))\n    return format(expected_time(N, permutation), '.6f')\n\nT = int(input())\n\nfor _ in range(T):\n    print(solve_test_case())", "from math import sqrt\n\nMOD = 10 ** 9 + 7\n\ndef extended_gcd(a, b):\n    \"\"\"Extended Euclidean algorithm to find gcd and coefficients\"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef mod_inv(a, m):\n    \"\"\"Modular inverse using Extended Euclidean algorithm\"\"\"\n    gcd, x, _ = extended_gcd(a, m)\n    return x % m\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        R = 1\n        D = (1 + P)\n        for _ in range(int(sqrt(time))):\n            R = (R * D) % MOD\n            D = (D * D) % MOD\n        R = (R * (1 - P * D)) % MOD\n        R = (R * mod_inv(D, MOD)) % MOD\n        R = R * mod_inv(1 - P, MOD) % MOD\n        R = round(R, 4)\n        print(f\"{R}\")\n\nif __name__ == \"__main__\":\n    solve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value(p, time):\n    # Calculate the expected value using the formula for geometric series\n    expected_value = (1 - p ** (2 ** time)) / (1 - p)\n    return expected_value\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        expected_value = calculate_expected_value(p, time)\n        # Round the expected value to 4 decimal places\n        expected_value = round(expected_value, 4)\n        print(f\"{expected_value:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef calculate_probability(rain_probability, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes for Raj to reach his office.\n\n    Args:\n        rain_probability (float): The probability that it will rain today.\n        time (int): The time it will take for Raj to reach his office in minutes.\n\n    Returns:\n        float: The probability that it rains during the time it takes for Raj to reach his office.\n    \"\"\"\n    # Calculate the expected value of the geometric distribution\n    expected_value = (1 - rain_probability) / rain_probability * time\n\n    # Return the probability that it rains during the time it takes for Raj to reach his office\n    return 1 - math.pow(1 - rain_probability * math.e, expected_value)\n\n\n# Read the number of test cases\nnum_test_cases = int(input())\n\n# Process each test case\nfor _ in range(num_test_cases):\n    # Read the probability of rain and time\n    rain_probability, time = map(float, input().split())\n\n    # Calculate the probability that it rains during the time it takes for Raj to reach his office\n    probability = round(calculate_probability(rain_probability, time), 4)\n\n    # Print the result\n    print(probability)", "def expected_rain_probability(p, t):\n    # Calculate the expected number of rainy minutes\n    expected_rainy_minutes = p * t\n    \n    # Calculate the probability of no rain\n    no_rain_probability = (1 - p) * (1 - p)\n    \n    # Calculate the expected number of minutes with rain\n    expected_rain_minutes = expected_rainy_minutes / (1 - no_rain_probability)\n    \n    # Return the expected probability of rain\n    return round(expected_rain_minutes, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability and time\n    p, t = map(float, input().split())\n    \n    # Calculate and print the expected probability of rain\n    print(expected_rain_probability(p, t))", "def calculate_expected_value():\n    MOD = 10 ** 9 + 7\n    test_cases = int(input())\n\n    for _ in range(test_cases):\n        P, time = map(float, input().split())\n\n        # Calculate the expected value\n        expected_value = 0\n        for i in range(1, int(time // 1440) + 1):\n            # Calculate the number of possible outcomes\n            outcomes = 2 ** (time // 1440)\n\n            # Calculate the probability of each outcome\n            probability = (1 - P) ** (time // 1440 - i) * P ** i\n\n            # Calculate the expected value\n            expected_value += probability * i * outcomes\n\n        # Calculate the expected value modulo MOD\n        expected_value %= MOD\n\n        # Print the result rounded to 4 decimal places\n        print(f\"{expected_value:.4f}\")\n\n\nif __name__ == \"__main__\":\n    calculate_expected_value()", "def calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way.\n    \n    Args:\n    rain_probability (float): The probability of rain today.\n    travel_time (int): The time (in minutes) it will take for Raj to reach his office.\n    \n    Returns:\n    float: The probability that it rains during the time Raj is on the way.\n    \"\"\"\n    # Since it's raining or not is a binary event, we can model this as a geometric distribution\n    # The probability of rain during the travel time is 1 - (probability of no rain)\n    # The probability of no rain is (1 - rain_probability)^(travel_time)\n    return 1 - (1 - rain_probability) ** travel_time\n\nMOD = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    P = 1 - P  # Convert P to probability of no rain\n    result = (1 - P ** t) % MOD\n    print(\"{0:.4f}\".format(result))", "from math import gcd\n\nMOD = 10**9 + 7\n\ndef extended_gcd(a, b):\n    \"\"\"Returns the gcd and the coefficients x, y such that a*x + b*y = gcd(a, b)\"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef mod_inverse(a, m):\n    \"\"\"Returns the modular inverse of a modulo m\"\"\"\n    gcd, x, y = extended_gcd(a, m)\n    if gcd!= 1:\n        raise ValueError(\"Modular inverse does not exist\")\n    return x % m\n\ndef expected_value(a, b, t):\n    \"\"\"Calculates the expected value of (a^t + b^t)\"\"\"\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        t = t // 1440 * 1440  # convert minutes to seconds\n        a = 2\n        b = 4\n        R = expected_value(a, b, t)\n        print(f\"{R:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time(p, t):\n    R = 1\n    D = (1 + p) / (1 - p)\n    for _ in range(t):\n        R = R * D % MOD\n        D = D * D % MOD\n    return R\n\nT = int(input())\nfor _ in range(T):\n    p = float(input().split()[0])\n    t = int(input().split()[1])\n    result = calculate_expected_time(p, t)\n    print(\"{0:.4f}\".format(result))", "import math\n\ndef calculate_probability(p, time):\n    # Calculate the expected number of rainy days\n    total_rainy_days = time / 1440\n\n    # Calculate the probability of no rainy days\n    prob_no_rainy_days = (1 - p) ** total_rainy_days\n\n    # Calculate the probability of at least one rainy day\n    prob_at_least_one_rainy_day = 1 - prob_no_rainy_days\n\n    return round(prob_at_least_one_rainy_day, 4)\n\nT = int(input())\nfor _ in range(T):\n    p, time = map(float, input().split())\n    print(calculate_probability(p, time))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = 1\n        D = (1 + P)\n        for i in range(t):\n            R = (R * D) % MOD\n            D = (D * D) % MOD\n        print(format(R, \".4f\"))\n\nsolve()", "import math\n\ndef expected_minutes Waiting_Time):\n    MOD = 10 ** 9 + 7\n    P = Waiting_Time / 1440.0  # P is the probability of rain\n    T = Waiting_Time  # Time is in minutes\n    D = (1 + P) * (1 + (1 - P))  # D is the sum of the probabilities\n    R = 1\n    while T > 0:\n        if T % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        T //= 2\n    return R\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, t = map(float, input().split())\n        print(f\"{expected_minutes(t):.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_time(p, time):\n    # Calculate the expected number of rainfalls during the given time\n    expected_rainfalls = (1 - p) * time + p * (time + 1) // 2\n    \n    # Calculate the expected total time considering the rain or no rain\n    expected_total_time = time + (expected_rainfalls * time)\n    \n    return round(expected_total_time, 4)\n\n# Read the number of test cases\nT = int(input())\n\nfor _ in range(T):\n    # Read the probability and time\n    p, time = map(float, input().split())\n    \n    # Calculate and print the expected time\n    expected_time = calculate_expected_time(p, time)\n    print(expected_time)", "def calculate_probability(p, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes to reach the office.\n\n    Args:\n    p (float): The probability of rain.\n    time (int): The time it takes to reach the office in minutes.\n\n    Returns:\n    float: The probability that it rains during the time it takes to reach the office.\n    \"\"\"\n    return p * time\n\ndef main():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        # Since time is a perfect divisor of 1440, we can find the number of times it divides 1440\n        num_times = 1440 // time\n        # The expected number of rainfalls during the time it takes to reach the office is the sum of probabilities of each time it rains\n        probability = sum(calculate_probability(p, i) for i in range(num_times + 1))\n        probability %= MOD\n        print(f\"{probability:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve(p, t):\n    # Calculate the number of divisors of t\n    divisors = []\n    for i in range(1, int(math.sqrt(t)) + 1):\n        if t % i == 0:\n            divisors.append(i)\n            if i!= t // i:\n                divisors.append(t // i)\n\n    # Initialize the result\n    result = 0\n\n    # Iterate over each divisor\n    for divisor in divisors:\n        # Calculate the probability of rain in the time it takes to reach the office\n        prob = p * (1 - p) ** (t // divisor)\n\n        # Update the result\n        result += prob * divisor\n\n    # Return the result modulo MOD\n    return result % MOD\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        print(f\"{solve(p, time):.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "def calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    # Read the number of test cases\n    t = int(input())\n    \n    # Loop through each test case\n    for _ in range(t):\n        # Read the probability and time\n        p = float(input().split()[0])\n        time = int(input().split()[1])\n        \n        # Calculate the expected time using the geometric series formula\n        expected_time = p * time + (1 - p) * (1 - p) * time / (1 - p)\n        \n        # Print the result rounded to 4 decimal places\n        print(round(expected_time, 4))\n\ncalculate_expected_time()", "import math\n\nMOD = 10**9 + 7\n\nfor _ in range(int(input())):\n    P, time = map(float, input().split())\n    total_minutes = 1440  # total minutes in a day\n    prob = P * (1 - P) * (time / total_minutes) + P * (1 - P) * ((total_minutes - time) / total_minutes)\n    print(f\"{prob:.4f}\")", "import math\n\ndef calculate_probability(p, time):\n    return (p * time) % (10**9 + 7)\n\nT = int(input())\nfor _ in range(T):\n    p, time = map(float, input().split())\n    result = calculate_probability(p, time)\n    print(\"{:.4f}\".format(result))", "import math\n\nMOD = 10**9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, time = map(float, input().split())\n\n    # Calculate the number of possible outcomes where it rains\n    num_rainy_outcomes = time * 2\n\n    # Calculate the probability of it raining\n    prob_rainy = P\n\n    # Calculate the probability of it not raining\n    prob_not_rainy = 1 - prob_rainy\n\n    # Calculate the expected number of rainy outcomes\n    expected_rainy_outcomes = num_rainy_outcomes * prob_rainy + (time * (time + 1) // 2) * prob_not_rainy\n\n    # Calculate the probability of it raining within the given time\n    prob_rainy_within_time = sum([prob_rainy * (prob_rainy ** (time - i)) * (1 - prob_rainy) * (1 - prob_rainy ** (time - i)) for i in range(time + 1)])\n\n    # Calculate the expected number of rainy outcomes within the given time\n    expected_rainy_outcomes_within_time = expected_rainy_outcomes * prob_rainy_within_time\n\n    # Print the result rounded to 4 decimal places\n    print(\"{:.4f}\".format(expected_rainy_outcomes_within_time))", "def calculate_probability(p, time):\n    total_minutes = 1440\n    minutes_per_hour = 60\n    minutes_per_divisor = time // minutes_per_hour\n    probability = p * (1 - ((1 - p) ** minutes_per_divisor))\n    return round(probability, 4)\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        p, time = map(float, input().split())\n        probability = calculate_probability(p, time)\n        print(probability)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * (1 - P) % MOD\n            t -= 1\n        else:\n            R = R * P % MOD\n            t //= 2\n    print('{:.4f}'.format(R))\nimport math\n\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n    R = P / (1 - (1 - P) ** t)\n    print('{:.4f}'.format(R))", "import math\n\ndef calculate_expected_time(t, p):\n    \"\"\"\n    Calculate the expected number of minutes that Logan will spend waiting for P to be sorted.\n\n    Args:\n    t (int): The time in minutes.\n    p (float): The probability that it rains today.\n\n    Returns:\n    float: The expected number of minutes.\n    \"\"\"\n    MOD = 10 ** 9 + 7\n    if t % 2 == 0:\n        D = (2 * p + (1 - p) * (1 + (2 * p))) % MOD\n        R = 1\n        while t > 0:\n            if t % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            t //= 2\n        return R\n    else:\n        D = (1 - (1 - p) * (1 + (2 * p))) % MOD\n        R = 1\n        while t > 0:\n            if t % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            t //= 2\n        return R\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        time /= 1440  # Convert minutes to hours\n        time *= 720  # Convert hours to minutes\n        time /= 1440  # Convert hours to days\n        expected_time = calculate_expected_time(int(time), p)\n        print(\"{:.4f}\".format(expected_time))\n\n\nif __name__ == \"__main__\":\n    main()", "import math\nMOD = 10 ** 9 + 7\n\ndef solve():\n    t, p, time = map(float, input().split())\n    p = 1 - t\n    ans = 0\n    for i in range(1, int(time // 1440) + 1):\n        ans += p * (1440 / i)\n    ans = round(ans, 4)\n    print(ans)\n\nT = int(input())\nfor _ in range(T):\n    solve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value(a, b, t):\n    \"\"\"\n    Calculate the expected number of virus cells after t milliseconds.\n    \n    Parameters:\n    a (int): The first growth factor.\n    b (int): The second growth factor.\n    t (int): The time in milliseconds.\n    \n    Returns:\n    int: The expected number of virus cells after t milliseconds modulo (10^9+7).\n    \"\"\"\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        # Convert probability to a fraction\n        p = 1 - p\n        # Calculate expected value\n        expected_value = calculate_expected_value(2, 4, time)\n        # Calculate probability of rain\n        probability_of_rain = p * (1 + expected_value) + (1 - p)\n        # Round probability to 4 decimal places\n        probability_of_rain = round(probability_of_rain, 4)\n        # Convert to string and print\n        print(\"{:.4f}\".format(probability_of_rain))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_time():\n    for _ in range(int(input())):\n        P, time = map(float, input().split())\n        total_minutes = 1440\n        total_seconds = total_minutes * 60\n        R = 1\n        D = (P + (1 - P)) // 2\n        R = R * D % MOD\n        D = D * D % MOD\n        for _ in range(time // 2):\n            R = R * D % MOD\n            D = D * D % MOD\n        R = R * (1 - D * (1 - P)) % MOD\n        R = R * (1 - D * P) % MOD\n        R = R * (1 - D) % MOD\n        R = R * P % MOD\n        R = R * 60 % MOD\n        print(f\"{R:.4f}\")\n\ncalculate_expected_time()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_time_to_sort(N, P):\n    # Calculate the expected time to sort the permutation\n    expected_time = 0\n    for i in range(1, N + 1):\n        probability = (1/2) ** i\n        expected_time += probability * i\n    return expected_time\n\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    # Convert time to minutes\n    time_in_minutes = time / 1440 * 60\n    # Calculate the expected time to sort the permutation\n    expected_time = expected_time_to_sort(int(time_in_minutes), P)\n    # Round the result to 4 decimal places\n    expected_time = round(expected_time, 4)\n    print(f\"{expected_time:.6f}\")", "MOD = 10 ** 9 + 7\n\ndef rain_probability(p, time):\n    return round(p * time, 4)\n\nT = int(input())\nfor _ in range(T):\n    p, time = map(float, input().split())\n    if p == 0:\n        print(0.0000)\n    elif p == 1:\n        print(1.0000)\n    else:\n        print(rain_probability(p, time))", "import math\n\ndef calculate_expected_value():\n    N = int(input())\n    a = list(map(float, input().split()))\n    \n    if a == sorted(a):\n        return 0\n    else:\n        num = 1\n        for i in a:\n            num *= math.factorial(int(i))\n        den = math.factorial(N)\n        return round((den / num), 6)\n\nT = int(input())\nfor _ in range(T):\n    print(calculate_expected_value())", "import math\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        R = 1\n        D = 1\n        for i in range(time):\n            if i % 2:\n                R = R * (1 - P) % MOD\n                D = D * (1 - P) % MOD\n            else:\n                R = R * P % MOD\n                D = D * P % MOD\n        print('{0:5.4f}'.format(R))\n\ncalculate_expected_time()", "import math\nfrom fractions import Fraction\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(a, b, t):\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return Fraction(R, MOD)\n\nT = int(input())\n\nfor _ in range(T):\n    a, t = map(float, input().split())\n    probability = calculate_probability(2*a, 2*b, t) * a + calculate_probability(2*a, 2*b, t) * b\n    print(f\"{probability:.4f}\")", "import math\n\ndef calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes to reach the office.\n    \n    Args:\n    rain_probability (float): The probability of rain.\n    travel_time (int): The time it takes to reach the office.\n    \n    Returns:\n    float: The probability that it rains during the time it takes to reach the office.\n    \"\"\"\n    # Calculate the probability that it does not rain during the time it takes to reach the office\n    no_rain_probability = (1 - rain_probability) ** (travel_time // 2)\n    \n    # Calculate the probability that it rains during the time it takes to reach the office\n    rain_probability_at_office = 2 * (rain_probability * no_rain_probability)\n    \n    return rain_probability_at_office\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability of rain and travel time\n    rain_probability, travel_time = map(float, input().split())\n    \n    # Calculate the probability that it rains during the time it takes to reach the office\n    probability = calculate_probability(rain_probability, travel_time)\n    \n    # Round the result to 4 decimal places\n    probability = round(probability, 4)\n    \n    # Print the result\n    print(f\"{probability:.4f}\")", "import math\n\ndef expected_rainfall_probability(rainfall_probability, travel_time):\n    \"\"\"\n    Calculate the probability of rainfall during travel time.\n\n    Args:\n    rainfall_probability (float): The probability of rainfall.\n    travel_time (int): The time taken for travel in minutes.\n\n    Returns:\n    float: The probability of rainfall during travel time.\n    \"\"\"\n    # Calculate the number of times the travel time can be divided by 1440\n    division_count = travel_time // 1440\n\n    # Calculate the remaining time after division\n    remaining_time = travel_time % 1440\n\n    # Calculate the probability of rainfall during the remaining time\n    remaining_probability = (1 - rainfall_probability) ** (1440 - remaining_time)\n\n    # Calculate the probability of rainfall during the division counts\n    division_probability = (1 - rainfall_probability) ** 1440\n\n    # Return the overall probability of rainfall during travel time\n    return (division_probability + remaining_probability) / 2\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability of rainfall and travel time\n    rainfall_probability, travel_time = map(float, input().split())\n\n    # Calculate and print the expected rainfall probability\n    print(round(expected_rainfall_probability(rainfall_probability, travel_time), 4))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    R = 1\n    D = (1 + p) // 2\n    while time > 0:\n        if time % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        time //= 2\n    return R\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        result = calculate_probability(p, time)\n        print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\nimport math\n\ndef calculate_expected_time(N):\n    return sum(i * (1/2)**i for i in range(1, N + 1))\n\ndef main():\n    N = int(input())\n    a = list(map(int, input().split()))\n    if a == sorted(a):\n        print(0)\n    else:\n        num = 1\n        for i in set(a):\n            num *= math.factorial(a.count(i))\n        den = math.factorial(N)\n        print('%0.6f' % (den / num))\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\n\ndef solve(P, time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes to reach the office.\n\n    Args:\n        P (float): The probability of rain.\n        time (int): The time it takes to reach the office.\n\n    Returns:\n        float: The probability that it rains during the time it takes to reach the office.\n    \"\"\"\n    return P * (1 - (1 - P) ** time)\n\n\nT = int(input())\n\nfor _ in range(T):\n    P, time = map(float, input().split())\n    print(f\"{solve(P, time):.4f}\")", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        P *= 1440\n        time *= 1440\n        probability = (1 - P) * (1 - P) ** time\n        print(f\"{probability:.4f}\")\n\ncalculate_expected_time()", "MOD = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    P, time = map(float, input().split())\n    R = P * (1 - (1 - P) ** time)\n    print(\"{0:.4f}\".format(R))", "import math\n\nMOD = 10**9 + 7\n\ndef calculate_expected_time(rainfall_probability, travel_time):\n    \"\"\"\n    Calculate the expected number of rainy days during the travel time.\n\n    Args:\n    rainfall_probability (float): The probability of rain in a given day.\n    travel_time (int): The time it takes to travel.\n\n    Returns:\n    float: The expected number of rainy days during the travel time.\n    \"\"\"\n    # Calculate the expected number of rainy days\n    expected_rainy_days = 0\n    for i in range(1, travel_time + 1):\n        # Calculate the probability of no rain on this day\n        no_rain_probability = (1 - rainfall_probability) ** i\n        # Calculate the probability of rain on this day\n        rain_probability = rainfall_probability * (1 - no_rain_probability)\n        # Add the probability of rain on this day to the expected number of rainy days\n        expected_rainy_days += rain_probability\n\n    # Return the expected number of rainy days, rounded to 4 decimal places\n    return round(expected_rainy_days, 4)\n\nT = int(input())\nfor _ in range(T):\n    rainfall_probability, travel_time = map(float, input().split())\n    print(calculate_expected_time(rainfall_probability, travel_time))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_value():\n    T = int(input())\n    for _ in range(T):\n        P = float(input())\n        time = int(input())\n        R = 1\n        D = (P + 1 - P * 2) * 2\n        while time > 0:\n            if time % 2:\n                R = (R * D) % MOD\n            D = (D * D) % MOD\n            time //= 2\n        print(f\"{R:.4f}\")\n\ncalculate_expected_value()", "import math\nfrom decimal import Decimal, getcontext\n\n# Set the precision for decimal operations\ngetcontext().prec = 30\n\nMOD = 10 ** 9 + 7\n\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(Decimal, input().split())\n    t = int(t)\n\n    # Calculate the sum of probabilities\n    sum_prob = 0\n    for i in range(1, t + 1):\n        sum_prob += (P ** i) * (1 - P ** (t - i))\n\n    # Calculate the expected number of rainfalls\n    expected_rainfalls = sum_prob / P\n\n    # Print the expected number of rainfalls\n    print(\"%.4f\" % expected_rainfalls)", "import math\n\ndef calculate_probability(rainfall, time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n\n    Args:\n    rainfall (float): The probability of rain today.\n    time (int): The time it will take for Raj to reach his office in minutes.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way to his office.\n    \"\"\"\n    # Calculate the probability that it rains during the time Raj is on the way\n    # This is equal to the probability of rain today multiplied by the probability that\n    # it rains during the remaining time, which is (1 - rainfall)^(time - 1)\n    probability = rainfall * (1 - rainfall) ** (time - 1)\n    \n    # Return the calculated probability\n    return probability\n\ndef main():\n    # Read the number of test cases\n    test_cases = int(input())\n\n    # Iterate over each test case\n    for _ in range(test_cases):\n        # Read the probability of rain and time\n        rainfall, time = map(float, input().split())\n\n        # Calculate the probability that it rains during the time Raj is on the way\n        probability = calculate_probability(rainfall, time)\n\n        # Print the result to 4 decimal places\n        print(\"{:.4f}\".format(probability))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(rain_probability, travel_time):\n    total_probability = rain_probability\n    for i in range(1, travel_time // 2 + 1):\n        total_probability = (total_probability * (1 - rain_probability) + \n                              total_probability * (rain_probability ** i))\n    \n    return total_probability\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P = float(input().split()[0])\n        t = int(input().split()[1])\n        probability = calculate_probability(P, t)\n        print(\"{0:.4f}\".format(probability))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(time, probability):\n    total_probability = 1\n    for i in range(time + 1):\n        total_probability = (total_probability + total_probability * (1 - probability) * (probability ** i)) % MOD\n    return total_probability\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        probability, time = map(float, input().split())\n        result = calculate_probability(time, probability)\n        print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        # Convert time from minutes to hours\n        time_in_hours = time / 60\n        # Calculate the probability of it not raining during the given time\n        prob_not_raining = (1 - P) ** time_in_hours\n        # Calculate the probability of it raining during the given time\n        prob_raining = 1 - prob_not_raining\n        # Round the result to 4 decimal places\n        prob_raining = round(prob_raining, 4)\n        print(prob_raining)\n\nsolve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, time):\n    # Calculate the probability of no rain\n    prob_no_rain = (1 - p) ** time\n    \n    # Calculate the probability of rain\n    prob_rain = 1 - prob_no_rain\n    \n    return prob_rain\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        p, time = map(float, input().split())\n        # Calculate the probability of rain\n        prob_rain = calculate_probability(p, time)\n        # Round the result to 4 decimal places\n        prob_rain = round(prob_rain, 4)\n        print(f\"{prob_rain:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10**9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P, t = map(float, input().split())\n    P = P / 2.0\n    t = 1440 / t\n    R = 1.0\n    for i in range(t):\n        R = R * (1.0 + P) % MOD\n        P = P * (1.0 - P) % MOD\n    print('{0:.4f}'.format(R))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_rain_probability(probability, time):\n    \"\"\"\n    Calculate the expected probability of rain during the given time.\n\n    Args:\n    probability (float): The probability of rain today.\n    time (int): The time (in minutes) it will take for Raj to reach his office.\n\n    Returns:\n    float: The expected probability of rain during the given time.\n    \"\"\"\n    return probability * time\n\n\ndef calculate_answer(test_cases):\n    \"\"\"\n    Calculate the answer for each test case and print the results.\n\n    Args:\n    test_cases (int): The number of test cases.\n    \"\"\"\n    for _ in range(test_cases):\n        probability, time = map(float, input().split())\n        answer = expected_rain_probability(probability, time)\n        print(f\"{answer:.4f}\")\n\n\nif __name__ == \"__main__\":\n    test_cases = int(input())\n    calculate_answer(test_cases)", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(rainfall_probability, time):\n    # Calculate the number of possible outcomes\n    outcomes = int(time / 1440) + 1\n\n    # Calculate the probability of rain during the time\n    probability = (1 - rainfall_probability) * (1 - rainfall_probability) ** outcomes\n\n    # Calculate the expected value\n    expected_value = (1 - probability) * time\n\n    return expected_value\n\ndef main():\n    test_cases = int(input())\n\n    for _ in range(test_cases):\n        rainfall_probability, time = map(float, input().split())\n\n        # Round the result to 4 decimal places\n        result = round(calculate_probability(rainfall_probability, time), 4)\n\n        print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P = float(input())\n    time = int(input())\n\n    if P == 0:\n        print(\"0.0000\")\n    else:\n        R = 1\n        D = (1 - P) * 2\n        T = time\n        while T > 0:\n            if T % 2:\n                R = R * D % MOD\n            D = D * D % MOD\n            T //= 2\n        print(\"{0:.4f}\".format(R))", "import math\n\ndef solve_problem():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        p, t = map(float, input().split())\n        t = int(t)\n        ans = 0\n        for i in range(t + 1):\n            if i % 2 == 0:\n                ans += p * (1 - p)**(t - i) * 2\n            else:\n                ans += (1 - p) * p**(t - i) * 2\n        ans = round(ans, 4)\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve_problem()", "import math\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    P = float(input())\n    t = int(input())\n\n    D = 1440 // t\n    R = 0\n    if P < 0.5:\n        R = 1 - P\n    else:\n        R = 2 * P * (1 - P)\n\n    for d in range(1, D + 1):\n        R += R * (d / t)\n\n    print(f\"{R:.4f}\")", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    t, time = map(float, input().split())\n    ans = 0\n    for i in range(1, int(time / 1440) + 1):\n        ans += (math.comb(int(time / 1440), i) * (t ** i) * ((1 - t) ** (int(time / 1440) - i)))\n    ans = round(ans * 1440 / (t * (1 - t)), 4)\n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()", "def calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time Raj is on the way to his office.\n\n    Args:\n    rain_probability (float): The probability that it will rain today.\n    travel_time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the time Raj is on the way.\n    \"\"\"\n    # Calculate the probability that it does not rain during the travel time\n    no_rain_probability = 1 - rain_probability\n    # Calculate the probability that it rains at least once during the travel time\n    rain_probability = 1 - (no_rain_probability ** travel_time)\n    return rain_probability\n\n\nMOD = 10 ** 9 + 7\nT = int(input())\n\nfor _ in range(T):\n    # Read the input values\n    rain_probability = float(input().split()[0])\n    travel_time = int(input().split()[1])\n    # Calculate the probability\n    probability = calculate_probability(rain_probability, travel_time)\n    # Round the probability to 4 decimal places\n    probability = round(probability, 4)\n    # Print the result\n    print(f\"{probability:.4f}\")", "import math\n\nMOD = 10**9 + 7\ndef calculate_probability(t, p):\n    total_minutes = 1440\n    time_factor = t // total_minutes\n    remaining_time = t % total_minutes\n    \n    # Calculate the probability for remaining time\n    prob_remaining_time = (1 - p) * pow(1 - p * (time_factor + 1), remaining_time, MOD)\n    # Calculate the probability for full days\n    prob_full_days = pow(1 - p * (time_factor + 1), total_minutes - remaining_time, MOD)\n    \n    # Combine the probabilities\n    return prob_remaining_time * prob_full_days % MOD\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    print(f\"{calculate_probability(int(t), p):.4f}\")", "MOD = 10 ** 9 + 7\n\nT = int(input())\n\nfor _ in range(T):\n    P, time = map(float, input().split())\n    P = int(P * 1440)\n    time = int(time * 1440)\n\n    # Calculate the expected value of the probability that it rains during the time\n    R = (P * time) % MOD\n\n    # Calculate the probability that it does not rain during the time\n    D = (MOD + MOD - time) % MOD\n    R = (R + D) % MOD\n\n    # Calculate the expected value of the probability that it rains during the time\n    R = (R * D) % MOD\n\n    # Calculate the final answer\n    R = R ** 1440 % MOD\n\n    print('{:.4f}'.format(R / 1440))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(a, b, t):\n    # Calculate the total number of factors of time\n    total_factors = 0\n    for i in range(1, int(math.sqrt(t)) + 1):\n        if t % i == 0:\n            total_factors += 1\n\n    # Initialize the result\n    result = 0\n\n    # Calculate the expected probability\n    for i in range(1, total_factors + 1):\n        if t // i!= i:\n            result += 2 * pow((1 - a), i - 1) * pow(a, i) * pow((1 - b), t // i - i) * pow(b, t // i)\n        else:\n            result += (1 - a) * pow(a, i) * pow((1 - b), t // i)\n\n    # Return the result modulo MOD\n    return int(result * (MOD // t))\n\ndef main():\n    # Read the number of test cases\n    t = int(input())\n\n    # Process each test case\n    for _ in range(t):\n        # Read the probability and time\n        a, t = map(float, input().split())\n\n        # Calculate and print the expected probability\n        print(\"{:.4f}\".format(calculate_probability(a, 1 - a, t)))\n\nif __name__ == \"__main__\":\n    main()", "import math\nfrom math import factorial\nimport sys\n\ndef calculate_expected_time():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        numerator = 0\n        for i in range(1, int(time/2) + 1):\n            numerator += (i * p * (1 - p) ** (time - i) * 2)\n        denominator = 1 - p\n        print(f'{numerator / denominator:.4f}')\n\ncalculate_expected_time()", "def calculate_expected_value(probability, time):\n    MOD = 10**9 + 7\n    num = 1\n    denominator = 1\n    for i in range(time):\n        num = (num * (1 + probability)) % MOD\n        denominator = denominator * (1 + probability) % MOD\n        probability = (2 * probability) % MOD\n    return (num * pow(denominator, -1, MOD)) % MOD\n\nT = int(input())\nfor _ in range(T):\n    P = float(input().split()[0])\n    t = int(input().split()[1])\n    print(\"{0:5.4f}\".format(calculate_expected_value(P, t)))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        R = 1\n        D = 1\n        for i in range(t):\n            R = R * (1 - P + P) % MOD\n            D = D * (1 + P) % MOD\n        print('{:.4f}'.format(R))\n\nsolve()", "def solve():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        minutes = (time // 1440) * 1440\n        prob = 1\n        for _ in range(minutes):\n            prob = (prob + p) % 1\n        print('{0:.4f}'.format(prob))\n\nif __name__ == \"__main__\":\n    solve()", "def calculate_probability(t, p):\n    # calculate the probability of no rain\n    no_rain_prob = (1 - p) ** t\n\n    # calculate the probability of rain\n    rain_prob = 1 - no_rain_prob\n\n    # return the probability of rain\n    return rain_prob\n\n# get the number of test cases\nT = int(input())\n\n# loop through each test case\nfor _ in range(T):\n    # get the probability of rain and time\n    p, t = map(float, input().split())\n\n    # calculate the probability of rain\n    prob = calculate_probability(t, p)\n\n    # round the answer to 4 decimal places\n    prob = round(prob, 4)\n\n    # print the answer\n    print(prob)", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(probability, time):\n    # Calculate the probability that it rains during the time\n    probability_rain = probability * (1 - (1 - probability) ** time)\n    \n    return probability_rain\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        probability, time = map(float, input().split())\n        probability_rain = calculate_probability(probability, time)\n        probability_rain = round(probability_rain, 4)\n        print(f\"{probability_rain:.6f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(rainfall_probability, time):\n    probability = 0\n    for i in range(time // 1440 + 1):\n        # Calculate the number of minutes it will rain\n        rain_minutes = i * 1440\n        # Calculate the probability of it raining for the remaining time\n        remaining_probability = (rainfall_probability ** rain_minutes) * ((1 - rainfall_probability) ** (time - rain_minutes))\n        # Add the probability to the total probability\n        probability += remaining_probability\n    # Return the total probability\n    return probability % MOD\n\ndef main():\n    # Read the number of test cases\n    test_cases = int(input())\n    for _ in range(test_cases):\n        # Read the probability of rainfall and the time\n        rainfall_probability, time = map(float, input().split())\n        # Calculate the probability of rainfall during the time\n        probability = calculate_probability(rainfall_probability, time)\n        # Print the result\n        print(f\"{probability:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        print(\"{0:.4f}\".format(P * t))\n\nsolve()", "import math\n\ndef calculate_expected_time(T, P, time):\n    \"\"\"\n    Calculate the expected time for it to rain during Raj's trip.\n\n    Args:\n    T (float): The total time (in minutes) it takes for Raj to reach his office.\n    P (float): The probability of rain today.\n    time (int): The time (in minutes) it will take for Raj to reach his office.\n\n    Returns:\n    float: The expected time for it to rain during Raj's trip.\n    \"\"\"\n    # Calculate the expected time using the formula for geometric series\n    expected_time = P * time + (1 - P) * (T - time)\n    return expected_time\n\nMOD = 10 ** 9 + 7\n\ndef solve_problem():\n    \"\"\"\n    Solve the problem.\n    \"\"\"\n    T = int(input())\n    for _ in range(T):\n        P, time = map(float, input().split())\n        expected_time = calculate_expected_time(1440, P, time)\n        expected_time %= MOD  # Calculate modulo to avoid overflow\n        expected_time = round(expected_time, 4)  # Round to 4 decimal places\n        print(f\"{expected_time}\")\n\nif __name__ == \"__main__\":\n    solve_problem()", "import math\nimport sys\n\ndef logan_wait_time():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(int, input().split()))\n        if a == sorted(a):\n            print(0)\n        else:\n            m = {}\n            for i in a:\n                if i in m:\n                    m[i] += 1\n                else:\n                    m[i] = 1\n            num = 1\n            for i in m:\n                num *= math.factorial(m[i])\n            den = math.factorial(N)\n            print('{:.6f}'.format(den / num))\n\nlogan_wait_time()", "def calculate_probability(rain_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the travel time.\n\n    Args:\n    rain_probability (float): The probability that it will rain today.\n    travel_time (int): The time it will take for Raj to reach his office.\n\n    Returns:\n    float: The probability that it rains during the travel time.\n    \"\"\"\n    # Calculate the probability that it does not rain during the travel time\n    no_rain_probability = 1 - rain_probability\n    # Calculate the probability that it rains during the travel time using the formula for the sum of a geometric series\n    rain_probability_during_travel = (rain_probability - (no_rain_probability ** travel_time)) / (1 - (no_rain_probability ** travel_time))\n    return round(rain_probability_during_travel, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    # Read the probability of rain and travel time\n    rain_probability, travel_time = map(float, input().split())\n    # Calculate and print the result\n    print(calculate_probability(rain_probability, travel_time))", "import math\n\ndef calculate_probability(rainfall_probability, travel_time):\n    \"\"\"\n    Calculate the probability that it rains during the time it takes for Raj to reach his office.\n\n    Args:\n        rainfall_probability (float): The probability that it will rain today.\n        travel_time (int): The time it takes for Raj to reach his office.\n\n    Returns:\n        float: The probability that it rains during the time it takes for Raj to reach his office.\n    \"\"\"\n    # Calculate the expected number of rainfalls during the travel time\n    expected_rainfalls = rainfall_probability * travel_time\n\n    # Calculate the probability that it rains during the travel time\n    probability = 1 - (1 - rainfall_probability) ** travel_time\n\n    return probability\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    t = int(input())\n    for _ in range(t):\n        rainfall_probability = float(input())\n        travel_time = int(input())\n        probability = calculate_probability(rainfall_probability, travel_time)\n        print(format(probability, '.4f'))\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time(probability, time):\n    expected_value = 0\n    for i in range(time + 1):\n        expected_value += (probability ** i) * (time - i)\n    return expected_value\n\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    expected_value = calculate_expected_time(P, t)\n    print('{:.4f}'.format(expected_value))", "import math\n\ndef calculate_probability(rainfall_probability, travel_time):\n    # Calculate the number of possible outcomes\n    possible_outcomes = 2\n    \n    # Calculate the probability of no rain\n    no_rain_probability = (1 - rainfall_probability) ** travel_time\n    \n    # Calculate the expected number of rainy days\n    expected_rainy_days = possible_outcomes * rainfall_probability * no_rain_probability\n    \n    # Since we only care about whether it rains or not, the expected number of rainy days is equal to the probability of rain\n    return round(expected_rainy_days, 4)\n\nT = int(input())\nfor _ in range(T):\n    rainfall_probability, travel_time = map(float, input().split())\n    print(calculate_probability(rainfall_probability, travel_time))", "import math\n\nMOD = 10**9 + 7\ndef expected_rainfall_probability(rainfall_probability, time):\n    # calculate the probability that it rains during the given time\n    return (1 - (1 - rainfall_probability) ** time) * 100\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        print(f\"{expected_rainfall_probability(p, time) / 100:.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time(T, t, P):\n    expected_time = 0\n    for time in range(t + 1):\n        # Calculate the probability of rain for the given time\n        prob_rain = math.comb(t, time) * (P ** time) * ((1 - P) ** (t - time))\n        # Calculate the expected number of minutes to reach the destination\n        exp_time = time * t - (t - time) * time / 2\n        # Update the expected time\n        expected_time += prob_rain * exp_time\n    return expected_time % MOD\n\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    print(f\"{calculate_expected_time(t, t, P):.4f}\")", "MOD = 10 ** 9 + 7\n\nfor _ in range(int(input())):\n    P, t = map(float, input().split())\n    p = 1\n    for i in range(t):\n        p = p * (1 - P) + P * p\n    print(\"{0:.4f}\".format(p))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_time(probability, time):\n    if probability == 0:\n        return 0\n    elif probability == 1:\n        return time\n    else:\n        result = 0\n        for i in range(time + 1):\n            result += (probability * (time - i)) * (1 - probability ** i)\n        return result\n\nT = int(input())\nfor _ in range(T):\n    probability, time = map(float, input().split())\n    print(round(expected_time(probability, time), 4))", "from math import factorial\n\ndef logan_time(N, a):\n    total_time = 0\n    for i in range(1, N + 1):\n        total_time += (i * (2 ** -(i - 1)))\n    return total_time\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        a = list(map(int, input().split()))\n        if a == sorted(a):\n            print(0)\n        else:\n            m = {}\n            for i in a:\n                if i in m:\n                    m[i] += 1\n                else:\n                    m[i] = 1\n            num = 1\n            for i in m:\n                num *= factorial(m[i])\n            den = factorial(N)\n            print('%0.6f' % (den / num))\n\nif __name__ == \"__main__\":\n    main()\nMOD = 10 ** 9 + 7\n\ndef virus_growth(A, B, T):\n    D = (A + B) // 2\n    R = 1\n    while T > 0:\n        if T % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        T //= 2\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        A, B, T = map(int, input().split())\n        result = (A * (1 - pow(B, T, MOD)) + B * (1 - pow(A, T, MOD))) % MOD\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        p, time = map(float, input().split())\n        n = time // 1440\n        k = time % 1440\n        result = (p * n) + ((1 - p) * sum(math.comb(2 * k + 1, i) * (p ** i) * ((1 - p) ** (2 * k + 1 - i)) for i in range(k + 1)))\n        result = round(result, 4)\n        print(f\"{result:.4f}\")\n\nsolve()", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_probability(p, t):\n    # Calculate the probability that it does not rain during the time\n    prob_not_rain = 1 - p\n    \n    # Calculate the expected number of rainy days\n    expected_rainy_days = (1 - prob_not_rain) * t + p\n    \n    # Return the expected number of rainy days modulo MOD\n    return int(expected_rainy_days % MOD)\n\nT = int(input())\n\nfor _ in range(T):\n    p, t = map(float, input().split())\n    \n    # Calculate the probability that it rains during the time\n    prob_rain = 1 - (calculate_probability(1-p, t) / 100)\n    \n    # Print the result rounded to 4 decimal places\n    print('{:.4f}'.format(prob_rain))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef expected_time(R, T):\n    R = 1 if R == 0 else R\n    R = R * (1 - R) % MOD\n    R = R * (1 + R) % MOD\n    R = R * (1 + (R ** 2)) % MOD\n    R = R * (1 + ((1 + R) * (R ** 2))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 4))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 8))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 16))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 32))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 64))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 128))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 256))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 512))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 1024))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 2048))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 4096))) % MOD\n    R = R * (1 + ((1 + R) * (R ** 8192))) % MOD\n    return R\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        P, t = map(float, input().split())\n        print(f\"{expected_time(P, t):.4f}\")\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\nimport math\n\ndef calculate_probability(rainfall_probability, time):\n    # Calculate the expected number of rainy hours\n    expected_rainy_hours = (rainfall_probability / (1 - rainfall_probability)) * time\n\n    # Calculate the expected number of rainy minutes\n    expected_rainy_minutes = expected_rainy_hours / 60\n\n    # Calculate the expected number of rainy hours modulo MOD\n    result = (math.floor(expected_rainy_minutes) % MOD) % MOD\n    return result\n\nT = int(input())\nfor _ in range(T):\n    P, t = map(float, input().split())\n    result = calculate_probability(P, t)\n    print(f\"{result:.4f}\")", "import math\nimport sys\n\ndef calculate_expected_value(N, P):\n    expected_value = 0\n    for i in range(1, N+1):\n        probability = 2 ** (-i)\n        expected_value += i * probability\n    return expected_value\n\ndef calculate_virus_cells(a, b, t):\n    MOD = 10 ** 9 + 7\n    D = (a + b) // 2\n    R = 1\n    while t > 0:\n        if t % 2:\n            R = R * D % MOD\n        D = D * D % MOD\n        t //= 2\n    return R\n\ndef calculate_rain_probability(p, t):\n    return p * t\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input().split()[0])\n        P = float(input().split()[0])\n        time = int(input().split()[1])\n        \n        if P == 0:\n            print('{:.4f}'.format(calculate_rain_probability(P, time)))\n        else:\n            print('{:.4f}'.format(calculate_expected_value(N, P)))\n\nif __name__ == \"__main__\":\n    main()", "MOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    P, time = map(float, input().split())\n    D = (1 + P) * (1 - (1 - P) ** time) / P\n    print(\"{0:.4f}\".format(D))", "import math\n\ndef expected_rain_probability(rain_probability, travel_time):\n    # Calculate the probability that it rains during the entire travel time\n    # This is the complement of the probability that it doesn't rain at all\n    # We use the formula for the sum of an infinite geometric series\n    total_probability = 1 - (1 - rain_probability) ** math.floor(travel_time / 1440)\n    return round(total_probability, 4)\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\nfor _ in range(test_cases):\n    rain_probability, travel_time = map(float, input().split())\n    print(expected_rain_probability(rain_probability, travel_time))", "import math\n\nMOD = 10 ** 9 + 7\n\ndef calculate_expected_time(T, p, t):\n    \"\"\"\n    Calculate the expected time it takes for it to rain during the trip.\n\n    Args:\n    T (int): Time taken to reach the office.\n    p (float): Probability of rain.\n    t (int): Time taken to reach the office.\n\n    Returns:\n    float: Expected time it takes for it to rain during the trip.\n    \"\"\"\n    R = 1\n    D = 1\n    for i in range(t):\n        if i % 2 == 0:\n            R = R * (1 - p) % MOD\n            D = D * (1 - p) % MOD\n        else:\n            R = R * p % MOD\n            D = D * p % MOD\n    return R\n\nT = int(input())\nfor _ in range(T):\n    p, t = map(float, input().split())\n    t /= 1440  # Convert time to minutes\n    expected_time = calculate_expected_time(t, p, t)\n    print(f\"{expected_time:.4f}\")"]}]