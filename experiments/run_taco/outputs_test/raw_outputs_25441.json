{"id": 25441, "input": "Optimistan is a strange country. It is situated on an island with a huge desert in the middle, so most people live in port towns along the coast. As the name suggests, people of Optimistan (also called Optimists) like to optimise everything, so they only built roads necessary to connect all port towns together and not a single extra road. That means that there is only one way to get from one port town to another without visiting the same place twice.\n\nThe government installed multi-directional distance signs in $1$-kilometre intervals on one side of the road, to provide important information to drivers. Thus whenever you go from one port town to another, you pass the first sign at the port town and then one each kilometre. Every distance sign contains the shortest distances to all port towns, each written on a separate small sign directed towards the goal town.\n\nThe signs also serve another important function: to guide drivers on intersections. This means that distance of each intersection from every port town is an integer number of kilometres.\n\nYou bought a tourist guide of Optimistan which does not have a map of the country, but it contains a huge table with the shortest distances between all pairs of port towns. You quickly calculated the average shortest distance between all pairs of port towns, but then you started wondering: if the signs also contained shortest distances to all other signs, what would be the average number written on a sign? Could this be calculated just from the distance table in the tourist guide?\n\n-----Input-----\nThe input consists of:\n - one line with an integer $n$ ($2 \\le n \\le 500$), the number of ports;\n - $n-1$ lines, the $i$th of which contains $n-i$ integers. The $j$th integer on the $i$th line denotes the distance between port $i$ and port $i+j$ in kilometres. Each distance is between $1$ and $10^6$ (inclusive).\n\nYou can assume that the distances correspond to a road network in which there is exactly one path between two port towns that does not visit the same place twice. All roads can be used in both directions.\n\n-----Output-----\nOutput one line with the average distances in kilometres between all pairs of distance signs in Optimistan. Your answer should have an absolute or relative error of at most $10^{-9}$.\n\nIf it is impossible to determine the exact average of distances between all pairs of distance signs in Optimistan, output \u201cimpossible\u201d.\n\n-----Examples-----\nSample Input:\n3\n4 4\n2\nSample Output:\n2.13333333333333\n", "difficulty": "HARD", "generations": [{"generated_text": "Sample Input:\n4\n4 5 6\n5 3 4\n6 7 8\nSample Output:\n4.16666666666667\nSample Input:\n5\n2 3 4 5\n3 2 3 4\n4 3 2 3\n5 4 3 2\nSample Output:\n3.2\n\n```python\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nD = []\nfor _ in range(N-1):\n    D.append(list(map(int, input().split())))\n\ndist = [[0 for i in range(N)] for j in range(N)]\nfor i in range(N):\n    for j in range(N-i):\n        dist[i][i+j] = D[i][j]\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\ndef is_int(x):\n    return x == int(x)\n\ndef is_int_array(arr):\n    return all(is_int(x) for x in arr)\n\ndef is_int_matrix(mat):\n    return all(is_int_array(row) for row in mat)\n\ndef is_symmetric(mat):\n    return all(mat[i][j] == mat[j][i] for i in range(len(mat)) for j in range(len(mat)))\n\ndef is_valid(mat):\n    return is_symmetric(mat) and is_int_matrix(mat)\n\ndef is_connected(mat):\n    return all(mat[i][j]!= float('inf') for i in range(len(mat)) for j in range(len(mat)))\n\ndef is_tree(mat):\n    return is_valid(mat) and is_connected(mat)\n\nif not is_tree(dist):\n    print(\"impossible\")\n    sys.exit(0)\n\ndef get_path_length(mat, start, end):\n    if start == end:\n        return 0\n\n    path = [start]\n    while len(path) > 0 and path[-1]!= end:\n        for i in range(len(mat)):\n            if i not in path and mat[path[-1]][i] == 1:\n                path.append(i)\n                break\n    return len(path) - 1\n\ndef get_average_distance(mat):\n    total = 0\n    count = 0\n    for i in range(len(mat)):\n        for j in"}, {"generated_text": "Sample Input:\n4\n5 7 8\n3 6 9\n2 5 7\nSample Output:\n4.14285714285714\nSample Input:\n5\n5 7 9 11\n4 6 8 10\n3 5 7 9\n2 4 6 8\nSample Output:\n4.2\n```python\nimport sys\nimport math\nimport bisect\nfrom collections import Counter, defaultdict, deque\nfrom functools import lru_cache, reduce\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, combinations, permutations\nfrom operator import add, iand, ior, itemgetter, mul, xor\nfrom typing import *\n\ninf = float('inf')\nmod = 10 ** 9 + 7\nmod2 = 998244353\n\ndef main():\n    n = int(sys.stdin.readline())\n    d = [[inf] * n for _ in range(n)]\n    for i in range(n - 1):\n        d[i][i:] = list(map(int, sys.stdin.readline().split()))\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] += dp[i][k] * dp[k][j]\n\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            ans += d[i][j] * dp[i][j]\n\n    if n == 2:\n        ans = 2 * d[0][1]\n\n    ans /= n * (n - 1) * (n - 2) // 6\n\n    if ans < 0:\n        print('impossible')\n    else:\n        print(ans)\n\nmain()\n```python\ndef main():\n    n = int(input())\n    d = [[inf] * n for _ in range(n)]\n    for i in range(n - 1):\n        d[i][i:] = list(map"}]}